/*

USE [master]
GO
/****** Object:  Database [DBServices]    Script Date: 9/14/2016 5:15:46 PM ******/
CREATE DATABASE [DBServices]
 CONTAINMENT = NONE
 ON  PRIMARY 
( NAME = N'DBServices', FILENAME = N'M:\MP_Group_1\MP_Data1\MSSQL11\MSSQL11.MSSQLSERVER\MSSQL\Data\DBServices.mdf' , SIZE = 614400KB , MAXSIZE = UNLIMITED, FILEGROWTH = 0)
 LOG ON 
( NAME = N'DBServices_log', FILENAME = N'M:\MP_Group_2\MP_Log1\MSSQL11\MSSQL11.MSSQLSERVER\MSSQL\TLog\DBServices_log.ldf' , SIZE = 614400KB , MAXSIZE = 2048GB , FILEGROWTH = 0)
GO
ALTER DATABASE [DBServices] SET COMPATIBILITY_LEVEL = 110
GO
IF (1 = FULLTEXTSERVICEPROPERTY('IsFullTextInstalled'))
begin
EXEC [DBServices].[dbo].[sp_fulltext_database] @action = 'enable'
end
GO
ALTER DATABASE [DBServices] SET ANSI_NULL_DEFAULT OFF 
GO
ALTER DATABASE [DBServices] SET ANSI_NULLS OFF 
GO
ALTER DATABASE [DBServices] SET ANSI_PADDING OFF 
GO
ALTER DATABASE [DBServices] SET ANSI_WARNINGS OFF 
GO
ALTER DATABASE [DBServices] SET ARITHABORT OFF 
GO
ALTER DATABASE [DBServices] SET AUTO_CLOSE OFF 
GO
ALTER DATABASE [DBServices] SET AUTO_CREATE_STATISTICS ON 
GO
ALTER DATABASE [DBServices] SET AUTO_SHRINK OFF 
GO
ALTER DATABASE [DBServices] SET AUTO_UPDATE_STATISTICS ON 
GO
ALTER DATABASE [DBServices] SET CURSOR_CLOSE_ON_COMMIT OFF 
GO
ALTER DATABASE [DBServices] SET CURSOR_DEFAULT  GLOBAL 
GO
ALTER DATABASE [DBServices] SET CONCAT_NULL_YIELDS_NULL OFF 
GO
ALTER DATABASE [DBServices] SET NUMERIC_ROUNDABORT OFF 
GO
ALTER DATABASE [DBServices] SET QUOTED_IDENTIFIER OFF 
GO
ALTER DATABASE [DBServices] SET RECURSIVE_TRIGGERS OFF 
GO
ALTER DATABASE [DBServices] SET  ENABLE_BROKER 
GO
ALTER DATABASE [DBServices] SET AUTO_UPDATE_STATISTICS_ASYNC OFF 
GO
ALTER DATABASE [DBServices] SET DATE_CORRELATION_OPTIMIZATION OFF 
GO
ALTER DATABASE [DBServices] SET TRUSTWORTHY ON 
GO
ALTER DATABASE [DBServices] SET ALLOW_SNAPSHOT_ISOLATION OFF 
GO
ALTER DATABASE [DBServices] SET PARAMETERIZATION SIMPLE 
GO
ALTER DATABASE [DBServices] SET READ_COMMITTED_SNAPSHOT OFF 
GO
ALTER DATABASE [DBServices] SET HONOR_BROKER_PRIORITY OFF 
GO
ALTER DATABASE [DBServices] SET RECOVERY SIMPLE 
GO
ALTER DATABASE [DBServices] SET  MULTI_USER 
GO
ALTER DATABASE [DBServices] SET PAGE_VERIFY CHECKSUM  
GO
ALTER DATABASE [DBServices] SET DB_CHAINING OFF 
GO
ALTER DATABASE [DBServices] SET FILESTREAM( NON_TRANSACTED_ACCESS = OFF ) 
GO
ALTER DATABASE [DBServices] SET TARGET_RECOVERY_TIME = 0 SECONDS 
GO
EXEC sys.sp_db_vardecimal_storage_format N'DBServices', N'ON'
GO
USE [DBServices]
GO
/****** Object:  XmlSchemaCollection [dbo].[CommVaultRestore]    Script Date: 9/14/2016 5:15:50 PM ******/
CREATE XML SCHEMA COLLECTION [dbo].[CommVaultRestore] AS N'<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"><xsd:element name="TMMsg_CreateTaskReq"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="taskInfo"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="task"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="taskFlags"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="disabled" type="xsd:boolean" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="policyType" type="xsd:string" /><xsd:element name="taskType" type="xsd:string" /><xsd:element name="initiatedFrom" type="xsd:string" /><xsd:element name="alert"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="alertName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="associations"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="backupsetName" type="xsd:string" /><xsd:element name="subclientName" type="xsd:string" /><xsd:element name="clientName" type="xsd:string" /><xsd:element name="appName" type="xsd:string" /><xsd:element name="instanceName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="subTasks"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="subTask"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="subTaskType" type="xsd:string" /><xsd:element name="operationType" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="options"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="restoreOptions"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="browseOption"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="commCellId" type="xsd:int" /><xsd:element name="backupset"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="clientName" type="xsd:string" /><xsd:element name="backupsetName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="timeRange"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="toTimeValue" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="noImage" type="xsd:boolean" /><xsd:element name="useExactIndex" type="xsd:boolean" /><xsd:element name="mediaOption"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="library" type="xsd:string" /><xsd:element name="mediaAgent" type="xsd:string" /><xsd:element name="drivePool" type="xsd:string" /><xsd:element name="drive" type="xsd:string" /><xsd:element name="copyPrecedence"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="copyPrecedenceApplicable" type="xsd:boolean" /><xsd:element name="synchronousCopyPrecedence" type="xsd:int" /><xsd:element name="copyPrecedence" type="xsd:int" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="proxyForSnapClients"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="clientName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="timeZone"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="TimeZoneName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="listMedia" type="xsd:boolean" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="destination"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="destClient"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="clientName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="destinationInstance"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="clientName" type="xsd:string" /><xsd:element name="appName" type="xsd:string" /><xsd:element name="instanceName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="sqlServerRstOption"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="dbOnly" type="xsd:boolean" /><xsd:element name="overWrite" type="xsd:boolean" /><xsd:element name="pointOfTimeRst" type="xsd:boolean" /><xsd:element name="sqlRestoreType" type="xsd:string" /><xsd:element name="sqlRecoverType" type="xsd:string" /><xsd:element name="stopStartSSA" type="xsd:boolean" /><xsd:element name="stopMarkRestore" type="xsd:boolean" /><xsd:element name="stopBeforeMarkRestore" type="xsd:boolean" /><xsd:element name="partialRestore" type="xsd:boolean" /><xsd:element name="logShippingOnly" type="xsd:boolean" /><xsd:element name="ffgRestore" type="xsd:boolean" /><xsd:element name="ignoreFullBackup" type="xsd:boolean" /><xsd:element name="vSSBackup" type="xsd:boolean" /><xsd:element name="device" type="xsd:string" minOccurs="0" maxOccurs="unbounded" /><xsd:element name="restoreSource" type="xsd:string" /><xsd:element name="database" type="xsd:string" /><xsd:element name="timeZone"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="TimeZoneName" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="keepDataCapture" type="xsd:boolean" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="fileOption"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="mapFiles" minOccurs="0" maxOccurs="unbounded"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="renameFilesSuffix" type="xsd:string" minOccurs="0" maxOccurs="unbounded" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="commonOptions"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="detectRegularExpression" type="xsd:boolean" /><xsd:element name="restoreDeviceFilesAsRegularFiles" type="xsd:boolean" /><xsd:element name="restoreSpaceRestrictions" type="xsd:boolean" /><xsd:element name="ignoreNamespaceRequirements" type="xsd:boolean" /><xsd:element name="skipErrorsAndContinue" type="xsd:boolean" /><xsd:element name="onePassRestore" type="xsd:boolean" /><xsd:element name="revert" type="xsd:boolean" /><xsd:element name="recoverAllProtectedMails" type="xsd:boolean" /><xsd:element name="isFromBrowseBackup" type="xsd:boolean" /><xsd:element name="clusterDBBackedup" type="xsd:boolean" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="adminOpts"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="updateOption" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="commonOpts"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="startUpOpts"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="startInSuspendedState" type="xsd:boolean" /><xsd:element name="priority" type="xsd:int" /><xsd:element name="useDefaultPriority" type="xsd:boolean" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="prePostOpts"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="preRecoveryCommand" type="xsd:string" /><xsd:element name="postRecoveryCommand" type="xsd:string" /><xsd:element name="impersonation"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="level" type="xsd:string" /><xsd:element name="user"><xsd:complexType><xsd:complexContent><xsd:restriction base="xsd:anyType"><xsd:sequence><xsd:element name="userName" type="xsd:string" nillable="true" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="runPostWhenFail" type="xsd:boolean" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element><xsd:element name="jobDescription" type="xsd:string" /></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:sequence></xsd:restriction></xsd:complexContent></xsd:complexType></xsd:element></xsd:schema>'
GO
/****** Object:  StoredProcedure [dbo].[msc_ExecuteRemoteSQL]    Script Date: 9/14/2016 5:15:50 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_ExecuteRemoteSQL] @sql1 nvarchar(4000), @sql2 nvarchar(4000) = NULL, @sql3 nvarchar(4000) = NULL

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: msc_ExecuteRemoteSQL.sql
// 
// Purpose:
//   Update MSSQLCentral with new data from dbsDatabase, abstract code used to 
//		identify if we have MSSQL integration turned on or off
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

--NSTM0621DAP, MSSQLCentral

BEGIN  --Begin main()
	DECLARE @RC int,
			@MSSQLCentralPrimaryServer nvarchar(255),
			@MSSQLCentralPrimaryDatabase	nvarchar(255),
			@sql nvarchar(4000),
			@MSSQLCentralInstanceID nvarchar(255)


	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryServer', @MSSQLCentralPrimaryServer OUTPUT 
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryDatabase', @MSSQLCentralPrimaryDatabase OUTPUT 
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralInstanceID', @MSSQLCentralInstanceID OUTPUT


	IF @sql1 IS NOT NULL and @sql2 IS NULL and @sql3 IS NULL
		BEGIN 
			SELECT @sql = 'osql -w 2000  -S ' + @MSSQLCentralPrimaryServer + ' -E -d ' +  @MSSQLCentralPrimaryDatabase + ' -Q "' + @sql1  + '"'  
		END
	ELSE IF @sql1 IS NOT NULL and @sql2 IS NOT NULL and @sql3 IS NULL
		BEGIN 
			SELECT @sql = 'osql -w 2000  -S ' + @MSSQLCentralPrimaryServer + ' -E -d ' +  @MSSQLCentralPrimaryDatabase + ' -Q "' + @sql1 + @sql2 + '"'  
		END
	ELSE IF @sql1 IS NOT NULL and @sql2 IS NOT NULL and @sql3 IS NOT NULL
		BEGIN 
			SELECT @sql = 'osql -w 2000  -S ' + @MSSQLCentralPrimaryServer + ' -E -d ' +  @MSSQLCentralPrimaryDatabase + ' -Q "' + @sql1 + @sql2 + @sql3 + '"'  
		END

	IF @sql IS NOT NULL
		BEGIN
			exec master..xp_cmdshell @sql
		END
	ELSE
		BEGIN
			PRINT 'No valid statement to execute, BUG this to Database Engineering'
		END

END --main()


GO
/****** Object:  StoredProcedure [dbo].[msc_InsertMSCCQ]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_InsertMSCCQ]
			@sql1 nvarchar(4000)
			,@sql2 nvarchar(4000) = NULL
			,@sql3 nvarchar(4000) = NULL
AS
/****************************************************************************************
// @File: msc_InsertMSCCQ.sql
// 
// Purpose:
//   Update MSSQLCentral with new data from dbsDatabase, abstract code used to 
//		identify if we have MSSQL integration turned on or off
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 25/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 tidy
//
****************************************************************************************/
BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @sql nvarchar(4000)
	, @RC int

SET @sql = @sql1 + ISNULL(@sql2, '') + ISNULL(@sql3, '')

IF @sql IS NOT NULL
BEGIN
	INSERT INTO DBServices.dbo.[dbsMSSQLCentralCommandQueue]
		([MSCCQCommand])
    VALUES (@sql)
	
	SET @RC = @@ERROR
	
	RETURN @RC
END
ELSE --------------------------
BEGIN
	PRINT 'UBSMWE: msc_InsertMSCCQ: No valid statement to execute - please forward details to Database Engineering'
	
	RETURN 1
END

END --main()

GO
/****** Object:  StoredProcedure [dbo].[msc_MSCCQGetCommands]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_MSCCQGetCommands]
AS

/****************************************************************************************
// @File: msc_MSCCQGetCommands.sql.SQL
// 
// Purpose:
//   Creates the commands needed for batch processing to MSSQLCentral Server.
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 10/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Created
//   @Date: 25/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRV3 Tidy up 
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @MSCCQID_MAX bigint
		,@MSCCQID_MIN bigint
		,@MSCCQID_Count int

------------------------------------

SELECT @MSCCQID_Count = COUNT(*)
	,@MSCCQID_MIN = MIN(MSCCQID)
FROM DBServices.dbo.dbsMSSQLCentralCommandQueue 
WHERE MSCCQIsProccessed = 0

--Set to process all data within 5 hrs when the job runs every 10 min(5 *(60/10)) 

IF (@MSCCQID_Count /(5*(60/10))) < 100
	SET @MSCCQID_MAX = @MSCCQID_MIN + 100
ELSE
	SET @MSCCQID_MAX = @MSCCQID_MIN + (@MSCCQID_Count / (5*(60/10)))

----------------
-- Outputs a cmd wrapper for MSCCQCommand action

SELECT CAST(
	('SET NOCOUNT ON 
	BEGIN TRY 
		' + MSCCQCommand + ' 
		PRINT ''UPDATE dbo.dbsMSSQLCentralCommandQueue 
		SET MSCCQIsProccessed = 1, 
		MSCCQResult = ''''Success.'''' 
		WHERE MSCCQID = ' + CAST(MSCCQID as varchar(25)) + '' + ''' 
	END TRY 

	BEGIN CATCH 
		PRINT ''UPDATE dbo.dbsMSSQLCentralCommandQueue 
		SET MSCCQIsProccessed = 1, 
		MSCCQResult = ''''Error pusing to MSSQLCentral, restart main UBSMWE job to fix.'''' 
		WHERE MSCCQID = ' + CAST(MSCCQID as varchar(25)) + '''
	END CATCH'
	) as nvarchar(2000)) 

FROM DBServices.dbo.dbsMSSQLCentralCommandQueue

WHERE MSCCQIsProccessed = 0
	AND MSCCQID BETWEEN @MSCCQID_MIN AND @MSCCQID_MAX
ORDER BY MSCCQID

----------------

UPDATE DBServices.dbo.dbsMSSQLCentralCommandQueue 
SET MSCCQCommand = 'EXEC [MSSQLCentral].[dbo].[UpdtSAPWD] [Details Removed for security...]' 
WHERE MSCCQIsProccessed = 1 
	AND MSCCQID > @MSCCQID_MIN - 100
	AND MSCCQCommand LIKE '%UpdtSAPWD%@InstanceID%'

END

GO
/****** Object:  StoredProcedure [dbo].[msc_ProcessMSCCQ]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_ProcessMSCCQ]
AS
/****************************************************************************************
// @File: msc_ProcessMSCCQ.sql.SQL
// 
// Purpose:
//   Update MSSQLCentral with new data from dbsDatabase, abstract code used to 
//		identify if we have MSSQL integration turned on or off
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: 2.0.0 @Action: Created
//   @Date: 06/10/2006 @Author: Kevin Wagner @Version: 2.0.2 @Action: Updated for bug #4 submitted by Roger Edie
//   @Date: 06/10/2006 @Author: Kevin Wagner @Version: 2.0.7 @Action: Added code to purge the command queue with a default retention time of 10 days.
//   @Date: 18/12/2006 @Author: Kevin Wagner @Version: 2.5.1 @Action: Fixed issue with @MSSQLCentralCommandQueueRetainDays
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Final release to production
//   @Date: 25/09/2007 @Author: Charley Hanania @Version: 2.5.2 @Action: Update dbsMSSQLCentralCommandQueue to remove SA password Details
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//   @Date: 14/10/2008 @Author: Kevin Wagner @Version: 2.5.4.1 @Action: Updated for bug#57 Performance issues.
//   @Date: 25/11/2014 @Author: Chris Basson @Version: 6.0.0.13 @Action: TRRv3 Tidy
//   @Date: 10/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Bugfix - DisableMSSQLCentral
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int,
	@MSSQLCentralActiveServer nvarchar(128),
	@MSSQLCentralActiveDatabase	nvarchar(128),
	@MSSQLCentralActiveLoginMethod nvarchar(128),
	@MSSQLCentralActiveUser	nvarchar(128),
	@MSSQLCentralActiveUserPW nvarchar(128),
	@sql nvarchar(4000),
	@MSSQLCentralInstanceID char(36),
	@MSSQLCentralCommandQueueRetainDays varchar(3),
	@MSCCQProcessEnabled bit,
	@dbsInstanceFileLocation nvarchar(255),
	@MSSQLCentralSendFile nvarchar(255),
	@MSSQLCentralGetFile nvarchar(255),
	@MSSQLCentralProcessedGetFile nvarchar(255),
	@DisableMSSQLCentral bit

SET @RC = 0

--------------------------
-- Get config

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DisableMSSQLCentral', @DisableMSSQLCentral OUTPUT, @quiet=1

IF ISNULL(@DisableMSSQLCentral, 0) = 1
	OR NOT EXISTS(SELECT 1
		FROM [DBServices].[dbo].dbsMSSQLCentralCommandQueue
		WHERE MSCCQIsProccessed = 0)
	RETURN 0 -- Nothing to do

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSCCQProcessEnabled', @MSCCQProcessEnabled OUTPUT 
SET @MSCCQProcessEnabled = ISNULL(@MSCCQProcessEnabled, 0)

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralActiveLoginMethod', @MSSQLCentralActiveLoginMethod OUTPUT 

IF ISNULL(@MSSQLCentralActiveLoginMethod,'No Connection') = 'No Connection'
	OR @MSCCQProcessEnabled = 0

	RETURN 1
ELSE --------------
IF @MSSQLCentralActiveLoginMethod = 'SQL'
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralActiveUser', @MSSQLCentralActiveUser OUTPUT 
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralActiveUserPW', @MSSQLCentralActiveUserPW OUTPUT 
END

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralInstanceID', @MSSQLCentralInstanceID OUTPUT
EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralActiveServer', @MSSQLCentralActiveServer OUTPUT 
EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralActiveDatabase', @MSSQLCentralActiveDatabase OUTPUT 

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

SET @MSSQLCentralSendFile = @dbsInstanceFileLocation + '\MSSQLCentralSend.sql'
SET @MSSQLCentralGetFile = @dbsInstanceFileLocation + '\MSSQLCentralGet.sql'
SET @MSSQLCentralProcessedGetFile = @dbsInstanceFileLocation + '\MSSQLCentralProcessedGet.sql'

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralCommandQueueRetainDays', @MSSQLCentralCommandQueueRetainDays OUTPUT

IF @MSSQLCentralCommandQueueRetainDays IS NULL
BEGIN
	--If setting does not exist, default to 7 days

	EXEC [DBServices].[dbo].usp_ConfigureUBSMWE 'MSSQLCentralCommandQueueRetainDays', '7'
	SET @MSSQLCentralCommandQueueRetainDays = '7'
END

--------------------------
-- SendFile

SET @sql = 'sqlcmd -o ' + @MSSQLCentralSendFile 
	+ ' -w 4100 -t 60 -S ' + CONVERT(sysname, SERVERPROPERTY('ServerName')) 
	+ ' -E -d DBServices -Q "EXEC msc_MSCCQGetCommands"'  

EXEC @RC = master..xp_cmdshell @sql
IF @RC <> 0
BEGIN
	PRINT 'UBSMWE: msc_ProcessMSCCQ: Error creating SendFile.'
	RETURN 1
END

WAITFOR DELAY '00:00:02'

--------------------------
-- GetFile

IF @MSSQLCentralActiveLoginMethod = 'Trusted'
	SET @sql = 'sqlcmd -n -r -w 4100 -S ' + @MSSQLCentralActiveServer 
		+ ' -E -d ' + @MSSQLCentralActiveDatabase 
		+ ' -o ' + @MSSQLCentralGetFile 
		+ ' -i ' + @MSSQLCentralSendFile 
ELSE
IF @MSSQLCentralActiveLoginMethod = 'SQL'
	SET @sql = 'sqlcmd -n -r -w 4100 -S ' + @MSSQLCentralActiveServer
		+ ' -U ' + @MSSQLCentralActiveUser
		+ ' -P ' + @MSSQLCentralActiveUserPW
		+ ' -d ' + @MSSQLCentralActiveDatabase
		+ ' -o ' + @MSSQLCentralGetFile
		+ ' -i ' + @MSSQLCentralSendFile 

EXEC @RC = master..xp_cmdshell @sql

IF @RC <> 0
BEGIN
	PRINT 'UBSMWE: msc_ProcessMSCCQ: Error creating GetFile.'
	RETURN 1
END

WAITFOR DELAY '00:00:02'

--------------------------
-- Process GetFile

SET @sql = 'find /V  "New" ' + @MSSQLCentralGetFile
		+ ' > ' + @MSSQLCentralProcessedGetFile 

EXEC @RC = master..xp_cmdshell @sql
IF @RC <> 0
BEGIN
	PRINT 'UBSMWE: msc_ProcessMSCCQ: Unable to locate GetFile'
	RETURN 1
END

WAITFOR DELAY '00:00:02'

SELECT @sql = 'sqlcmd  -w 4100 -t 60 -S ' + CONVERT(sysname, SERVERPROPERTY('ServerName')) 
	+ ' -E -d DBServices -i ' + @MSSQLCentralProcessedGetFile

EXEC @RC = master..xp_cmdshell @sql
IF @RC <> 0
BEGIN
	PRINT 'UBSMWE: msc_ProcessMSCCQ: Unable to process GetFile'
	RETURN 1
END

-----------------------------------
ENDIT:

DELETE FROM DBServices.dbo.dbsMSSQLCentralCommandQueue
FROM DBServices.dbo.dbsMSSQLCentralCommandQueue msccq
LEFT OUTER JOIN DBServices.dbo.dbsMSSQLCentralCommandQueueExtendedError msccqee
	ON msccq.MSCCQID = msccqee.MSCCQID
WHERE (DATEDIFF(d, msccqee.DateProcessed, getdate()) >= @MSSQLCentralCommandQueueRetainDays)
	AND	MSCCQIsProccessed = 1

SET @RC = @@ERROR

RETURN @RC

END --main()

GO
/****** Object:  StoredProcedure [dbo].[msc_UpdatedbsDatabase]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_UpdatedbsDatabase] 
AS

/****************************************************************************************
// @File: msc_UpdatedbsDatabase.SQL
// 
// Purpose:
//   Update MSSQLCentral with new data from dbsDatabase
//
// Notes: This stored procedure is called from main UBSMWE. Can be run by hand if needed.
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production//
//   @Date: 02/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//   @Date: 24/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 Beta
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int,
		@Data nvarchar(255),
		@sql nvarchar(4000),
		@MSSQLCentralInstanceID char(36),
		@InstanceID char(36),
		@dbsDatabaseID  char(36),
		@dbsDatabaseName nvarchar(128),
		@dbsDatabaseIsSystemObjectFlag  bit,
		@dbsDatabaseEntryDate varchar(30),
		@dbsDatabaseInfoLoadedToMSSQLCentralDate varchar(30),
		@dbsDatabaseIsActive bit

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralInstanceID', @MSSQLCentralInstanceID OUTPUT

IF @RC = 0 
	AND NOT ISNULL(@MSSQLCentralInstanceID, '') = ''
BEGIN
	
	DECLARE cur_dbsDatabase CURSOR FAST_FORWARD FOR
	SELECT [dbsDatabaseUID]
		  ,[dbsDatabaseName]
		  ,[dbsDatabaseIsSystemObjectFlag]
		  ,[dbsDatabaseEntryDate]
		  ,[dbsDatabaseInfoLoadedToMSSQLCentralDate]
		  ,[dbsDatabaseIsActive]
	FROM [DBServices].[dbo].[dbsDatabase]
	WHERE dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1

	OPEN cur_dbsDatabase

	FETCH NEXT FROM cur_dbsDatabase
	INTO @dbsDatabaseID
		  ,@dbsDatabaseName
		  ,@dbsDatabaseIsSystemObjectFlag
		  ,@dbsDatabaseEntryDate
		  ,@dbsDatabaseInfoLoadedToMSSQLCentralDate
		  ,@dbsDatabaseIsActive

	WHILE (@@fetch_status <> -1)
	BEGIN --While
		IF (@@fetch_status <> -2)
		BEGIN
			-- Compile SQL Central @sql to be executed on the SQLCentral host
			SELECT @sql = 'EXECUTE [ubsmwe_InsUpdDatabase] ''' +  
				@MSSQLCentralInstanceID + ''', ''' + 
				@dbsDatabaseID + ''', ''' + 
				@dbsDatabaseName + ''', ''' +  
				CAST(@dbsDatabaseIsSystemObjectFlag as char(1)) + ''', ''' + 
				@dbsDatabaseEntryDate + ''', ''' +  
				CAST(getdate() as nvarchar(255)) + ''', ''' +  
				CAST(@dbsDatabaseIsActive as char(1)) + ''''

			EXEC @RC = [DBServices].[dbo].msc_InsertMSCCQ @sql 			
			
			IF @RC = 0
				UPDATE [DBServices].[dbo].dbsDatabase 
				SET dbsDatabaseMSSQLCentralNeedsUpdateFlag = 0 
					, dbsDatabaseInfoLoadedToMSSQLCentralDate = getdate() 
				FROM [DBServices].[dbo].dbsDatabase
				WHERE dbsDatabaseUID = @dbsDatabaseID
			-- ELSE continue on error
		END

		FETCH NEXT FROM cur_dbsDatabase
		INTO @dbsDatabaseID
			  ,@dbsDatabaseName
			  ,@dbsDatabaseIsSystemObjectFlag
			  ,@dbsDatabaseEntryDate
			  ,@dbsDatabaseInfoLoadedToMSSQLCentralDate
			  ,@dbsDatabaseIsActive
	END 
	CLOSE cur_dbsDatabase
	DEALLOCATE cur_dbsDatabase

	RETURN 0
END
ELSE 
BEGIN
	PRINT 'UBSMWE: msc_UpdatedbsDatabase: Unhanded exception; MSSQLCentralInstanceID is NULL' 

	RETURN 1
END

END --main()

GO
/****** Object:  StoredProcedure [dbo].[msc_UpdatedbsDatabaseBackupHistory]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_UpdatedbsDatabaseBackupHistory]
			@dbsDBHID varchar(27), -- source bigint
			@dbsDatabaseUID char(36), -- source GUID
			@dbsDBHIsLogFlag char(1) = NULL,	
			@dbsDBHStartDate varchar(30) = NULL,	
			@dbsDBHEndDate varchar(30) = NULL,	
			@dbsDBHFileName nvarchar(255) = NULL,	
			@dbsDBHIsOnDiskFlag char(1) = NULL,	
			@dbsDBackupProcessorID char(1) = NULL,	
			@dbsDBHParentID varchar(27) = NULL,	
			@dbsDBHActiveComputerName nvarchar(128) = NULL,	
			@dbsDBHSentToNBFlag char(1) = NULL
AS
/****************************************************************************************
// @File: msc_UpdatedbsDatabaseHistory.SQL
// 
// Purpose:
//   Update MSSQLCentral with new data from dbsDatabase
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 07/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 25/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 tidy up
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int,
		@MSSQLCentralPrimaryServer nvarchar(128),
		@MSSQLCentralPrimaryDatabase nvarchar(128),
		@sql nvarchar(4000),
		@MSSQLCentralInstanceID char(36),
		@CV_FSIncSysDB bit

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_FSIncSysDB', @CV_FSIncSysDB OUTPUT

------------------------------

-- TRRv3 @dbsDBHSentToNBFlag special case overrides
IF @dbsDBackupProcessorID = 5
BEGIN
	IF @CV_FSIncSysDB = 0
		SELECT @dbsDBHSentToNBFlag = '0' -- If system obj override @dbsDBHSentToNBFlag
		FROM DBServices.dbo.dbsDatabase db
		WHERE db.dbsDatabaseUID = @dbsDatabaseUID
			AND db.dbsDatabaseIsSystemObjectFlag = 1
END

SELECT @dbsDBHSentToNBFlag = '0' -- If filesystem exception
FROM DBServices.dbo.dbsDatabaseException dbe
WHERE dbe.dbsDatabaseUID = @dbsDatabaseUID
	AND dbe.dbsExceptionActive = 1
	AND dbe.dbsDatabaseExceptionType = 'filesystem'

------------------------------

SET @sql = 'EXEC [ubsmwe_InsUpd_ubsmweDatabaseBackupHistory] 
				@dbsDBHID = ''' + @dbsDBHID 
				+ ''', @dbsDatabaseUID = ''' + @dbsDatabaseUID   

IF @dbsDBHIsLogFlag IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHIsLogFlag = ''' + @dbsDBHIsLogFlag 

IF @dbsDBHStartDate IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHStartDate = ''' + @dbsDBHStartDate 

IF @dbsDBHEndDate IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHEndDate = ''' + @dbsDBHEndDate 

IF @dbsDBHFileName IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHFileName = ''' + @dbsDBHFileName 

IF @dbsDBHIsOnDiskFlag IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHIsOnDiskFlag = ''' + @dbsDBHIsOnDiskFlag 

IF @dbsDBackupProcessorID IS NOT NULL
	SET @sql= @sql + ''', @dbsDBackupProcessorID = ''' + @dbsDBackupProcessorID 

IF @dbsDBHParentID IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHParentID = ''' + @dbsDBHParentID

IF @dbsDBHActiveComputerName IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHActiveComputerName = ''' + @dbsDBHActiveComputerName 

IF @dbsDBHSentToNBFlag IS NOT NULL
	SET @sql= @sql + ''', @dbsDBHSentToNBFlag = ''' + @dbsDBHSentToNBFlag + ''''
ELSE
	SET @sql= @sql + ''''

EXEC @RC = DBServices.dbo.msc_InsertMSCCQ @sql

RETURN @RC

END --main()

GO
/****** Object:  StoredProcedure [dbo].[msc_UpdatedbsDatabaseBackupHistoryINIT]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[msc_UpdatedbsDatabaseBackupHistoryINIT] 
AS

/****************************************************************************************
// @File: msc_UpdatedbsDatabaseBackupHistoryINIT.SQL
// 
// Purpose:
//   Update MSSQLCentral with new data from dbsDatabase
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 07/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 25/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 tidy up
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int,
		@dbsDBHID varchar(27), -- source bigint
		@dbsDatabaseUID char(36) ,	
		@dbsDBHIsLogFlag char(1),	
		@dbsDBHStartDate varchar(30),	
		@dbsDBHEndDate varchar(30),	
		@dbsDBHFileName nvarchar(255),	
		@dbsDBHIsOnDiskFlag char(1),	
		@dbsDBackupProcessorID char(1),	
		@dbsDBHParentID varchar(27),	
		@dbsDBHActiveComputerName nvarchar(128),	
		@dbsDBHSentToNBFlag char(1)

DECLARE cur_dbsDatabaseBackup CURSOR FAST_FORWARD FOR
SELECT [dbsDBHID]
	,[dbsDatabaseUID]
	,[dbsDBHIsLogFlag]
	,[dbsDBHStartDate]
	,[dbsDBHEndDate]
	,[dbsDBHFileName]
	,[dbsDBHIsOnDiskFlag]
	,[dbsDBackupProcessorID]
	,[dbsDBHParentID]
	,[dbsDBHActiveComputerName]
	,[dbsDBHSentToNBFlag]
FROM [DBServices].[dbo].[dbsDatabaseBackupHistory]
WHERE [dbsDBHParentID] IS NULL	
UNION ALL
SELECT [dbsDBHID]
	,[dbsDatabaseUID]
	,[dbsDBHIsLogFlag]
	,[dbsDBHStartDate]
	,[dbsDBHEndDate]
	,[dbsDBHFileName]
	,[dbsDBHIsOnDiskFlag]
	,[dbsDBackupProcessorID]
	,[dbsDBHParentID]
	,[dbsDBHActiveComputerName]
	,[dbsDBHSentToNBFlag]

FROM [DBServices].[dbo].[dbsDatabaseBackupHistory]
WHERE [dbsDBHParentID] IN (SELECT [dbsDBHID] 
							FROM [DBServices].[dbo].[dbsDatabaseBackupHistory]
							WHERE [dbsDBHParentID] IS NULL)
ORDER BY dbsDBHParentID, dbsDBHID

OPEN cur_dbsDatabaseBackup

FETCH NEXT FROM cur_dbsDatabaseBackup 
INTO @dbsDBHID
	  ,@dbsDatabaseUID
	  ,@dbsDBHIsLogFlag
	  ,@dbsDBHStartDate
	  ,@dbsDBHEndDate
	  ,@dbsDBHFileName
	  ,@dbsDBHIsOnDiskFlag
	  ,@dbsDBackupProcessorID
	  ,@dbsDBHParentID
	  ,@dbsDBHActiveComputerName
	  ,@dbsDBHSentToNBFlag

WHILE (@@fetch_status <> -1)
BEGIN --While

	IF (@@fetch_status <> -2)
	BEGIN
		EXEC @RC = [DBServices].[dbo].[msc_UpdatedbsDatabaseBackupHistory] 
					@dbsDBHID
					,@dbsDatabaseUID
					,@dbsDBHIsLogFlag
					,@dbsDBHStartDate
					,@dbsDBHEndDate
					,@dbsDBHFileName
					,@dbsDBHIsOnDiskFlag
					,@dbsDBackupProcessorID
					,@dbsDBHParentID
					,@dbsDBHActiveComputerName
					,@dbsDBHSentToNBFlag
	END

	FETCH NEXT FROM cur_dbsDatabaseBackup 
	INTO @dbsDBHID
		  ,@dbsDatabaseUID
		  ,@dbsDBHIsLogFlag
		  ,@dbsDBHStartDate
		  ,@dbsDBHEndDate
		  ,@dbsDBHFileName
		  ,@dbsDBHIsOnDiskFlag
		  ,@dbsDBackupProcessorID
		  ,@dbsDBHParentID
		  ,@dbsDBHActiveComputerName
		  ,@dbsDBHSentToNBFlag
END --While

CLOSE cur_dbsDatabaseBackup
DEALLOCATE cur_dbsDatabaseBackup

END --main()

GO
/****** Object:  StoredProcedure [dbo].[msc_updateSAPassword]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[msc_updateSAPassword] 	@VVCNewSAPassword  varchar(50)

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: msc_updateSAPassword.SQL
// 
// Purpose:
//   Perform Full Backup of all databases
//
// Notes: This stored procedure is called from main UBSMWE. Can be run by hand if needed.
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 25/09/2007 @Author: Charley Hanania @Version: UBSMWE 2.5.2 @Action: Update dbsMSSQLCentralCommandQueue to remove SA password Details
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/







DECLARE
	 @VinReturnCode int
	,@VuiInstanceID varchar(50)
	,@VvcInstanceID varchar(50)
	,@VvcSQLString varchar(1024)

BEGIN

	--Update MSSQLCentral

	EXEC @VinReturnCode = [dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralInstanceID' ,@VuiInstanceID OUTPUT

	SET 	 @VvcInstanceID=CAST(@VuiInstanceID as varchar(50))

	SELECT 	 @VvcSQLString = 'EXEC [MSSQLCentral].[dbo].[UpdtSAPWD] @InstanceID='''+@VvcInstanceID+''', @PWD='''+@VVCNewSAPassword+''''

	EXEC 	@VinReturnCode = dbo.msc_InsertMSCCQ @VvcSQLString



END


GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupDatabase]  
AS

/****************************************************************************************
// @File: usp_BackupDatabase.SQL
// 
// Purpose:
//   Badly named sp - collates msdb data for externally initated file backups in certain scenarios
//
// Notes: This stored procedure is called from main UBSMWE.
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 24/05/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Fixed bug in file naming pattern...
//   @Date: 25/08/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Added functionality for LiteSpeed syntax...
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 23/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Fixed bug where if db was set to external backup the Netbackup call would be set to fire every time the UBSMWE job ran.
//   @Date: 29/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Added code to allow for use in Log Shipped operations
//   @Date: 16/10/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0.5 @Action: Updated for Logshipping Secondary database issue.
//   @Date: 18/12/2006 @Author: Kevin Wagner @Version: UBSMWE 2.5 @Action: Rebranded for UBSMWE, changed job names.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 10/06/2014 @Author: Chris Basson @Version: UBSMWE 5.0.11 @Action: Tidyup
//   @Date: 14/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//   @Date: 21/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 10/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.15 @Action: TRRv3 Beta
//   @Date: 24/09/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.38 @Action: Minor tidyup for clarity
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int,
	@dbsDatabaseUID uniqueidentifier,
	@dbsDBFileLocation nvarchar(255),
	@dbsDatabaseName nvarchar(128),
	--@debug nvarchar(2),
	@dbsDBExternalBackupFlag bit,
	@dbsDBDoFullBackupNow bit,
	@dbsDBDoLogBackupNow bit,
	@dbsDBIsInLogBackupProcess bit,
	@dbsDBIsInFullBackupProcess bit,
	@dbsDBBackupType nvarchar(128)
	
--EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT 

-------------------------------------------------
--Database Backups

DECLARE dbsDatabase_cur CURSOR FOR
SELECT 	dbsD.[dbsDatabaseUID], 
	dbsD.[dbsDatabaseName] , 
	dbsDB.[dbsDBFileLocation],
	dbsDB.[dbsDBExternalBackupFlag],
	dbsDB.[dbsDBDoFullBackupNow], -- = 1 
	dbsDB.[dbsDBDoLogBackupNow],
	dbsDB.[dbsDBIsInLogBackupProcess],
	dbsDB.[dbsDBIsInFullBackupProcess],
	dbsDB.[dbsDBBackupType]
FROM [DBServices].[dbo].[dbsDatabase] dbsD
INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB
	ON	dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID] 
WHERE dbsD.dbsDatabaseIsActive = 1
	AND dbsDB.dbsDBIsInRestoreProcess = 0

OPEN dbsDatabase_cur

FETCH NEXT FROM dbsDatabase_cur 
	INTO @dbsDatabaseUID, @dbsDatabaseName, @dbsDBFileLocation
		, @dbsDBExternalBackupFlag, @dbsDBDoFullBackupNow, @dbsDBDoLogBackupNow
		, @dbsDBIsInLogBackupProcess, @dbsDBIsInFullBackupProcess, @dbsDBBackupType
WHILE (@@FETCH_STATUS = 0)
BEGIN 

	IF  @dbsDBExternalBackupFlag = 1 
		OR @dbsDBBackupType IN ('LS_Primary')
	BEGIN

		-- Case: DB fulls backed up externally and not LS primary
		IF @dbsDBExternalBackupFlag = 1 
			AND @dbsDBBackupType NOT IN ('LS_Primary') 
		BEGIN
			-- Get full DB backup info from msdb
			
			EXEC @RC = [DBServices].[dbo].usp_GetSystemBackupInformation @dbsDatabaseName, 'D' --D = Full

			-- Reset dbsDBDoFullBackupNow flag for DB				
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBDoFullBackupNow = 0
			WHERE dbsDatabaseUID = @dbsDatabaseUID
		END ------------------

		-- Case DB tlogs backed up externally OR a LS primary
		IF ( @dbsDBBackupType IN ('FULL', 'BULK_LOGGED') AND @dbsDBExternalBackupFlag = 1 ) 
			OR @dbsDBBackupType IN ('LS_Primary')
		BEGIN 
			-- Get Tlog DB backup info from msdb

			EXEC @RC = [DBServices].[dbo].usp_GetSystemBackupInformation @dbsDatabaseName, 'L' --L = Log

			-- Reset dbsDBDoLogBackupNow flag for DB	
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBDoLogBackupNow = 0
			WHERE dbsDatabaseUID = @dbsDatabaseUID
		END ------------------
		ELSE
		BEGIN --Just clear the entry
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBDoLogBackupNow = 0
			WHERE dbsDatabaseUID = @dbsDatabaseUID
		END 
	END --Get information from the system tables for excluded backups

	FETCH NEXT FROM dbsDatabase_cur
	INTO @dbsDatabaseUID, @dbsDatabaseName, @dbsDBFileLocation
		, @dbsDBExternalBackupFlag, @dbsDBDoFullBackupNow, @dbsDBDoLogBackupNow
		, @dbsDBIsInLogBackupProcess, @dbsDBIsInFullBackupProcess, @dbsDBBackupType

END

CLOSE dbsDatabase_cur
DEALLOCATE dbsDatabase_cur

-------------------------------------------------

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase_FULL_Base]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupDatabase_FULL_Base] 
					@dbsDatabaseName nvarchar(128), 
					@DatabaseBackupFullPath nvarchar(255),
					@CopyOnly bit = 0 
AS
/****************************************************************************************
// @File: usp_BackupDatabase_FULL_Base.SQL
//
// Purpose:
//   Perform Full Backup of named database using SQL Server native syntax
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase.
//
// History:
//
//   @Version: 6.0.0.15
//   @Author: Kevin Wagner
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 04/05/2010 @Author: Steve Trogub @Version: UBSMWE 2.5.4.3 @Action: Added differential backup option
//   @Date: 12/28/2010 @Author: Steve Trogub @Version: UBSMWE 2.5.4.3 @Action: Added backup tunning options maxtransize and buffercount
//   @Date: 18/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 11/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.15 @Action: TRRv3 TRR-95 @CopyOnly
//   @Date: 11/11/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.40 @Action: Refinement
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE
	@RC int,
    @sql1 nvarchar(1000),
    @sql2 nvarchar(4000),
 	@sql3 nvarchar(320),
 	@sql4 nvarchar(255),
 	@sql5 nvarchar(20),
 	@MAXTRANSFERSIZE nvarchar(10),
 	@BUFFERCOUNT nvarchar(10),
	@debug tinyint,
	@dbsStripe tinyint,
	@i smallint

--exclude system and maintanance databases from stripes if enabled
SELECT @dbsStripe = 1
	,@BUFFERCOUNT = 20
	,@MAXTRANSFERSIZE = 4194304

--------------------------------
-- Get config
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT

 IF NOT EXISTS (SELECT 1 FROM [DBServices].[dbo].[dbsDatabase] 
	WHERE [dbsDatabaseName] = @dbsDatabaseName AND [dbsDatabaseIsSystemObjectFlag] = 1)
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsStripeSet', @dbsStripe OUTPUT

--BUFFERCOUNT Native Backup Config variable
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBUFFERCOUNT', @BUFFERCOUNT OUTPUT

--MAXTRANSFERSIZE Native Backup Config variable
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsMAXTRANSFERSIZE', @MAXTRANSFERSIZE OUTPUT

--------------------------------
-- Compile backup cmd
    
SET @sql1 = 'BACKUP DATABASE ['
            + @dbsDatabaseName
            +'] ' 

IF CHARINDEX('_Part_',@DatabaseBackupFullPath) > 0
BEGIN
	SET @sql2 = ''
	EXEC [DBServices].[dbo].[usp_PartialDatabaseBackup_fglist]
			 @dbsDatabaseName = @dbsDatabaseName
			, @PartialBackupStringOut = @sql2  OUTPUT

	SET @sql1 = @sql1 + @sql2  
END

--------------------------------
--Add striping loop to create multiple files here

SET @sql2 = ' TO '
SET @i = 1

WHILE @i <= @dbsStripe
BEGIN
	IF @dbsStripe > 1    
		SET @sql2 = @sql2 + 'DISK = N''' + LTRIM(RTRIM(REPLACE(@DatabaseBackupFullPath, '.bak', '_'
			 + CAST(@i as nvarchar(2)) + 'of' + CAST(@dbsStripe as nvarchar(2)) + '.bak'))) + '''' 
	ELSE 
		SET @sql2 = @sql2 + 'DISK = N''' + LTRIM(RTRIM(@DatabaseBackupFullPath))+ '''' 

	IF @i <> @dbsStripe
		SET @sql2 = @sql2 + ','
	
	SET @i = @i + 1
END
--------------------------------
 
SET @sql3 = ' WITH ' + CASE @CopyOnly
						WHEN 1 THEN 'COPY_ONLY, '
						ELSE ''
						END
			+ 'NOINIT, NOUNLOAD, NAME = N''' 
			+ @dbsDatabaseName
            + ' backup'',  SKIP ,  STATS = 10,  DESCRIPTION = N'''
            + 'UBSMWE'''
            + ', NOFORMAT'

IF ISNUMERIC(@MAXTRANSFERSIZE) = 1
	AND ISNUMERIC(@BUFFERCOUNT) = 1
	SET @sql4 = ', MAXTRANSFERSIZE=' + @MAXTRANSFERSIZE 
			+ ', BUFFERCOUNT=' + @BUFFERCOUNT
ELSE
	SET @sql4 =	''
				
IF CHARINDEX('_Diff_', @DatabaseBackupFullPath) > 0
	SET @sql5 = ', Differential'
ELSE
	SET @sql5 = ''

--------------------------------
-- *** Run backup cmd ***

IF @debug >= 2  
	PRINT (@sql1 + @sql2 + @sql3 + @sql4 + @sql5)                                   

EXEC (@sql1 + @sql2 + @sql3 + @sql4 + @sql5)
SET @RC = @@ERROR

IF @RC <> 0
	RETURN 1
ELSE 
	RETURN 0
	

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase_Full_LiteSpeed]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupDatabase_Full_LiteSpeed] 
	@dbsDatabaseName nvarchar(128), 
	@DatabaseBackupFullPath nvarchar(255)
AS

/****************************************************************************************
// @File: usp_BackupDatabase_FULL_Base.SQL
//
// Purpose:
//   Perform Full Backup of named database using LiteSpeed syntax
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase.
//
// History:
//
//   @Version: Beta General
//   @Author: Kevin Wagner
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 04/05/2010 @Author: Steve Trogub @Version: UBSMWE 2.5.4 @Action: Added differential backup option
//   @Date: 18/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE        
	@LiteSpeedThreads char(5)
	,@RC int
	,@diff char(40)
	,@sql1 nvarchar(4000)
	,@sql2 nvarchar(4000)
	,@sql3 nvarchar(4000)
	,@dbsStripe INT
	,@debug_level INT
	,@i int
                     
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug_level OUTPUT

--exclude system and maintanance databases from stripes if striped are enabled
SET @dbsStripe = 1
SET @diff = ''

 IF NOT EXISTS (SELECT 1
			FROM [DBServices].[dbo].[dbsDatabase] 
			WHERE [dbsDatabaseName] = @dbsDatabaseName AND [dbsDatabaseIsSystemObjectFlag] = 1)
	 EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsStripeSet', @dbsStripe OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'LiteSpeedThreads', @LiteSpeedThreads OUTPUT
IF @RC <> 0
BEGIN
    PRINT 'The setting for LiteSpeedTreads was not found, defaulting to 3 threads for this run of backup'
    SET @LiteSpeedThreads = 3
END

-- Determine if differential
IF CHARINDEX('_Diff_',@DatabaseBackupFullPath) > 0
	SET @diff = ',@with = N' + '''DIFFERENTIAL'''

-- =============================================
-- Execute SQL LiteSpeed Full Database Backup
-- ============================================

WAITFOR DELAY '00:00:10'

SET @sql1 = 'master.dbo.xp_backup_database @database = [' + @dbsDatabaseName + ']' 
                            
--Add striping loop to create multiple files here              
SET @i = 1
SET @sql2 = ''

WHILE @i <= @dbsStripe
BEGIN
	IF @dbsStripe > 1    --@DatabaseBackupFullPath = REPLACE(@DatabaseBackupFullPath, '_Full_', '_Part_')
		SET @sql2 =@sql2 + ', @FileName = N''' + LTRIM(RTRIM(REPLACE(@DatabaseBackupFullPath, '.bak', '_' 
			+ CAST(@i as nvarchar(2)) + 'of' + CAST(@dbsStripe as nvarchar(2)) + '.bak'))) + ''''
	ELSE 
		SET @sql2 = ', @FileName = N''' + LTRIM(RTRIM(@DatabaseBackupFullPath))+ ''''

    SELECT @i = @i + 1
END
                          
SET @sql3 = ' , @desc =' + '''UBSMWE'''
	+ ', @threads = ' + @LiteSpeedThreads
	+ ', @init = 0'
	+ ', @OLRMAP = 1'
	+ @diff

----------------------------
-- DO

IF @debug_level = 2
	PRINT @sql1 + @sql2 + @sql3

EXEC  (@sql1 + @sql2 + @sql3 )

SET @RC = @@ERROR
RETURN (@RC)

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase_JobRun]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupDatabase_JobRun] 
	@DatabaseName nvarchar(255) 
	,@BackupType tinyint  --1 = Database, 2 = Log
	,@ForceFull bit = 0

AS

/****************************************************************************************
// @File: usp_BackupDatabase_JobRun.SQL
//
// @Version 6.0.0.29
//
// Purpose:
//   Perform Backup of databases
//
// Notes: This stored procedure is called from specific db backup job.
//		TRRV3: user DBs which are explicitly excluded from CV (External) will NOT use the WITH COPY_ONLY backup parameter
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 02/11/2004 @Author: Kevin Wagner @Version: 1.5.1 HF1 @Action: Inception...
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//   @Date: 30/09/2010 @Author: Steve Trogub @Version: 2.5.4.3 @Action: add differential backup functionality
//   @Date: 10/02/2011 @Author: Steve Trogub @Version: 4.0 @Action: Add partial backup feature
//   @Date: 01/04/2011 @Author: Steve Trogub @Version: 4.0 @Action: Add striped backup support
//   @Date: 29/05/2011 @Author: Steve Trogub @Version: 4.0 @Action: Add backup alighnment support
//   @Date: 02/06/2011 @Author: Steve Trogub @Version: 4.0 @Action: Add exclusion of system databases from non-full backups
//   @Date: 02/06/2011 @Author: Steve Trogub @Version: 5.0.2 @Action: Add parallel operation for FS and iData backups to CommVault
//   @Date: 07/06/2013 @Author: Steve Trogub @Version: 5.0.5 @Action: BRAT Tool support and Mullti-Database Subclient support
//   @Date: 08/23/2013 @Author: Steve Trogub @Version: 5.0.5 @Action: added automated CommVault Daily jobs configuration fix
//   @Date: 10/05/2014 @Author: Chris Basson @Version: 5.0.11 @Action: Tidyup, Bugfix: Log backup job script; backup processor order (Andrew Calvett)
//   @Date: 30/07/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 BETA
//   @Date: 12/08/2014 @Author: Chris Basson @Version: 6.0.0.1 @Action: TRRv3 BETA
//   @Date: 30/09/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 BETA
//   @Date: 21/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 BETA
//   @Date: 10/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 BETA
//   @Date: 12/11/2014 @Author: Chris Basson @Version: 6.0.0.11 @Action: TRRv3 BETA
//   @Date: 11/12/2014 @Author: Chris Basson @Version: 6.0.0.15 @Action: TRRv3 TRR-95; use WITH COPY_ONLY for local dumps
//   @Date: 20/01/2015 @Author: Chris Basson @Version: 6.0.0.21 @Action: Minor err code bug fix
//   @Date: 04/04/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Support for non-alpha numerics in DB names, TRR-133 - TRRv2 CV exclusion
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Set Sunday = 1st day of week

DECLARE @RC int,
        @dbsDatabaseUID uniqueidentifier,
        @dbsDBHIsLogFlag bit,
        @dbsDBHStartDate datetime,
        @dbsDBHEndDate datetime,
        @dbsDBFileLocation nvarchar(255),
        @dbsDBHID bigint,
		@dbsDBHID_unused bigint,
        @DatabaseDumpPath nvarchar(512),
        @StartDateTemp datetime,
        @EndDateTemp datetime,
        @dbsLastFullBackupRun datetime,
        @RunFullBackup bit,
        @dbsDatabaseFullBackupStartTime nvarchar(50),
        @dbsDatabaseLogBackupStartTime nvarchar(50),
        @dbsDatabaseLogBackupIntervalMinute nvarchar(4),
        @dbsDatabaseLogBackupEndTime nvarchar(50),
        @year varchar(4),
        @month varchar(2),
        @day varchar(2),
        @hour varchar(2),
        @minute varchar(2),
        @second varchar(2),
        @dbsBackupProcessor tinyint,
        @dbsDBHIsInRestoreProcess int,
        @debug nvarchar(2),
        @dbsDBHActiveComputerName nvarchar(255),
        @dbsDBHParentID bigint,
        @exceptionNum int,
		@dbsAlign tinyint,
		@dbsFullBackupDay int,
		@dbsFullPartialBackupDay int,
        @fileID int,
        @fileSizePages int,
        @extentID int,
        @pageID int,
        @DIFFTotal int,
        @sizeTotal int,
        @total int,
        @DIFFpercent float,
        @dbccPageString varchar (200),
        @dbExcludedFromDiffnPart int,
		@dbExcludedFromFullBackup int, 
		@dbsSubclientName nvarchar(255), 
		@dbsDatabaseIsOndemandFlag bit,
        @dbsStripe tinyint,
        @i int,
        @tempSql varchar(8000),
		@fglist varchar(8000),
		@ReturnValue varchar(8000),
		@dbsInstanceMajorVersion tinyint,
		@dbsCVParallelOps bit,
		@dbsFGRPBackup bit,
		@ErrorMsg varchar(255),
		@permdef nvarchar(255),
		@isSysDB bit,
		@dt_LastFullBakJobFailure datetime,
		@hours_since_install int,
		@dt_LastFullBak datetime,
		@LastFullBakage int,
		@bType char(7),
		@diffthreshold int,
		@dbsDiffBackup bit,
		@dbsDiffnPartFullBackupAlignDay tinyint,
		@DBExternalException bit,
		@DIFFpercentThreshold tinyint,
		@FinalRC int

------------------
-- Get config

SET @dbsInstanceMajorVersion = [DBServices].[dbo].[ufn_InstanceMajorVersion] ()   
--SET @DatabaseName = LTRIM(RTRIM(@DatabaseName)) -- Bugfix - do not trim DB Name

SET @DIFFpercentThreshold = 50

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT, @quiet = 1

------------------
--DP0 - Begin
IF @debug >= 2
BEGIN
    PRINT 'In usp_BackupDatabase_JobRun AT DP0 - Begin'
    PRINT '----------------------------------------------------------------------------------------------------'
    PRINT 'Post initialization of variables using usp_GetdbsInstanceConfig;'
END

-- Init Vars
SET @dbsAlign = DATEPART(dw, getdate()) --  1 = Sunday, 7 = Sat

-- Init output vars
SELECT 
	@dbsDBHActiveComputerName=NULL
	,@dbsStripe = 1
	,@dbsDBHID=0
	,@dbsDatabaseFullBackupStartTime = NULL
	,@dbsDatabaseLogBackupStartTime = NULL
	,@dbsDatabaseLogBackupIntervalMinute = 15
	,@dbsDatabaseLogBackupEndTime=NULL
	,@dbsCVParallelOps=0
	,@dbsFGRPBackup=0
	,@diffthreshold=23
	,@dbExcludedFromFullBackup = 0
	,@dbExcludedFromDiffnPart = 0
	,@dbsFullPartialBackupDay = 0
	,@dbsFullBackupDay = 0
	,@ReturnValue = ''
	,@fglist=''
	,@dbsSubclientName=NULL
	,@dbsDatabaseIsOndemandFlag = 0
	,@DBExternalException=0
	,@dbsDiffBackup=0
	,@dbsDiffnPartFullBackupAlignDay=1
	,@FinalRC=0
	
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @dbsDBHActiveComputerName OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupStartTime', @dbsDatabaseLogBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupIntervalMinute', @dbsDatabaseLogBackupIntervalMinute OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupEndTime', @dbsDatabaseLogBackupEndTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Parallel_Ops', @dbsCVParallelOps OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsFGRPBackup', @dbsFGRPBackup OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDiffBackup', @dbsDiffBackup OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDiffBackupThreshold', @diffthreshold OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDiffnPartFullBackupAlignDay', @dbsDiffnPartFullBackupAlignDay OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsStripeSet', @dbsStripe OUTPUT

SELECT  @year = CONVERT(varchar(4), DATEPART(year, getdate())),
		@month = CONVERT(varchar(2), DATEPART(month, getdate())),
		@day = CONVERT(varchar(2), DATEPART(day, getdate())),
		@hour = CONVERT(varchar(2), DATEPART(hour, getdate())),
		@minute = CONVERT(varchar(2), DATEPART(minute, getdate())),
		@second = CONVERT(varchar(2), DATEPART(second, getdate()))

IF NOT (ISDATE (@dbsDatabaseFullBackupStartTime)=1
	AND ISDATE (@dbsDatabaseLogBackupStartTime)=1
	AND ISDATE (@dbsDatabaseLogBackupEndTime)=1)
BEGIN
	SET @ErrorMsg = 'UBSMWE Error: usp_BackupDatabase_JobRun: Invalid time specified within table dbo.dbsInstanceConfig - unable to configure backup schedule!'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

	GOTO END_IT	
END

-----------

SELECT @dbsDatabaseUID = db.[dbsDatabaseUID]
		,@dbsDBFileLocation = dbb.[dbsDBFileLocation]
		,@isSysDB = db.dbsDatabaseIsSystemObjectFlag
FROM [DBServices].[dbo].[dbsDatabase] db
INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbb
	ON dbb.[dbsDatabaseUID] = db.[dbsDatabaseUID]
WHERE db.dbsDatabaseName = @DatabaseName
	AND db.dbsDatabaseIsActive = 1

IF @dbsDatabaseUID IS NULL
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, 'NULL') 
		 + ': not found or deemed inactive; backup is not possible - further investigation required' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

	GOTO END_IT
END
ELSE 
IF @isSysDB = 1
	SET @dbsStripe = 1 --exclude system and maintanance databases from stripes if striped are enabled

----------------------------------------------------
-- TRR Determine if external exception

IF @dbsBackupProcessor IN (4,5)
BEGIN
	SELECT @DBExternalException = 1 
	FROM [DBServices].[dbo].dbsDatabase db
	INNER JOIN  [DBServices].[dbo].dbsDatabaseException dbe
		ON db.dbsDatabaseUID = dbe.dbsDatabaseUID
	WHERE
		db.dbsDatabaseName = @DatabaseName 
		AND db.dbsDatabaseIsActive = 1
		AND ((dbe.dbsExceptionActive = 1
				AND dbe.dbsDatabaseExceptionType = 'backup'
				AND dbe.dbsDatabaseExceptionSubType = 'external')
			OR (db.dbsDatabaseIsSystemObjectFlag = 1))

	SET @DBExternalException = ISNULL(@DBExternalException, 0)

	IF @dbsBackupProcessor = 5
		AND @DBExternalException = 0 
		AND @isSysDB = 0
	BEGIN 
		-- CV Scheduling configured; a user DB passed without exception - handled directly by CV - just exit

		PRINT 'Configured for CV Scheduled backups (@dbsBackupProcessor = 5), consequently only able to backup system DBs locally - exiting'
		GOTO END_IT 
	END
END
----------------------------------------------------

--DP0 - END
IF  @debug >= 2
BEGIN
	PRINT '@dbsDatabaseFullBackupStartTime = ' + ISNULL(CAST(@dbsDatabaseFullBackupStartTime as varchar(255)), 'NULL')
	PRINT '@dbsDatabaseLogBackupStartTime = ' + ISNULL(CAST(@dbsDatabaseLogBackupStartTime as varchar(255)), 'NULL')
	PRINT '@dbsDatabaseLogBackupIntervalMinute = ' + ISNULL(CAST(@dbsDatabaseLogBackupIntervalMinute as varchar(255)), 'NULL')
	PRINT '@dbsDatabaseLogBackupEndTime = ' + ISNULL(CAST(@dbsDatabaseLogBackupEndTime as varchar(255)), 'NULL')
	PRINT '@dbsBackupProcessor = ' + ISNULL(CAST(@dbsBackupProcessor as varchar(255)), 'NULL')
	PRINT '@dbsDBHActiveComputerName = ' + ISNULL(CAST(@dbsDBHActiveComputerName as varchar(255)), 'NULL')
	PRINT '----------------------------------------------------------------------------------------------------'
	PRINT 'In usp_BackupDatabase_JobRun AT DP0 - END;'
	PRINT ''
END

----------------------------------------	
--DP1 - Begin
IF  @debug >= 2
BEGIN
    PRINT 'In usp_BackupDatabase_JobRun AT DP1 - Begin'
    PRINT '----------------------------------------------------------------------------------------------------'
    PRINT 'Seeding the values for the following;'
END

--identify if the database is excluded from MWE full backups

SET @exceptionNum = NULL
SET @dbExcludedFromFullBackup = 0

SELECT  @exceptionNum = MAX(dbsDatabaseExceptionID)
FROM [DBServices].[dbo].[dbsDatabaseException]
WHERE dbsDatabaseUID = @dbsDatabaseUID
	AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'backup'
	AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionSubType))) = 'full'

IF @exceptionNum IS NOT NULL
BEGIN
	IF (SELECT dbsExceptionActive
		FROM [DBServices].[dbo].[dbsDatabaseException]
		WHERE dbsDatabaseExceptionID = @exceptionNum) = 1
	BEGIN
		PRINT 'Info: ' + @DatabaseName + ' - exception identified for FULL DB Backups: '
			+ CAST(@exceptionNum as nvarchar(5)) + ' - skipping'

		SET @dbExcludedFromFullBackup = 1
	END 
	ELSE 
		SET @dbExcludedFromFullBackup = 0
END

--FULL Backups start ------------------------------------------------------------------------------------------------------------------------------------

IF @BackupType = 1 -- 1=Database, 2=Log
	 AND @dbExcludedFromFullBackup <> 1 
BEGIN --Full Database Backup

	SET @dbsDBHIsLogFlag  = 0  

	--DP1 - END
	IF  @debug >= 2
	BEGIN
		PRINT '@dbsDatabaseUID = ' + ISNULL(CAST(@dbsDatabaseUID as varchar(255)), 'NULL')
		PRINT '@dbsDatabaseName = ' + @DatabaseName
		PRINT '@dbsDBFileLocation = ' + ISNULL(@dbsDBFileLocation, 'NULL')
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'In usp_BackupDatabase_JobRun AT DP1 - END;'
		PRINT ''
	END
		
	--AND (dbsDBHIsInLogBackupProcess = 0 OR dbsDBHIsInLogBackupProcess IS NULL)

	--Still may need this but will try without for now...
	-- AND dbsDBH.dbsDBHIsInRestoreProcess = 0

	BEGIN  --begin DatabaseBackup

		IF @dbsBackupProcessor IN (1,2,3,5)
			OR (@DBExternalException = 1)
		BEGIN

			IF  @debug >= 2
			BEGIN
				PRINT 'In usp_BackupDatabase_JobRun AT DP3 - Begin'
				PRINT '----------------------------------------------------------------------------------------------------'
				PRINT 'Setting @DatabaseDumpPath'
			END

			SET @DatabaseDumpPath = @dbsDBFileLocation
				+ '\'
				+ REPLACE(LEFT(@DatabaseName, 64), '\', '#') + '_Full_'
				+ @year --+ '_'
				+ CASE WHEN LEN (@month) = 2 THEN @month ELSE '0' +  LTRIM(@month) END 
				+ CASE WHEN LEN (@day) = 2 THEN @day ELSE '0' +  LTRIM(@day) END
				+ CASE WHEN LEN (@hour) = 2 THEN @hour ELSE '0' +  LTRIM(@hour) END 
				+ CASE WHEN LEN (@minute) = 2 THEN @minute ELSE '0' +  LTRIM(@minute) END 
				+ CASE WHEN LEN (@second) = 2 THEN @second ELSE '0' +  LTRIM(@second) END
				+'.bak'
			
			IF ISNULL(@DatabaseDumpPath, '') = ''
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: Unhandled exception ' + @DatabaseName 
					+ ': @DatabaseDumpPath = NULL' 
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

				GOTO END_IT
			END 
			ELSE
			IF LEN(@DatabaseDumpPath) > 255
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: Backup file path for DB ' + @DatabaseName 
					+ ' exceeds OS limitation of 255 chars: ' + @DatabaseDumpPath + ' unable to proceed!'
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 

				GOTO END_IT
			END	
			ELSE -- Ensure valid filename
				SET @DatabaseDumpPath = [DBServices].[dbo].[ufn_SafeFileName](@DatabaseDumpPath)
			
			--DP3 - END
			IF  @debug >= 2
			BEGIN
				PRINT '@dbsDBFileLocation = ' + @dbsDBFileLocation
				PRINT '@dbsDatabaseName = ' + @DatabaseName
				PRINT '@year = ' + @year
				PRINT '@DatabaseDumpPath = ' + @DatabaseDumpPath
				PRINT '----------------------------------------------------------------------------------------------------'
				PRINT 'In usp_BackupDatabase_JobRun AT DP3 - END;'
				PRINT ''
			END
		END

		--DP4 - Begin
		IF  @debug >= 2
		BEGIN
			PRINT 'In usp_BackupDatabase_JobRun AT DP4 - Begin'
			PRINT '----------------------------------------------------------------------------------------------------'
			PRINT 'Calling usp_InsertdbsDatabaseBackupHistory to insert record and return valid @dbsDBHID:'
		END

	------------------------------------------------------------------------------------------------------------------------------------------------------
	-- FG Partial backup handler

	IF @isSysDB = 1 OR @ForceFull = 1
	BEGIN
		SET @dbExcludedFromDiffnPart = 1
		GOTO SKIP_DIFFnPARTIAL_BAK
	END
	ELSE ---------------------------
	IF (@dbsFGRPBackup = 1) --Filegroup Backup control variable
		AND (@dbsBackupProcessor <= 3
			OR @DBExternalException = 1)
	BEGIN -- FGRPBackup
		IF  @debug >= 2
		BEGIN
			PRINT 'In usp_BackupDatabase_JobRun AT DP4 - Filegroup Backup control variable'
		END

		SELECT  @exceptionNum = MAX(dbsDatabaseExceptionID)
		FROM [DBServices].[dbo].[dbsDatabaseException]
		WHERE dbsDatabaseUID = @dbsDatabaseUID
			AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'backup'
			AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionSubType))) = 'partial'

		IF @exceptionNum IS NOT NULL
		BEGIN
			IF (SELECT dbsExceptionActive
				FROM [DBServices].[dbo].[dbsDatabaseException]
				WHERE dbsDatabaseExceptionID = @exceptionNum) = 1
			BEGIN
				PRINT 'Info: ' + @DatabaseName + ' - exception identified for PARTIAL DB Backups: ' + CAST(@exceptionNum as nvarchar(5)) + ' - skipping'
				SET @dbExcludedFromDiffnPart = 1
				GOTO SKIP_PARTIAL_BAK
			END
			ELSE 
				SET @dbExcludedFromDiffnPart = 0
		
			--Partial backup alignment based ON configured weekday option
			IF (SELECT TOP 1 dbsAlign 
				FROM [DBServices].[dbo].[dbsDatabaseException]
				WHERE dbsDatabaseExceptionID = @exceptionNum
				) = @dbsAlign
			BEGIN
				PRINT 'Info: ' + @DatabaseName + ' - Full Backup alignment exception; full scheduled for today'
				SET @dbsFullPartialBackupDay = 1
			END
			ELSE 
				SET @dbsFullPartialBackupDay = 0
		END
		ELSE
			SET @dbsFullPartialBackupDay = CASE @dbsDiffnPartFullBackupAlignDay
												WHEN @dbsAlign THEN 1
												ELSE 0
											END

		--exclude system databases and DBServices from partial backups even if enabled
		IF @dbsFullPartialBackupDay = 0
			AND @dbExcludedFromDiffnPart = 0
		BEGIN
			IF CHARINDEX('_Full_', @DatabaseDumpPath) > 0 
				SET @DatabaseDumpPath = REPLACE(@DatabaseDumpPath, '_Full_', '_Part_')

			--store filegroups that will need to be sent to backup under partial backup scheme. 
			SET @fglist =''
			EXEC [DBServices].[dbo].[usp_PartialDatabaseBackup_fglist]
					@dbsDatabaseName = @DatabaseName
					,@PartialBackupStringOut = @fglist  OUTPUT
		END     

		IF  @debug >= 2
		BEGIN
			PRINT '1st day of week = Sunday' 
			PRINT 'Today = ' +  CAST(DATEPART(dw, GETDATE()) as char(1))
			PRINT '@dbsAlign = ' + CAST(@dbsAlign as char(1))
				+ ' @dbsFullPartialBackupDay = ' + CAST(@dbsFullPartialBackupDay as varchar)
				+ ' @dbExcludedFromDiffnPart = ' + CAST(@dbExcludedFromDiffnPart as varchar)
			PRINT '@fglist: ' + @fglist
		END
	             
	END -- FGRPBackup


	SKIP_PARTIAL_BAK:
	------------------------------------------------------
	-- Differentials
	IF @dbsDiffBackup = 1
		AND @dbsBackupProcessor <= 3 -- not CV 
		AND @dbsInstanceMajorVersion > 8 -- SQL 2005+

	BEGIN -- Local Differential backups
             
		SELECT @hours_since_install = DATEDIFF(hh, MAX(crdate), GETDATE())
		FROM [DBServices].[dbo].[sysobjects]
		WHERE [name] = 'dbsUBSMWEHeartbeat'
		
		--calculate percent changed for the database to determine
		--if differential backup is benefitial

		IF OBJECT_ID('tempdb..#DBCCPage') IS NOT NULL 
			DROP TABLE #DBCCPage
		
		CREATE TABLE #DBCCPage (
			  [ParentObject] varchar (100),
			  [Object]       varchar (100),
			  [Field]        varchar (100),
			  [VALUE]        varchar (100));

		SET @DIFFTotal = 1
		SET @sizeTotal = 1

		DECLARE curfiles CURSOR 
		FOR SELECT [file_id], [size] 
		FROM master.sys.master_files WITH (NOLOCK)
		WHERE [type_desc] = 'ROWS'
			AND [state_desc] = 'ONLINE'
			AND [database_id] = DB_ID (@DatabaseName)
		OPEN curfiles

		FETCH NEXT FROM curfiles 
			INTO @fileID, @fileSizePages
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SET @extentID = 0
			SET @sizeTotal = @sizeTotal + @fileSizePages / 8

			WHILE (@extentID < @fileSizePages)
			BEGIN
				SET @pageID = @extentID + 6
				SET @dbccPageString = 'DBCC PAGE (['
					+ @DatabaseName + '], '
					+ CAST (@fileID as varchar(5)) + ', '
					+ CAST (@pageID as varchar(20)) + ', 3) WITH TABLERESULTS, NO_INFOMSGS'

				TRUNCATE TABLE #DBCCPage

				INSERT INTO #DBCCPage
					EXEC (@dbccPageString);

				SELECT @total = SUM ([DBServices].[dbo].[fn_ConvertToExtents] ([Field]))
				FROM #DBCCPage
				WHERE [VALUE] = '    CHANGED'
					AND [ParentObject] LIKE 'DIFF_MAP%'

				SET @DIFFTotal = @DIFFTotal + @total
				SET @extentID = @extentID + 511232
			END -----------------------------------

			FETCH NEXT FROM curfiles 
			INTO @fileID, @fileSizePages
		END;

		-- clean up
		CLOSE curfiles
		DEALLOCATE curfiles

		IF OBJECT_ID('tempdb..#DBCCPage') IS NOT NULL 
			DROP TABLE #DBCCPage

		-----------------------------------
		--set percent data changed for the database
		SELECT @DIFFpercent = ROUND ((CONVERT (FLOAT, @DIFFTotal + 1)/CONVERT (FLOAT, @sizeTotal + 1)) * 100, 2)
	
		IF  @debug >= 2
		BEGIN
			PRINT 'Diff Backup Code status:'
			PRINT 'Diff percent: ' + CAST(@DIFFpercent as varchar)
			PRINT 'hours since mwe install: ' +  CAST(@hours_since_install as varchar)
			PRINT 'time of last backup: ' +      CAST(@dt_LastFullBak as varchar)
			PRINT 'Diff dbname: ' +              CAST(@DatabaseName as varchar)
			PRINT 'full age of backup: ' +       CAST(@LastFullBakage  as varchar)
			PRINT 'Diff btype: ' +               CAST(@bType as varchar) 
			PRINT 'Diff threshold: ' +           CAST(@diffthreshold as varchar)
		END
	 
		---------------------------------------------------------

		-- Determine the last BUFull job failure - CB: to determine whether offsite backup chain is complete. ie. MWE has to know about it
		SET @dt_LastFullBakJobFailure = NULL
		IF EXISTS (SELECT TOP 1 instance_id
					FROM [msdb].[dbo].[sysjobhistory]
					WHERE run_status <> 1  -- 0 = Failed, 1 = Succeeded, 2 = Retry, 3 = Canceled
						AND step_name = 'UBSMWE_WFST_BUFull (' + @DatabaseName + ')'
					ORDER BY instance_id DESC)
		BEGIN 
			SELECT TOP 1 @dt_LastFullBakJobFailure = CONVERT(DATETIME, LTRIM(RTRIM(run_date)))
				+ ((run_time * 9 
				+ run_time % 10000 * 6 
				+ run_time % 100 * 10) / 216e4)
			FROM [msdb].[dbo].[sysjobhistory]
			WHERE
				run_status <> 1  -- 0 = Failed, 1 = Succeeded, 2 = Retry, 3 = Canceled
				AND step_name = 'UBSMWE_WFST_BUFull (' + @DatabaseName + ')'
			ORDER BY instance_id DESC
		END

		IF @dt_LastFullBakJobFailure IS NULL -- Full backup job has never failed (or run)
			SET @dt_LastFullBakJobFailure = '1975-08-30 13:37:09.703' 

		-- Obtain time of last full backup
		SET @dt_LastFullBak = NULL
		SELECT @dt_LastFullBak = MAX(bs.[backup_finish_date])
		FROM [msdb].[dbo].[backupset] bs
		WHERE bs.[type] = 'D'
			AND bs.[database_name] = @DatabaseName
			AND bs.[backup_finish_date] >= @dt_LastFullBakJobFailure

		IF @dt_LastFullBak IS NULL
		BEGIN
			PRINT 'Info: Full backup has never executed for ' + @DatabaseName
			SET @LastFullBakage = 10000
		END
		ELSE
			SET @LastFullBakage = DATEDIFF(hh, @dt_LastFullBak, getdate())

		SELECT @dt_LastFullBakJobFailure as last_full_backup_job_failed
			, @dt_LastFullBak as last_full_backup
			, @LastFullBakage as backup_age_hr
			, @DIFFpercent as Percent_Changed_SinceFullBackup
		
		---------------------------------------------------------------------------
		-- Full backup alignment

		--check exclusion list
		--see if database is excluded from differential backups

		SELECT  @exceptionNum = MAX(dbsDatabaseExceptionID)
		FROM [DBServices].[dbo].[dbsDatabaseException]
		WHERE dbsDatabaseUID = @dbsDatabaseUID
			AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'backup'
			AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionSubType))) = 'differential'

		IF @exceptionNum IS NOT NULL
		BEGIN
			IF (SELECT dbsExceptionActive
				FROM [DBServices].[dbo].[dbsDatabaseException]
				WHERE dbsDatabaseExceptionID = @exceptionNum) = 1
			BEGIN
				PRINT 'Info: ' + @DatabaseName 
					+ ' - exception identified for DIFFERENTIAL DB Backups: ' 
					+ CAST(@exceptionNum as nvarchar(5))
				SET @dbExcludedFromDiffnPart = 1
			END
			ELSE 
				SET @dbExcludedFromDiffnPart = 0
		END -----------------------------------
		ELSE
			SET @dbExcludedFromDiffnPart = 0
	
		--Identify if full backup alignment exception also exists

		SELECT @exceptionNum = MAX(dbsDatabaseExceptionID)
		FROM [DBServices].[dbo].[dbsDatabaseException]
		WHERE dbsDatabaseUID = @dbsDatabaseUID
			AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'backup'
			AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionSubType))) = 'full';	

		IF @exceptionNum IS NOT NULL
		BEGIN
			IF (SELECT TOP 1 dbsAlign 
				FROM [DBServices].[dbo].[dbsDatabaseException]
				WHERE dbsDatabaseExceptionID = @exceptionNum
				) = @dbsAlign
			BEGIN
				PRINT 'Info: ' + @DatabaseName + ' - Full Backup alignment exception; full scheduled for today'
				SET @dbsFullBackupDay = 1
			END
			ELSE 
				SET @dbsFullBackupDay = 0
		END -----------------------------------
		ELSE
			SET @dbsFullBackupDay = CASE @dbsDiffnPartFullBackupAlignDay
										WHEN @dbsAlign THEN 1
										ELSE 0
									END
		---------------------------------------------------------------------------

		--Full backup alignment based ON configured weekday option @dbsAlign

		---------scrap-------------------
		--if dbo.dbsInstanceConfig 'dbsDiffBackupThreshold' value is not exceeded by age of backup
		--if last full backup did not fail or was not canceled
		--if database extents have not changed beyond 50%
		--if it has been over 23 hours since MWE install (settings need to take effect for time cycles)
	 
		IF  @debug >= 2
		BEGIN
			PRINT 'Partial/Full vs Diff conditions:'
			PRINT '@LastFullBakage: ' + CAST(@LastFullBakage as varchar(40))
			PRINT '@diffthreshold: ' + CAST(@diffthreshold as varchar(40))
			PRINT 'time of last backup (@dt_LastFullBak): ' + CAST(@dt_LastFullBak as varchar(40))
			PRINT '@dt_LastFullBakJobFailure:' + CAST(@dt_LastFullBakJobFailure as varchar(40))
			PRINT '@dbExcludedFromDiffnPart: ' + CAST(@dbExcludedFromDiffnPart  as varchar(40))
			PRINT '@DIFFpercent: ' + CAST(@DIFFpercent as varchar(40)) 
			PRINT '@dbsFullBackupDay: ' + CAST(@dbsFullBackupDay as varchar(40)) 
			PRINT '@dbsFullPartialBackupDay: ' + CAST(@dbsFullPartialBackupDay as varchar(40)) 
			PRINT 'Filename:' + @DatabaseDumpPath
			PRINT '@DBExternalException' + CAST(@DBExternalException as char(1))

			IF @dt_LastFullBakJobFailure < @dt_LastFullBak
				PRINT 'CONDITION @dt_LastFullBakJobFailure < @dt_LastFullBak IS TRUE - last failed BUFull job older than last full backup taken'
			ELSE
				PRINT 'CONDITION @dt_LastFullBakJobFailure < @dt_LastFullBak IS FALSE - last failed BUFull job newer than last full backup taken'

			IF @LastFullBakage < @diffthreshold
				PRINT 'CONDITION @LastFullBakage < @diffthreshold IS TRUE - run a DIFF backup'
			ELSE
				PRINT 'CONDITION @LastFullBakage < @diffthreshold IS FALSE - run a FULL backup'
			
			DECLARE @temp_index as int
			SET @temp_index = CHARINDEX('DBServices',@DatabaseName)
			PRINT 'Does database name contain DBServices in its name? : ' + CAST(@temp_index as varchar(40)) --? wtf
		END
		
		--then set the name to _Diff_ triggering differential backup in backup stored procedures
		IF (@LastFullBakage < @diffthreshold
			AND @DIFFpercent < @DIFFpercentThreshold
			AND @dbExcludedFromDiffnPart <> 1) 
			-- AND @dt_LastFullBakJobFailure < @dt_LastFullBak	-- CB dont care about the last job failure, only care how old the full is: taking condition out 
		BEGIN
			--this makes sure diff backup will not run ON a day which is set for full or partial full.
			IF @dbsDiffBackup = 1 
				AND CHARINDEX('_Full_', @DatabaseDumpPath) > 0
				AND @dbsFullBackupDay <> 1 
				AND @isSysDB = 0 
			BEGIN
				SET @DatabaseDumpPath = REPLACE(@DatabaseDumpPath, '_Full_', '_Diff_')
				PRINT @DatabaseName + ' Differentials - not a Full day - changing type: ' + @DatabaseDumpPath
			END
			
			IF @dbsFGRPBackup = 1
				AND CHARINDEX('_Part_', @DatabaseDumpPath) > 0
				AND @dbsFullPartialBackupDay <> 1
				AND @isSysDB = 0 
			BEGIN
				SET @DatabaseDumpPath = REPLACE(@DatabaseDumpPath, '_Part_', '_Diff_')
				PRINT @DatabaseName + ' Partials - not a Full day - changing type: ' + @DatabaseDumpPath
			END
		END

	END -- of Native SQL Differential backups

	SKIP_DIFFnPARTIAL_BAK:
	------------------------------------------------------------------------------------------------------------------------------------------------------

	IF @dbsStripe > 1  -- Native SQL DB backup striping 
	BEGIN            
		SET @i = 1
		SET @tempSql = ''
		            
		WHILE @i <= @dbsStripe
		BEGIN
			IF @dbsStripe > 1    
				SET @tempSql = LTRIM(RTRIM(REPLACE(@DatabaseDumpPath, '.bak', '_' + CAST(@i as nvarchar(2)) 
					+ 'of' + CAST(@dbsStripe as nvarchar(2)) + '.bak')))  

			IF  @debug >= 2
				SELECT 'Backup Filename: ' + @tempSql

			SET @StartDateTemp = getdate()

			EXEC @RC = [DBServices].[dbo].[usp_InsertdbsDatabaseBackupHistory]
											@dbsDatabaseUID = @dbsDatabaseUID,
											@dbsDBHIsLogFlag = 0, 
											@dbsDBHStartDate = @StartDateTemp, 
											@dbsDBHFileName = @tempSql,
											@dbsDBackupProcessorID = @dbsBackupProcessor,
											@dbsDBHActiveComputerName = @dbsDBHActiveComputerName,
											@dbsDBHID = @dbsDBHID OUTPUT
			IF @RC <> 0
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '') 
					+ ': Problem trying to insert data into dbsDatabaseBackupHistory' 
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise an warning alert 

				SET @FinalRC = 1
			END
			ELSE
			BEGIN
				PRINT 'Insert to dbsDatabaseBackupHistory successful'
				SELECT *
				FROM [DBServices].[dbo].dbsDatabaseBackupHistory 
				WHERE @dbsDBHID  = dbsDBHID
			END

			SET @i = @i + 1
		END
	END -----------------------------------
	ELSE
	BEGIN -- NO Native SQL DB backup striping 

		SET @StartDateTemp = getdate()

		EXEC @RC = [DBServices].[dbo].[usp_InsertdbsDatabaseBackupHistory]
										@dbsDatabaseUID = @dbsDatabaseUID,
										@dbsDBHIsLogFlag = 0, 
										@dbsDBHStartDate = @StartDateTemp, 
										@dbsDBHFileName = @DatabaseDumpPath,
										@dbsDBackupProcessorID = @dbsBackupProcessor,
										@dbsDBHActiveComputerName = @dbsDBHActiveComputerName,
										@dbsDBHID = @dbsDBHID OUTPUT
		IF @RC <> 0
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName
				+ ': Problem trying to insert data into dbsDatabaseBackupHistory' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise a warning alert
			 
			SET @FinalRC = 1
		END -----------------------------------
		ELSE
		IF  @debug >= 2
		BEGIN
			PRINT 'Insert to dbsDatabaseBackupHistory successful'

			SELECT *
			FROM  [DBServices].[dbo].dbsDatabaseBackupHistory
			WHERE @dbsDBHID  = dbsDBHID
		END
	END                  

	--DP4 - END
	IF  @debug >= 2
	BEGIN
		PRINT '@dbsDBHID = ' +  ISNULL(CAST(@dbsDBHID as varchar(255)), 'NULL')
		PRINT '@dbsDatabaseUID = ' +  ISNULL(CAST(@dbsDatabaseUID as varchar(255)), 'NULL')
		PRINT '@StartDateTemp = ' +  ISNULL(CAST(@StartDateTemp as varchar(255)), 'NULL')
		PRINT '@DatabaseDumpPath = ' +  @DatabaseDumpPath
		PRINT '@dbsBackupProcessor = ' +  ISNULL(CAST(@dbsBackupProcessor as varchar(255)), 'NULL')
		PRINT '@dbsDBHActiveComputerName = ' +  ISNULL(CAST(@dbsDBHActiveComputerName as varchar(255)), 'NULL')
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'In usp_BackupDatabase_JobRun AT DP4 - END;'
		PRINT ''
	END

	----------------------------------------------------------------------------------------------------
	-- DO full, diff, partial backup

	--DP5 - Begin
	IF  @debug >= 2
	BEGIN
		PRINT 'In usp_BackupDatabase_JobRun AT DP5 - Begin'
		PRINT '----------------------------------------------------------------------------------------------------'
	END
	
	UPDATE [DBServices].[dbo].dbsDatabaseBackup
	SET dbsDBIsInFullBackupProcess = 1
	WHERE dbsDatabaseUID = @dbsDatabaseUID
	
	SET @RC = 0
	IF @dbsBackupProcessor IN (1, 3) -- IF Native SQL backup / SQL 2k8 compression 
		OR @DBExternalException = 1
	BEGIN
		IF @debug >= 2
			PRINT 'Native FULL dump: usp_BackupDatabase_FULL_Base  ' + @DatabaseName + ', ' + @DatabaseDumpPath

		--DO
		EXEC @FinalRC = [DBServices].[dbo].usp_BackupDatabase_FULL_Base @DatabaseName, @DatabaseDumpPath
	END
	ELSE -----------------------------------
	IF @dbsBackupProcessor = 2 -- IF LiteSpeed  
	BEGIN
		IF @debug >= 2
			PRINT 'LiteSpeed FULL dump: usp_BackupDatabase_Full_LiteSpeed  ' + @DatabaseName + ', ' + @DatabaseDumpPath
		
		--DO
		EXEC @FinalRC = [DBServices].[dbo].usp_BackupDatabase_Full_LiteSpeed @DatabaseName, @DatabaseDumpPath
	END
	ELSE -----------------------------------
	IF @dbsBackupProcessor = 4 
		AND @DBExternalException = 0 -- CV SQLiDA client scheduled
	BEGIN 
		SELECT @dbsSubclientName = dbsSubclientName
			, @dbsDatabaseIsOndemandFlag = dbsDatabaseIsOndemandFlag
		FROM [DBServices].[dbo].[dbsCVSubclients]
		WHERE dbsDatabaseUID = @dbsDatabaseUID

		IF ISNULL(@dbsSubclientName, '') = ''
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName
				+ ': Unable to identify the Subclient in the dbsCVSubclient table; CV_List may need to be executed or the DB has not been registered. Exiting' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise a warning alert

			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 0
			WHERE dbsDatabaseUID = @dbsDatabaseUID

			SET @FinalRC = 1

			GOTO END_IT
		END -----------------------------------
		ELSE
		IF @dbsDatabaseIsOndemandFlag = 0
		BEGIN
			--database backups are managed by CommVault, the UBSMWE_WF_Daily_BUFull workflow will kick off backup ALL subclients command.
			SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '')  
				+ ' is backed up via CommVault SQL iDA and managed by UBSMWE as a collective via the main UBSMWE_WF_Daily_BUFull workflow job.'
			
			PRINT @ErrorMsg

			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 0
			WHERE dbsDatabaseUID = @dbsDatabaseUID
				
			EXEC @RC = [DBServices].[dbo].[usp_GetJobState] @dbsJobName= 'UBSMWE_WF_Daily_BUFull'
			
			IF @RC = 1 -- executed from UBSMWE_WF_Daily_BUFull, exit OK
			BEGIN
				SET @FinalRC = 0
				GOTO END_OK
			END
			ELSE
			BEGIN -- executed directly from calling job, exit failure to inform user 
				SET @FinalRC = 1
				GOTO END_IT
			END
		END -----------------------------------
		ELSE
		BEGIN -- @dbsDatabaseIsOndemandFlag = 1
			IF @debug >= 2
				PRINT 'CV SQLiDA FULL backup: usp_CVBackup ' + @DatabaseName + ', 0, 1'

			EXEC @FinalRC = [DBServices].[dbo].[usp_CVBackup] 
								@DBName = @DatabaseName
								,@BackupType = 0
								,@OnDemand = 1                   
		END	
	END	-- CV SQLiDA client scheduled
	ELSE -----------------------------------
	IF @dbsBackupProcessor = 5 -- IF TRRv3 CV Scheduled backups - only backup system DBs locally natively unless there is an exception
		AND @isSysDB = 1 
	BEGIN
		IF @debug >= 2
			PRINT 'Native FULL dump: usp_BackupDatabase_FULL_Base ' + @DatabaseName 
				+ ', ' + ISNULL(@DatabaseDumpPath, 'NULL')
				+ ', COPY ONLY' 

		EXEC @FinalRC = [DBServices].[dbo].usp_BackupDatabase_FULL_Base 
							@dbsDatabaseName = @DatabaseName
							,@DatabaseBackupFullPath = @DatabaseDumpPath
							,@CopyOnly = 1
	END
	ELSE -----------------------------------
	BEGIN -- ERROR as @dbsBackupProcessor clearly not set correctly

		SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName
			+ ': Invalid request for the configured @dbsBackupProcessor type = ' + CAST(@dbsBackupProcessor as char(1)) 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInFullBackupProcess = 0
		WHERE dbsDatabaseUID = @dbsDatabaseUID

		SET @FinalRC = 1

		GOTO END_IT
	END

	--let I/O finish:
	PRINT '...waiting 5 seconds'
	WAITFOR DELAY '00:00:05'

	IF @FinalRC <> 0
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '') 
			+ ': FULL Backup failure - investigation required' 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInFullBackupProcess = 0
		WHERE dbsDatabaseUID = @dbsDatabaseUID

		PRINT '@dbsDatabaseName = ' +  ISNULL(CAST(@DatabaseName as varchar(255)), 'NULL')
		PRINT '@DatabaseDumpPath = ' +   ISNULL(@DatabaseDumpPath, 'NULL')

		GOTO END_IT
	END

	--DP5 - END
	IF  @debug >= 2
	BEGIN
		PRINT '@dbsDatabaseName = ' +  ISNULL(CAST(@DatabaseName as varchar(255)), 'NULL')
		PRINT '@DatabaseDumpPath = ' +   ISNULL(@DatabaseDumpPath, 'NULL')
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'In usp_BackupDatabase_JobRun AT DP5 - END;'
		PRINT ''
	END

	-----------------------------------
	-- Update backup history table 
	--DP6 - Begin

	IF  @debug >= 2
	BEGIN
		PRINT 'In usp_BackupDatabase_JobRun AT DP6 - Begin'
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'Calling usp_UpdatedbsDatabaseBackupHistory ' + ISNULL(CAST(@dbsDBHID as nvarchar(255)), 'NULL') + ', ' + CONVERT ( varchar ( 255 )  , @EndDateTemp , 114  )
	END

	SET @EndDateTemp = getdate()
	IF @dbsStripe > 1 AND @dbsBackupProcessor <> 4
	BEGIN            
		SET @i = 1            
		WHILE @i <= @dbsStripe
		BEGIN
			EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsDatabaseBackupHistory] @dbsDBHID, @EndDateTemp --@dbsDBHEndDate,
	
			IF @RC <> 0
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '')  
					+ ': Problem trying to insert data into usp_UpdatedbsDatabaseBackupHistory' 
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise a warning alert

				SET @FinalRC = 1 -- return failure
			END

			SET @dbsDBHID = @dbsDBHID - 1
			SET @i = @i + 1
		END 
	END -----------------------------------
	ELSE
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsDatabaseBackupHistory] @dbsDBHID, @EndDateTemp --@dbsDBHEndDate,

		IF @RC <> 0
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '') 
				+ ': Problem trying to insert data into usp_UpdatedbsDatabaseBackupHistory' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise a warning alert

			SET @FinalRC = 1 -- return failure
		END
		-------ADD COMMVAULT CODE TO SET FILE AS BEING NOT ON DISK
		-------AND REPLACE FILENAME TO INDICATE THE FILE CODE OBTAINED FROM COMMCELL OPERATION                    
	END       
	                     
	--DP6 - END
	IF  @debug >= 2
	BEGIN
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'In usp_BackupDatabase_JobRun AT DP6 - END;'
		PRINT ''
	END

	--DP7 - Begin
	IF  @debug >= 2
	BEGIN
		PRINT 'In usp_BackupDatabase_JobRun AT DP7 - Begin'
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'Updating dbsDatabaseBackup table WITH final status;'
	END

	-- Updating dbsDatabaseBackup table WITH final status
	IF (@dbsBackupProcessor <= 4) 
		OR (@dbsBackupProcessor = 5 AND @isSysDB = 1) 
		OR (@DBExternalException = 1) 
	BEGIN

		UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
		SET dbsDBLastFullBackupRun = getdate(),
			dbsDBIsInFullBackupProcess = 0,
			dbsDBDoFullBackupNow = 0,
			dbsDBNextFullBackupRun =DATEADD (day, 1,
												(CONVERT(DATETIME,
													(CONVERT(varchar(4),DATEPART(year,getdate()))
														+ '-'  + CONVERT(varchar(4), DATEPART(month,getdate()))
														+ '-'  + CONVERT(varchar(4), DATEPART(day, getdate()))
														+ ' ' + @dbsDatabaseFullBackupStartTime))
												)
											)
		WHERE dbsDatabaseUID = @dbsDatabaseUID
                       
		   --TABLE [dbo].[dbsPartialBackupHistory](
		--	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
		--	[dbsDatabaseName] [sysname] NOT NULL,
		--	[dbsPartialBackupIsActiveFlag] [bit] NOT NULL,
		--	[dbsPartialBackupStartDate] [datetime] NULL,
		--	[dbsPartialBackupEndDate] [datetime] NULL,
		--	[dbsPartialBackupStatus] [int] NULL,
		--	[dbsPartialBackupExitStep] [int] NULL,
		--  [dbsDBHFileName] nvarchar(255),
		--	[dbsDBHActiveComputerName] nvarchar(255),                   

		-----------------------------------		
		IF (@dbsFGRPBackup = 1)
			AND ((@dbsBackupProcessor <= 3)
				OR (@dbsBackupProcessor = 5 AND @isSysDB = 1)
				OR (@DBExternalException = 1))
		BEGIN

			IF  @debug >= 2  
			BEGIN
				PRINT 'Updating dbsPartialBackupHistory table with final status for Partial Backups;'
			END             
       
			--@fgfilelist is initalized in the begining to be stored in dbsPartialBackupHistory tables
		
			SET @EndDateTemp = getdate()
			SET @i = 1
			SET @tempSql = ''            

			WHILE @i <= @dbsStripe
			BEGIN
				IF @dbsStripe > 1    
				   SET @tempSql = LTRIM(RTRIM(REPLACE(@DatabaseDumpPath, '.bak', '_' 
						+ CAST(@i as nvarchar(2))
						+ 'of' + CAST(@dbsStripe as nvarchar(2)) + '.bak')))  
			
				EXEC @RC = [DBServices].[dbo].[usp_InsertdbsDatabasePartialBackupHistory]
													  @dbsDatabaseUID		--dbsDatabaseUID
													, @DatabaseName		--dbsDatabaseName
													, 1						--dbsPartialBackupIsActiveFlag
													, @StartDateTemp		--dbsPartialBackupEndDate
													, @EndDateTemp			--[dbsPartialBackupEndDate]
													, 0						--[dbsPartialBackupStatus]
													, 0						--[dbsPartialBackupExitStep] 
													, @tempSql				--[dbsDBHFileName]
													, @dbsDBHActiveComputerName	--[dbsDBHActiveComputerName] 
													, @fglist				--[dbsFGList]           
													--, @dbsDBHID_unused OUTPUT         
				IF @RC <> 0
				BEGIN
					SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '') 
						 + ': Problem trying to insert data into dbsDatabasePartialBackupHistory' 
					EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise a warning alert

					SET @FinalRC = 1 -- return failure
				END
				ELSE
				IF  @debug >= 2
				BEGIN
					PRINT 'Insert to dbsPartialBackupHistory successful'
					SELECT * 
					FROM [DBServices].[dbo].dbsDatabaseBackupHistory
					WHERE @dbsDBHID  = dbsDBHID
				END  

				SELECT @i = @i + 1  
			END -- while

		END --@dbsFGRPBackup = 1 

		--DP7 - END
		IF  @debug >= 2
		BEGIN
			PRINT '----------------------------------------------------------------------------------------------------'
			PRINT 'In usp_BackupDatabase_JobRun AT DP7 - END;'
			PRINT ''
		END
			 
	END -- end of Updating dbsDatabaseBackup table WITH final status

END  -- end Database Backup
	
GOTO UPDATE_MSSQLCentral

END --FULL Database Backup

--FULL Backups end --------------------------------------------------------------------------------------------------------------------------------


-- LOG Backups ------------------------------------------------------------------------------------------------------------------------------------

IF @BackupType = 2 -- 2 = TLog
BEGIN --Log Database Backup

	SET @dbsDBHIsLogFlag  = 1

	SELECT @exceptionNum = MAX(dbsDatabaseExceptionID)
	FROM [DBServices].[dbo].[dbsDatabaseException] 
	WHERE dbsDatabaseUID = @dbsDatabaseUID
		AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'backup'
		AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionSubType))) = 'transaction_log';
	
	IF (SELECT dbsExceptionActive
		FROM [DBServices].[dbo].[dbsDatabaseException]
		WHERE dbsDatabaseExceptionID = @exceptionNum) = 1
		GOTO END_OK -- nothing to do - just exit

	---------------------------
	-- ELSE continue with log backup

	-- Determine dump file path (if local)

	IF @dbsBackupProcessor IN (1,2,3)
		OR (@dbsCVParallelOps = 1)
		OR (@DBExternalException = 1)
	BEGIN
		SET @DatabaseDumpPath = @dbsDBFileLocation
			+ '\'
			+ REPLACE(LEFT(@DatabaseName, 64), '\', '#') 
			+ '_LOG_' + @year
			+ CASE WHEN LEN (@month) = 2 THEN @month ELSE '0' +  LTRIM(@month) END 
			+ CASE WHEN LEN (@day) = 2 THEN @day ELSE '0' +  LTRIM(@day) END 
			+ CASE WHEN LEN (@hour) = 2 THEN @hour ELSE '0' +  LTRIM(@hour) END 
			+ CASE WHEN LEN (@minute) = 2 THEN @minute ELSE '0' +  LTRIM(@minute) END  
			+ CASE WHEN LEN (@second) = 2 THEN @second ELSE '0' +  LTRIM(@second) END
			+ '.TRN'
		    
		IF ISNULL(@DatabaseDumpPath,'') = ''
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: Unhandled exception ' + @DatabaseName 
				+' TLog @DatabaseDumpPath = NULL' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

			GOTO END_IT
		END
		ELSE
		IF LEN(@DatabaseDumpPath) > 255
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: Backup file path for DB ' + @DatabaseName 
				+ ' exceeds OS limitation of 255 chars: ' + @DatabaseDumpPath + ' unable to proceed!'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	

			GOTO END_IT
		END	
		ELSE -- Ensure valid filename
			SET @DatabaseDumpPath = [DBServices].[dbo].[ufn_SafeFileName](@DatabaseDumpPath)
	END

	IF  @debug >= 2
	BEGIN
		PRINT '----------------------------------------------------------------------------------------------------'
		PRINT 'In usp_BackupDatabase_JobRun logbackup'
		PRINT '---------------------------------------------------------------------------------------------------'
	END

	---------------------------
	-- Update MWE system tables

	UPDATE [DBServices].[dbo].dbsDatabaseBackup
	SET dbsDBIsInLogBackupProcess = 1
	WHERE dbsDatabaseUID = @dbsDatabaseUID

	SET @StartDateTemp = getdate()

	EXEC @RC = [DBServices].[dbo].[usp_InsertdbsDatabaseBackupHistory]
									@dbsDatabaseUID = @dbsDatabaseUID,
									@dbsDBHIsLogFlag = 1, 
									@dbsDBHStartDate = @StartDateTemp, 
									@dbsDBHFileName = @DatabaseDumpPath,
									@dbsDBackupProcessorID = @dbsBackupProcessor,
									@dbsDBHActiveComputerName = @dbsDBHActiveComputerName,
									@dbsDBHID = @dbsDBHID OUTPUT

	SELECT @dbsDBHParentID = MAX(dbsDBHID)
	FROM  [DBServices].[dbo].[dbsDatabaseBackupHistory]
	WHERE  dbsDatabaseUID = @dbsDatabaseUID
		AND dbsDBHIsLogFlag = 0
	                                
	SELECT '@dbsDBHParentID = ', @dbsDBHParentID

	------------------------------------------------------
	-- Exec TLog backup DO

	IF @dbsBackupProcessor IN (1,3) -- SQL Native
		OR @DBExternalException = 1
		EXEC @FinalRC = [DBServices].[dbo].usp_BackupDatabase_Log_Base @DatabaseName, @DatabaseDumpPath

	ELSE ---------------------------
	IF @dbsBackupProcessor = 2	-- SQL LiteSpeed
		EXEC @FinalRC = [DBServices].[dbo].usp_BackupDatabase_Log_LiteSpeed @DatabaseName, @DatabaseDumpPath

	ELSE ---------------------------
	IF @dbsBackupProcessor = 4 -- CV SQLiDA client scheduled
		AND @DBExternalException = 0
	BEGIN
		IF @dbsCVParallelOps = 0 -- CV SQLiDA TLog backups
		BEGIN
			-- Check if DB is a member of a Subclient and detemine dbsDatabaseIsOndemandFlag status
			SELECT @dbsSubclientName = dbsSubclientName
				,@dbsDatabaseIsOndemandFlag = dbsDatabaseIsOndemandFlag
			FROM [DBServices].[dbo].[dbsCVSubclients]
			WHERE dbsDatabaseUID = @dbsDatabaseUID

			IF @dbsSubclientName IS NULL
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName
					+ ': Unable to identify the Subclient in the dbsCVSubclient table; CV_List may need to be executed or the DB has not been registered. Exiting' 
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

				UPDATE [DBServices].[dbo].dbsDatabaseBackup
				SET dbsDBIsInLogBackupProcess = 0
				WHERE dbsDatabaseUID = @dbsDatabaseUID

				SET @FinalRC = 1

				GOTO END_IT
			END ---------------------------
			ELSE
			IF @dbsDatabaseIsOndemandFlag = 0
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: Please note ' + @DatabaseName
					 + ' is backed up via CommVault SQL iDA and managed by UBSMWE as a collective via the main UBSMWE_WF_Daily_BULog workflow job.'

				PRINT @ErrorMsg 
						
				UPDATE [DBServices].[dbo].dbsDatabaseBackup
				SET dbsDBIsInLogBackupProcess = 0
				WHERE dbsDatabaseUID = @dbsDatabaseUID

				EXEC @RC = [DBServices].[dbo].[usp_GetJobState] @dbsJobName= 'UBSMWE_WF_Daily_BULog'
				
				IF @RC = 1 -- executed from UBSMWE_WF_Daily_BULog, exit OK
				BEGIN
					SET @FinalRC = 0
					GOTO END_OK
				END
				ELSE
				BEGIN -- executed directly from calling job, exit failure to inform user 
					SET @FinalRC = 1
					GOTO END_IT
				END
			END ---------------------------
			ELSE
			BEGIN 
				IF @debug >= 2
					PRINT 'SQL iDA Tlog backup: usp_CVBackup ' + @DatabaseName + ', 1' 

				-- @dbsDatabaseIsOndemandFlag = 1 (e.g. SINGLE subclients), exec CV SQL iDA log backup
				EXEC @FinalRC = [DBServices].[dbo].[usp_CVBackup] @DatabaseName, 1 
			END	
		END ---------------------------
		ELSE -- @dbsCVParallelOps = 1
		BEGIN
			IF @debug >= 2
				PRINT 'Native Tlog dump: usp_BackupDatabase_Log_Base ' + @DatabaseName
					 + ', ' + @DatabaseDumpPath

			EXEC @FinalRC = [DBServices].[dbo].[usp_BackupDatabase_Log_Base] @DatabaseName, @DatabaseDumpPath			
		END
	END	-- CV SQLiDA client scheduled
	ELSE ---------------------------
	IF @dbsBackupProcessor = 5 
		AND @isSysDB = 1 -- IF TRRv3 CV Scheduled backups - will only backup system DBs locally natively
	BEGIN
		IF @debug >= 2
			PRINT 'Native Tlog dump: usp_BackupDatabase_Log_Base ' + @DatabaseName 
				+ ', ' + @DatabaseDumpPath
				+ ', COPY ONLY'

		EXEC @FinalRC = [DBServices].[dbo].usp_BackupDatabase_Log_Base 
							@dbsDatabaseName = @DatabaseName
							,@DatabaseBackupFullPath = @DatabaseDumpPath
							,@CopyOnly = 1
	END
	ELSE -- ERROR as @dbsBackupProcessor clearly not set correctly
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName 
			+': Invalid request for the configured @dbsBackupProcessor type = ' + CAST(@dbsBackupProcessor as char(1)) 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	 -- 1 info, 2 warning, 3 Error

		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInLogBackupProcess = 0
		WHERE dbsDatabaseUID = @dbsDatabaseUID

		SET @FinalRC = 1

		GOTO END_IT
	END ---------------------------
	
	--let I/O finish:
	PRINT '...waiting 5 seconds'
	WAITFOR DELAY '00:00:05'

	IF @FinalRC <> 0
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName
			 + ': TLog Backup failure - investigation required' 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	 -- 1 info, 2 warning, 3 Error

		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInLogBackupProcess = 0
		WHERE dbsDatabaseUID = @dbsDatabaseUID

		GOTO END_IT
	END

	SELECT @EndDateTemp = getdate()

	EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsDatabaseBackupHistory]
										@dbsDBHID,
										@EndDateTemp --@dbsDBHEndDate
	IF @RC <> 0
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + @DatabaseName
					 + ': usp_UpdatedbsDatabaseBackupHistory update failure'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- Info

		SET @FinalRC = 1
	END

	UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
	SET dbsDBLastLogBackupRun = getdate(),
		dbsDBIsInLogBackupProcess = 0,
		dbsDBDoLogBackupNow = 0,
		dbsDBNextLogBackupRun = DATEADD( minute, CONVERT(int,@dbsDatabaseLogBackupIntervalMinute),  getdate())
	WHERE dbsDatabaseUID = @dbsDatabaseUID
     
END --Log Database Backup

-- LOG Backups end ------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------
UPDATE_MSSQLCentral:
  
--Only send completed record to MSSQLCentral. Moved code from middle of sproc to finish.
--DP8 - Begin

IF  @debug >= 2
BEGIN
    PRINT 'In usp_BackupDatabase_JobRun AT DP8 - Begin'
    PRINT '----------------------------------------------------------------------------------------------------'
    PRINT 'Calling msc_UpdatedbsDatabaseBackupHistory;'
END

DECLARE @dbsDBHIsOnDiskFlag char(1)
	,@dbsDBHSentToNBFlag char(1)

IF (@dbsBackupProcessor = 4 -- tlog
		AND @BackupType = 2
		AND @dbsCVParallelOps = 0
		AND @DBExternalException = 0) 

	OR (@dbsBackupProcessor = 4 -- full
		AND @BackupType = 1
		AND @DBExternalException = 0)	
	
	OR (@dbsBackupProcessor = 5 --tlog
		AND @BackupType = 2
		AND @dbsCVParallelOps = 0 
		AND @DBExternalException = 0)  -- case should never occur

	OR (@dbsBackupProcessor = 5 --full 
		AND @BackupType = 1
		AND @isSysDB = 0 
		AND @DBExternalException = 0)  -- case should never occur
BEGIN
	SET @dbsDBHIsOnDiskFlag = '0'
	SET @dbsDBHSentToNBFlag = '1'	-- Legacy flag, now for all offsite FS backups
END
ELSE ---------------
BEGIN 
	SET @dbsDBHIsOnDiskFlag = '1'
	SET @dbsDBHSentToNBFlag = '0'
END

-- Update SQL Central DO
EXEC @RC = [DBServices].[dbo].[msc_UpdatedbsDatabaseBackupHistory]
	   @dbsDBHID =  @dbsDBHID
	  ,@dbsDatabaseUID = @dbsDatabaseUID
	  ,@dbsDBHIsLogFlag = @dbsDBHIsLogFlag
	  ,@dbsDBHStartDate = @StartDateTemp
	  ,@dbsDBHEndDate = @dbsDBHEndDate
	  ,@dbsDBHFileName = @DatabaseDumpPath --@dbsDBHFileName
	  ,@dbsDBHIsOnDiskFlag = @dbsDBHIsOnDiskFlag
	  ,@dbsDBackupProcessorID = @dbsBackupProcessor
	  ,@dbsDBHParentID = @dbsDBHParentID
	  ,@dbsDBHActiveComputerName = @dbsDBHActiveComputerName
	  ,@dbsDBHSentToNBFlag = @dbsDBHSentToNBFlag

IF @RC <> 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_BackupDatabase_JobRun: ' + ISNULL(@DatabaseName, '')  
					+ ': msc_UpdatedbsDatabaseBackupHistory update failure'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 	-- Warning

	SET @FinalRC = 1
END		

--DP8 - END
IF  @debug >= 2
BEGIN
	PRINT '@DatabaseName = ' +  ISNULL(CAST(@DatabaseName as varchar(255)), 'NULL')
	PRINT '@DatabaseDumpPath = ' + @DatabaseDumpPath

	PRINT '@dbsDBHID = ' +  ISNULL(CAST(@dbsDBHID as varchar(255)), 'NULL')
	PRINT '@dbsDatabaseUID = ' +  ISNULL(CAST(@dbsDatabaseUID  as varchar(255)), 'NULL')
	PRINT '@dbsDBHIsLogFlag = ' +  ISNULL(CAST(@dbsDBHIsLogFlag  as varchar(255)), 'NULL')
	PRINT '@dbsDBHStartDate = ' +  ISNULL(CAST(@StartDateTemp as varchar(255)), 'NULL')
	PRINT '@dbsDBHEndDate = ' +  ISNULL(CAST(@dbsDBHEndDate as varchar(255)), 'NULL')
	
	PRINT '@dbsDBHIsOnDiskFlag = ' + @dbsDBHIsOnDiskFlag
	PRINT '@dbsDBHSentToNBFlag = ' + @dbsDBHSentToNBFlag
	
	PRINT '@dbsDBackupProcessorID = ' +  ISNULL(CAST(@dbsBackupProcessor as varchar(255)), 'NULL')
	PRINT '@dbsDBHParentID = ' +  ISNULL(CAST(@dbsDBHParentID as varchar(255)), 'NULL')
	PRINT '@dbsDBHActiveComputerName = ' +  ISNULL(CAST(@dbsDBHActiveComputerName as varchar(255)), 'NULL')

	PRINT '----------------------------------------------------------------------------------------------------'
	PRINT 'In usp_BackupDatabase_JobRun AT DP8 - END;'
	PRINT ''
END
----------------------------------------------------------------------------------

END_OK:
IF OBJECT_ID('tempdb..#DBCCPage') IS NOT NULL 
	DROP TABLE #DBCCPage

RETURN (@FinalRC)

END_IT:
IF OBJECT_ID('tempdb..#DBCCPage') IS NOT NULL 
	DROP TABLE #DBCCPage

RETURN (1) -- Return failure

END --End main()


GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase_LMB_FULL]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_BackupDatabase_LMB_FULL] @DatabaseName nvarchar(255)
				--,@BackupType int  --1 = Database, 2 = Log

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_BackupDatabase_LMB_FULL.SQL
// 
// Purpose:
//   Perform Backup of databases
//
// Notes: This stored procedure is called from specific db backup job.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 06/12/2004 @Author: Kevin Wagner @Version: 1.5.1 HF1 @Action: Inception...
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

BEGIN  --Begin main()

	--Force to full backup, this is just a wrapper for the SMB project guaranteeing a consistent interface to the UBSMWE backup procedure. 
	EXEC DBServices.dbo.usp_BackupDatabase_JobRun @DatabaseName, 1 


END --End main()


GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase_Log_Base]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupDatabase_Log_Base] 
					@dbsDatabaseName nvarchar(128), 
					@DatabaseBackupFullPath nvarchar(255),
					@CopyOnly bit = 0
AS
/****************************************************************************************
// @File: usp_BackupDatabase_Log_Base.sql
// 
// Purpose:
//   Perform Log Backup of named database using SQL native syntax
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase. 
//
// History:
//   @Author: Kevin Wagner 
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 18/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 11/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.15 @Action: TRRv3 TRR-95 @CopyOnly
//   @Date: 11/11/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.40 @Action: Add BUFFERCOUNT and MAXTRANSFERSIZE support for tlog backups
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@sql1 nvarchar(1000)
	,@sql2 nvarchar(1000)
	,@sql3 nvarchar(255)
	,@RC int
	,@MAXTRANSFERSIZE nvarchar(10)
 	,@BUFFERCOUNT nvarchar(10)
	,@debug tinyint

-- Get config
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT

--BUFFERCOUNT Native Backup Config variable
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBUFFERCOUNT', @BUFFERCOUNT OUTPUT

--MAXTRANSFERSIZE Native Backup Config variable
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsMAXTRANSFERSIZE', @MAXTRANSFERSIZE OUTPUT

--------------------------------
-- Compile backup cmd

SET @sql1 = 'BACKUP LOG ['
	+ @dbsDatabaseName
	+'] TO  DISK = N'''
	+ @DatabaseBackupFullPath
	+ ''' WITH ' + CASE @CopyOnly
						WHEN 1 THEN 'COPY_ONLY, '
						ELSE ''
						END
		+ 'NOINIT, NOUNLOAD, NAME = N''' 

SET @sql2 = @dbsDatabaseName
	+' backup'', SKIP, STATS = 10, DESCRIPTION = N'''
	+ 'UBSMWE'''
	+ ', NOFORMAT'

IF ISNUMERIC(@MAXTRANSFERSIZE) = 1
	AND ISNUMERIC(@BUFFERCOUNT) = 1
	SET @sql3 = ', MAXTRANSFERSIZE=' + @MAXTRANSFERSIZE
				+ ', BUFFERCOUNT=' + @BUFFERCOUNT
ELSE
	SET @sql3 =	''

--------------------------------
-- *** Run backup cmd ***

IF @debug >= 2
	PRINT @sql1 + @sql2 + @sql3

EXEC (@sql1 + @sql2 + @sql3)

SET @RC = @@ERROR
IF @RC <> 0
	RETURN 1
ELSE 
	RETURN 0

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_BackupDatabase_Log_LiteSpeed]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupDatabase_Log_LiteSpeed] 
	@dbsDatabaseName nvarchar(128), 
	@DatabaseBackupFullPath nvarchar(255)

AS

/****************************************************************************************
// @File: usp_BackupDatabase_Log_LiteSpeed.SQL
// 
// Purpose:
//   Perform Log Backup of named database using LiteSpeed syntax
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase. 
//
// History:
//
//   @Version: Beta General
//   @Author: Kevin Wagner 
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 18/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE	@LiteSpeedThreads INT
		,@RC int

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'LiteSpeedThreads', @LiteSpeedThreads OUTPUT 
IF @RC <> 0 
BEGIN
	PRINT 'The setting for LiteSpeedTreads was not found, defaulting to 3 threads for this run of backup.'
	SET @LiteSpeedThreads = 3
END		
		
-- =============================================
-- Execute SQL LiteSpeed Transaction Log Database Backup 
-- =============================================
EXEC master.dbo.xp_backup_log    
	      	@database = @dbsDatabaseName
	    , @FileName = @DatabaseBackupFullPath 
	, @desc = 'UBSMWE' --@dbsDatabaseName --@DatabaseBackupFullPath + ' backup'
	, @threads = @LiteSpeedThreads --@Number_threads
	, @init = 1 --@InitBackupDevice
	--, @encryptionkey = '@encryptionKey'
	--, @file= '@LogicalFileName'
	--, @filegroup= '@LogicalFilegroupName'
	--, @with = '@AdditionalWithParams'
	--, @priority = @PriLevel
		
SET @RC = @@ERROR
RETURN (@RC)

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_BackupLUN_Mon]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_BackupLUN_Mon]
AS
/****************************************************************************************
// @File: usp_BackupLUN_Mon.SQL
// 
// @Version 6.0.0.27
// Purpose: In the event the space available within a DB backup LUN falls below a pre-defined threshold:
//	The UBSMWE v6.0 toolkit will initiate an automatic Ad-Hoc SQL iDA transaction log DB backup.
//	This process will force the SQL iDA to purge any CV scheduled transaction log dumps which are known 
//	to have been archived and initiate a file system iDA backup of any remaining dump files with high priority.
//	A SCOM / Netcool alert will be generated informing the DB Service Delivery for further investigation.
//
// Notes: Compatible with SQL 2005 and above
// Dependancy: [usp_CVScheduleForceTlogBackups]
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 21/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 beta
//   @Date: 18/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.12 @Action: TRRv3 mount point support
//	 @Date: 16/02/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.25 @Action: Feature request: add DB backup monitoring for CV TRRv3 
//	 @Date: 09/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.27 @Action: Bugfix TRR-126
****************************************************************************************/
BEGIN -- main

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int 
	, @CV_SqlLogBackupStageFolder nvarchar(255)
	, @CV_bTLBackupToFS int
	, @CV_backupFromFSForLog int
	, @CV_Enabled bit
	, @NB_Enabled bit
	, @dbsBackupLUN_SpaceThresholdPerc tinyint
	, @dbsInstanceFileLocation nvarchar(255)
	, @NB_WorkDirectory nvarchar(255)
	, @i tinyint
	, @CurrLUN char(1)
	, @msg_body nvarchar(255)
	, @str nvarchar(500)
	, @alertflag as bit
	, @CR char(2)
	, @TAB char(1)
	, @dbsBackupProcessor tinyint
	, @SubClient nvarchar(128)
	, @dbsBackupLUN_LastAlertDT smalldatetime 
	, @dbsBackupLUN_RetryMins tinyint 
	, @DeviceName varchar(256)
	, @CapacityMB numeric
	, @FreeSpace numeric
	, @PercFree tinyint
	, @Threshold varchar(8)
	, @CV_SqlLogBackupInterval int
	
------------------------------------------------------------------------------------------------
-- Constants
SET @CR = CHAR(13) + CHAR(10) -- Carridge return
SET @TAB = CHAR(9) -- Tab
SET @msg_body = ''
SET @RC = 0
SET @msg_body = 'UBSMWE: usp_BackupLUN_Mon: '

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupLUN_RetryMins', @dbsBackupLUN_RetryMins OUTPUT
IF @RC <> 0
	OR ISNULL(@dbsBackupLUN_RetryMins,'') = ''
BEGIN
	-- missing or invalid dbsBackupLUN_RetryMin parameter - default to 60mins
	EXEC [DBServices].[dbo].[usp_ConfigureUBSMWE] 
			@dbsInstanceConfigName = 'dbsBackupLUN_RetryMins' 
			,@dbsInstanceConfigValue = '60'
	
	SET @dbsBackupLUN_RetryMins = 60
	-- then continue with check...
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupLUN_LastAlertDT', @str OUTPUT
IF @RC <> 0
	OR ISNULL(@str,'') = ''
	OR ISDATE(@str) = 0
BEGIN
	-- missing or invalid dbsBackupLUN_LastAlertDT parameter - resetting
	EXEC [DBServices].[dbo].[usp_ConfigureUBSMWE] 
			@dbsInstanceConfigName = 'dbsBackupLUN_LastAlertDT' 
			,@dbsInstanceConfigValue = 'Mar 05 1972  0:00AM'
	-- then continue with check...
END
ELSE -----------------
BEGIN
	SET @dbsBackupLUN_LastAlertDT = CAST(@str as smalldatetime)
	IF DATEDIFF (minute, @dbsBackupLUN_LastAlertDT, getdate()) < @dbsBackupLUN_RetryMins
	BEGIN
		-- Already in an alert state - skip for @dbsBackupLUN_RetryMins minutes
		PRINT @msg_body + 'Backup LUN Monitor Alert already initiated at ' 
			+ CAST(@dbsBackupLUN_LastAlertDT as varchar(20)) 
			+ ' - skipping until: ' + CAST(DATEADD(minute, @dbsBackupLUN_RetryMins, @dbsBackupLUN_LastAlertDT) as varchar(20))
		RETURN 0 
	END
END

-- Get Config
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_WorkDirectory', @NB_WorkDirectory OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupLUN_SpaceThresholdPerc', @dbsBackupLUN_SpaceThresholdPerc OUTPUT

IF @dbsBackupLUN_SpaceThresholdPerc IS NULL 
	OR NOT (@dbsBackupLUN_SpaceThresholdPerc BETWEEN 0 AND 100)
BEGIN
	SET @msg_body = @msg_body + 'ERROR - InstanceConfig parameter dbsBackupLUN_SpaceThresholdPerc incorrectly set; defaulting to 10%' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 1

	SET @dbsBackupLUN_SpaceThresholdPerc = 10
END

------------------------------------------------------------------------------------------------
-- DO

IF @CV_Enabled=1 OR @NB_Enabled=1
BEGIN
	-----------------------
	-- Check for stale file dumps
	EXEC [DBServices].[dbo].usp_ChkStaleFileDumps 

	-- Get Volume info
	EXEC @RC = [DBServices].[dbo].[usp_fixeddrives2] @dbsBackupLUN_SpaceThresholdPerc

	IF @RC = 0
	BEGIN
		PRINT @msg_body + 'Backup LUN space ' + CAST(@dbsBackupLUN_SpaceThresholdPerc as varchar(2)) + '% threshold check: OK' 
		GOTO END_OK
	END
	ELSE
	IF @RC <> 999
	BEGIN
		SET @msg_body = @msg_body + 'Unhandled Exception, unable to verify Backup LUN space'
		EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2

		GOTO END_IT
	END
	ELSE -- @RC = 999
	IF NOT EXISTS (SELECT 1
		FROM [DBServices].[dbo].[dbsVolInfo])
	BEGIN
		SET @msg_body = @msg_body + 'Unhandled exception; failed to obtain volume space details' 
		EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2

		GOTO END_IT
	END

	-- @RC = 999: a LUN is below threshold, verify if it is a backup LUN....  
	-- See [DBServices].[dbo].[dbsVolInfo]

	-----------------------
	-- Identify Backup LUNs

	IF OBJECT_ID('tempdb..#bkdrives') IS NOT NULL 
		DROP TABLE #bkdrives

	CREATE TABLE #bkdrives (drive char(1) PRIMARY KEY)

	INSERT INTO #bkdrives
	SELECT DISTINCT SUBSTRING(dbsDBFileLocation
						,(CHARINDEX (':\', dbsDBFileLocation, 1)) -2
						,(CHARINDEX (':\', dbsDBFileLocation, 1)))		
	FROM DBServices.dbo.dbsDatabaseBackup
	WHERE dbsDBBackupType <> 'Decommissioned'

	SET @i = CHARINDEX (':\', @dbsInstanceFileLocation, 1)
	IF @i=0
	BEGIN
		SET @msg_body = @msg_body + 'ERROR: dbsInstanceFileLocation LUN not found - backups may fail, investigation required'
		EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2

		GOTO END_IT
	END
	ELSE
	BEGIN 
		SET @CurrLUN = SUBSTRING(@dbsInstanceFileLocation,@i-2,@i)
		IF NOT EXISTS (SELECT drive FROM #bkdrives WHERE drive = @CurrLUN)
			INSERT INTO #bkdrives SELECT @CurrLUN
	END

	SET @i = CHARINDEX (':\', @NB_WorkDirectory, 1)
	IF @i=0
	BEGIN
		SET @msg_body = @msg_body + 'ERROR: NB_WorkDirectory LUN not found - backups may fail, investigation required'
		EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2

		GOTO END_IT
	END	
	ELSE
	BEGIN 
		SET @CurrLUN = SUBSTRING(@NB_WorkDirectory,@i-2,@i)
		IF NOT EXISTS (SELECT drive FROM #bkdrives WHERE drive = @CurrLUN)
			INSERT INTO #bkdrives SELECT @CurrLUN
	END

	-----------------------
	-- Commvault Scheduled backups 

	IF @dbsBackupProcessor = 5
	BEGIN
		PRINT @msg_body + 'Commvault Scheduled backups identified'

		EXEC @RC = [dbo].[usp_CVTLogBakStagingStatus] 
				@CV_SqlLogBackupStageFolder OUTPUT
				,@CV_bTLBackupToFS OUTPUT
				,@CV_backupFromFSForLog OUTPUT
				,@CV_SqlLogBackupInterval OUTPUT

		IF @RC = 0 
		BEGIN 
			SET @CurrLUN = SUBSTRING(@CV_SqlLogBackupStageFolder,@i-2,@i)
			IF NOT EXISTS (SELECT drive FROM #bkdrives WHERE drive = @CurrLUN)
				INSERT INTO #bkdrives SELECT @CurrLUN
		END
		ELSE
			GOTO END_IT
	END
	
	IF NOT EXISTS (SELECT 1
		FROM #bkdrives)
	BEGIN
		SET @msg_body = @msg_body + 'Unhandled exception; failed to obtain a list of backup volumes' 
		
		EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2
		GOTO END_IT
	END
	
	------------------------------------------------------------------------------------------------
	-- Verify if backup LUN affected
		
	SET @alertflag = 0
	SET @msg_body = 'UBSMWE: usp_BackupLUN_Mon: '
		+ CAST(@dbsBackupLUN_SpaceThresholdPerc as varchar(3)) + '% threshold alert:' 
			
	DECLARE dcur CURSOR LOCAL FAST_FORWARD FOR
	SELECT DeviceName
		,Capacity
		,FreeSpace
		,PercFree
		,ThresholdStatus
		FROM [DBServices].[dbo].[dbsVolInfo]
		ORDER BY DeviceName
	OPEN dcur

	FETCH NEXT FROM dcur
		INTO @DeviceName,
			@CapacityMB,
			@FreeSpace,
			@PercFree, 
			@Threshold
	WHILE @@FETCH_STATUS=0 
	BEGIN
		IF EXISTS (SELECT 1 
					FROM #bkdrives
					WHERE drive = LEFT (@DeviceName,1)
						AND @Threshold = '*ALERT*')
		BEGIN
			SET @alertflag = 1 

			SET @msg_body = @msg_body + ' [' + @DeviceName + ']: has '
				+ CAST(@FreeSpace as varchar(20)) + 'MB, '
				+ CAST(@PercFree as varchar(3)) + '% Free' 
		END

		FETCH NEXT FROM dcur
			INTO @DeviceName,
				@CapacityMB,
				@FreeSpace,
				@PercFree, 
				@Threshold 
	END
	CLOSE dcur
	DEALLOCATE dcur 
	-----------------------
	
	IF @alertflag = 1 -- Raise alert
	BEGIN
		SET @str = CAST(CAST(getdate() as smalldatetime) as varchar(20))

		EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsBackupLUN_LastAlertDT', @str

		-- Raise alert with details from above
		EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2

		IF @dbsBackupProcessor =5
		BEGIN
			-- Execute a CV Scheduled TLog 'De-stage' for each supporting Subclient
			EXEC @RC = [DBServices].[dbo].[usp_CVScheduleTlogDeStage]

			IF @RC <> 0
			BEGIN
				SET @msg_body = 'UBSMWE: usp_BackupLUN_Mon: failed to initiate a forced CV Scheduled Tlog backups; thereby stale CV Tlog dumps may not have purged'
				EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 2
			END
		END
		GOTO END_IT
	END
	ELSE
		PRINT 'UBSMWE: usp_BackupLUN_Mon: Backup LUN space ' + CAST(@dbsBackupLUN_SpaceThresholdPerc as varchar(2)) + '% threshold check: OK' 
END
	
-----------------------
END_OK:

--Tidyup 
IF object_id('tempdb..#bkdrives') IS NOT NULL
	DROP TABLE #bkdrives

RETURN 0

-----------------------
END_IT:
--Tidyup 
IF object_id('tempdb..#bkdrives') IS NOT NULL
	DROP TABLE #bkdrives

RETURN 1

END -- end of main

GO
/****** Object:  StoredProcedure [dbo].[usp_BackupReport]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE [dbo].[usp_BackupReport] 
	@fromdate datetime = null,
	@todate datetime = null,
	@databasename nvarchar(128) = null 

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_BackupReport.SQL
// 
// Purpose:
//   Perform Full Backup of all databases
//
// Notes: This stored procedure is run by hand as needed.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 26/08/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Updated for LiteSpeed and LogMark restore function
//   @Date: 20/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1: Updated for Integration with Netbackup
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
//




Input:
	from date;
	to date; (if null then all for that day???)
	database name
Output:
	time of backup;dbo.dbsDatabaseBackupHistory
	date/time sent to tape;dbo.dbsNetbackup
	name of manifest;dbo.dbsNetbackup
	file name;dbo.dbsNetbackup, 
	file size;
	database name;
	backup type;
	backup class?? (possible to add this as a field/fk for backups made?);
	summary of how many files, and total size.





****************************************************************************************/

BEGIN  --Begin main()
--	DECLARE 

IF	@fromdate IS NULL
	BEGIN
		SELECT @fromdate = '2000-01-01'
	END

IF	@todate IS NULL
	BEGIN
		SELECT @todate = GETDATE()
	END


	IF @databasename IS NULL
		BEGIN

			SELECT     	dbsDatabase.dbsDatabaseName,
						dbsDatabaseBackupHistory.dbsDBHStartDate,
						dbsDatabaseBackupHistory.dbsDBHEndDate,
						dbsDatabaseBackupHistory.dbsDBHIsOnDiskFlag,
						dbsDatabaseBackupHistory.dbsDBHIsLogFlag,
						dbsDatabaseBackupHistory.dbsDBHSentToNBFlag,
						dbsDatabaseBackupHistory.dbsDBHFileName,
 						dbsNetbackupManifest.dbsNetbackupID, 
						dbsNetbackup.dbsNetbackupRequestStartDate, 
						dbsNetbackup.dbsNetbackupRequestEndDate,
						dbsNetbackupManifest.dbsNetbackupManifestLocation,  
 						dbsNetbackupStatus.dbsNetbackupClass

			FROM         dbsNetbackup INNER JOIN
								  dbsNetbackupManifest ON dbsNetbackup.dbsNetbackupID = dbsNetbackupManifest.dbsNetbackupID LEFT OUTER JOIN
								  dbsNetbackupStatus ON dbsNetbackup.dbsNetbackupID = dbsNetbackupStatus.dbsNetbackupID RIGHT OUTER JOIN
								  dbsDatabaseBackupHistory INNER JOIN
								  dbsDatabase ON dbsDatabaseBackupHistory.dbsDatabaseUID = dbsDatabase.dbsDatabaseUID ON 
								  dbsNetbackupManifest.dbsDBHID = dbsDatabaseBackupHistory.dbsDBHID
			WHERE     (CONVERT(varchar(30), dbsDatabaseBackupHistory.dbsDBHStartDate, 112) >= CONVERT(varchar(30), @fromdate, 112)) AND (CONVERT(varchar(30), 
								  dbsDatabaseBackupHistory.dbsDBHStartDate, 112) <= CONVERT(varchar(30), @todate, 112))
			ORDER BY dbsDatabaseBackupHistory.dbsDBHStartDate,dbsDatabase.dbsDatabaseName


		END
	ELSE
		BEGIN
			SELECT     	dbsDatabase.dbsDatabaseName,
						dbsDatabaseBackupHistory.dbsDBHStartDate,
						dbsDatabaseBackupHistory.dbsDBHEndDate,
						dbsDatabaseBackupHistory.dbsDBHIsOnDiskFlag,
						dbsDatabaseBackupHistory.dbsDBHIsLogFlag,
						dbsDatabaseBackupHistory.dbsDBHSentToNBFlag,
						dbsDatabaseBackupHistory.dbsDBHFileName,
 						dbsNetbackupManifest.dbsNetbackupID, 
						dbsNetbackup.dbsNetbackupRequestStartDate, 
						dbsNetbackup.dbsNetbackupRequestEndDate,
						dbsNetbackupManifest.dbsNetbackupManifestLocation,  
 						dbsNetbackupStatus.dbsNetbackupClass
			FROM         dbsNetbackup INNER JOIN
								  dbsNetbackupManifest ON dbsNetbackup.dbsNetbackupID = dbsNetbackupManifest.dbsNetbackupID LEFT OUTER JOIN
								  dbsNetbackupStatus ON dbsNetbackup.dbsNetbackupID = dbsNetbackupStatus.dbsNetbackupID RIGHT OUTER JOIN
								  dbsDatabaseBackupHistory INNER JOIN
								  dbsDatabase ON dbsDatabaseBackupHistory.dbsDatabaseUID = dbsDatabase.dbsDatabaseUID ON 
								  dbsNetbackupManifest.dbsDBHID = dbsDatabaseBackupHistory.dbsDBHID
			WHERE     (CONVERT(varchar(30), dbsDatabaseBackupHistory.dbsDBHStartDate, 112) >= CONVERT(varchar(30), @fromdate, 112)) AND (CONVERT(varchar(30), 
								  dbsDatabaseBackupHistory.dbsDBHStartDate, 112) <= CONVERT(varchar(30), @todate, 112))
						AND UPPER(dbsDatabase.dbsDatabaseName) = UPPER(@databasename)
			ORDER BY dbsDatabase.dbsDatabaseName, dbsDatabaseBackupHistory.dbsDBHStartDate
		END

END --End main()




GO
/****** Object:  StoredProcedure [dbo].[usp_ChangeDatabaseRecoveryModel]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_ChangeDatabaseRecoveryModel] @DatabaseName nvarchar(255) = NULL
				,@BackupModel nvarchar(50) = NULL , @Update nvarchar(10) = 'FALSE'

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_ChangeDatabaseRecoveryModel.SQL
// 
// Purpose:
//   Change recovery model of Database and perform Full database backup when changing to Full.
//
// Notes: This stored procedure is to be run by hand by dba.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 06/10/2008 @Author: Kevin Wagner @Version: 2.5.4.1  @Action: Created for bug# 38
//
****************************************************************************************/

BEGIN  --Begin main()
--'FULL', 'BULK_LOGGED', 'SIMPLE'
DECLARE @SQL nvarchar(2000)
		,@job_name nvarchar(2000)
		,@RC int
IF upper(@Update) in ( 'NO', 'FALSE' )
	BEGIN
		IF @DatabaseName IS NOT NULL
			BEGIN
				--PRINT 'NA'
				IF EXISTS (SELECT 1 FROM master..sysdatabases WHERE name = @DatabaseName )
					BEGIN
						SELECT name, DATABASEPROPERTYEX( name , 'Recovery' )
						FROM master..sysdatabases
						WHERE name = @DatabaseName
					END
				ELSE
					BEGIN
						PRINT 'Database ' + @DatabaseName + ' not found.'
						IF 'A' <> 'a'
							BEGIN
								PRINT 'This is a case sensitive instance, please check the spelling.'
							END
					END
			END
		ELSE
			BEGIN
				IF @BackupModel IS NULL OR @BackupModel NOT IN ('FULL', 'BULK_LOGGED', 'SIMPLE')
					BEGIN
						SELECT name, convert(nvarchar(128), DATABASEPROPERTYEX( name , 'Recovery' ) )
						FROM master..sysdatabases
						ORDER BY name
					END
				ELSE
					BEGIN
						SELECT name, convert(nvarchar(128), DATABASEPROPERTYEX( name , 'Recovery' ) )
						FROM master..sysdatabases
						WHERE UPPER(@BackupModel) = UPPER ( CAST ( DATABASEPROPERTYEX ( name , 'Recovery' ) as nvarchar(255) ) )
						ORDER BY name
					END
			END

	END
ELSE
IF upper(@BackupModel) IN ('FULL', 'BULK_LOGGED', 'SIMPLE')
	BEGIN
		IF upper(@Update) in ( 'YES', 'TRUE' )
			BEGIN
				IF EXISTS (SELECT 1 FROM master..sysdatabases )
					BEGIN
						IF (UPPER(@BackupModel) = UPPER ( CAST ( DATABASEPROPERTYEX ( @DatabaseName , 'Recovery' ) as nvarchar(255) ) ))
							BEGIN
								PRINT 'The database ' + @DatabaseName + ' is already set to ' + @BackupModel
							END
						ELSE
							BEGIN
--select UPPER ( CAST ( DATABASEPROPERTYEX ( @DatabaseName , 'Recovery' ) as nvarchar(255) ) )
--								exec master..sp_
								SELECT @SQL = 'USE MASTER ALTER DATABASE [' + @DatabaseName + '] SET RECOVERY ' + @BackupModel + ' WITH NO_WAIT'
								exec master..sp_executesql @SQL
								SELECT @job_name = 'UBSMWE_WFST_BUFull (' + @DatabaseName + ')'
									EXEC @RC = msdb.dbo.sp_start_job @job_name = @job_name
									IF @RC <> 0 
										BEGIN
											PRINT 'Unable to run subtask - ' + @job_name
										END
							END
					END
				ELSE
					BEGIN
						PRINT 'Database ' + @DatabaseName + ' not found.'
						IF 'A' <> 'a'
							BEGIN
								PRINT 'This is a case sensitive instance, please check the spelling.'
							END
					END
					
			END
		ELSE

			BEGIN
				PRINT 'Update section, Unknown option for Update: [' + @Update + '].'
			END


	END
ELSE
	BEGIN
		PRINT 'The BackupModel specified: [' + @BackupModel + '] was not one of the following;'
		PRINT 'FULL, BULK_LOGGED or SIMPLE.'
	END

ENDIT:
END --End main()


GO
/****** Object:  StoredProcedure [dbo].[usp_CheckNetbackupStatus]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_CheckNetbackupStatus] 

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_CheckNetbackupStatus_.SQL
// 
// Purpose:
//   Perform Backup to tape
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase. 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 14/10/2004 @Author: Kevin Wagner @Version: Beta General @Action: Created
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 20/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Netbackup Rerun process change. Will now rerun under same Netbackup Manifest number.//
****************************************************************************************/
SET NOCOUNT ON
BEGIN  --Begin main()
 	DECLARE @dbsNetbackupID BIGINT
 			,@dbsNetbackupRunNumber int
 			--,@dbsNetbackupExitStatus nvarchar(255)

	DECLARE manifest_cur CURSOR
	FOR 	SELECT N.dbsNetbackupID
			,NS.dbsNetbackupRunNumber
			--,N.dbsNetbackupExitStatus 
--SELECT *
		FROM dbo.dbsNetbackup N
		LEFT OUTER JOIN dbo.dbsNetbackupStatus NS
		ON N.dbsNetbackupID = NS.dbsNetbackupID
		WHERE NS.dbsNetbackupStatus IS NULL

--		OR (N.dbsNetbackupExitStatus LIKE '%partially%' AND NS.dbsNetbackupStatus IS NULL)


--select * from dbo.dbsNetbackup
--select * from dbo.dbsNetbackupStatus


	OPEN manifest_cur
	
	FETCH NEXT FROM manifest_cur INTO @dbsNetbackupID , @dbsNetbackupRunNumber--, @dbsNetbackupExitStatus  
	WHILE (@@fetch_status <> -1)
	BEGIN
		IF (@@fetch_status <> -2)
		BEGIN

			EXEC DBServices.dbo.usp_CheckNetbackupStatusDetail @dbsNetbackupID, 1, @dbsNetbackupRunNumber--, @dbsNetbackupExitStatus  --Persist all information to the database
		END
		FETCH NEXT FROM manifest_cur INTO @dbsNetbackupID, @dbsNetbackupRunNumber--, @dbsNetbackupExitStatus 
	END
	
	CLOSE manifest_cur
	DEALLOCATE manifest_cur



END --End main()



GO
/****** Object:  StoredProcedure [dbo].[usp_CheckNetbackupStatusDetail]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_CheckNetbackupStatusDetail]
	 @dbsNetbackupID bigint = NULL
	, @PersistToDBServices bit = 0
	, @dbsNetbackupRunNumber int = NULL
	, @IsRunFromNetbackupJob int = 0
AS

/****************************************************************************************
// @File: usp_CheckNetbackupStatusDetail_.SQL
// 
// @Version: 6.0.0.22
//
// Purpose:
//   Perform Backup to tape
//
// Notes: This stored procedure is called from main UBSMWE usp_CheckNetbackupStatus and can be run by hand if desired. 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 01/10/2006 @Author: Kevin Wagner @Version: 2.0.0 @Action: Fixed issue with Netbackup log date formats.
//   @Date: 08/10/2006 @Author: Kevin Wagner @Version: 2.0.3 @Action: Added functionality to keep history of Netbackup class.
//   @Date: 27/02/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Fixed issue with 30min and 15min deletion alerts.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 05/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Updated for issue# 26
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 20/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Netbackup Rerun process change. Will now rerun under same Netbackup Manifest number.//
//   @Date: 28/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 Tidyup only
//   @Date: 27/01/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.22 @Action: TRR-118
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE 
	@sql1 nvarchar(4000)
	,@NB_Class nvarchar(255)
	,@NB_Enabled bit
	,@CV_Enabled bit
	,@RC int
	,@dbsInstanceFileLocation nvarchar(255)
	,@ActiveComputerName nvarchar(128)
	,@dbsInstanceFileLocation_FIX nvarchar(255) --Fix for $ in path name
	,@dbsNetbackupRequestStartDate datetime
	,@dbsNetbackupRequestEndDate datetime
	,@dbsNetbackupFileListName nvarchar(255)
	,@dbsFSBakLogName nvarchar(255)
	,@dbsNetbackupStatusBackupstartedTime datetime
	,@dbsNetbackupStatusBackupstartedTime_text nvarchar(255)
	,@dbsNetbackupStatusInitiatingbackupTime datetime
	,@dbsNetbackupStatusInitiatingbackupTime_text nvarchar(255)
	,@dbsNetbackupStatusBACKUPSTARTTime datetime
	,@dbsNetbackupStatusBACKUPSTARTTime_text nvarchar(255) 
	,@dbsNetbackupStatusBeginningbackupTime datetime
	,@dbsNetbackupStatusBeginningbackupTime_text nvarchar(255) 
	,@dbsNetbackupTotalSize nvarchar(255)
	,@dbsNetbackupEndTime datetime
	,@dbsNetbackupEndTime_text nvarchar(255)
	,@dbsNetbackupExitStatus nvarchar(255)
	,@dbsNetbackupClass nvarchar(128)
	,@NetbackupErrorLimit int
	,@NetbackupErrorCount int
	,@NetbackupErrorRerunDelay int
	,@SendAlertOnIndividualFilePurgeErrors int
	,@dbsNetbackupStatus nvarchar(255)
	,@sqlError1 nvarchar(1000)
	,@dbsNetbackupRunNumber_MAX int
	,@forcefordebug bit
	,@exists bit

-------------------------------------------
-- Get config

SET @forcefordebug = 0 --change to 1 to debug

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 

SET @sql1 = 'NB_Class_' + @ActiveComputerName
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] @sql1, @NB_Class OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation_FIX OUTPUT
SET @dbsInstanceFileLocation = SUBSTRING(@dbsInstanceFileLocation_FIX, 1, 2)  --Grab out just the first 2 chars of the path = r:\

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorLimit', @NetbackupErrorLimit OUTPUT 
IF @RC <> 0 
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'NetbackupErrorLimit', 3
	SET @NetbackupErrorLimit = 3
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorCount', @NetbackupErrorCount OUTPUT 
IF @RC <> 0 
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'NetbackupErrorCount', 0
	SET @NetbackupErrorCount = 0
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorRerunDelay', @NetbackupErrorRerunDelay OUTPUT 
IF @RC <> 0 
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'NetbackupErrorRerunDelay', 3
	SET @NetbackupErrorRerunDelay = 3
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'SendAlertOnIndividualFilePurgeErrors', @SendAlertOnIndividualFilePurgeErrors OUTPUT 
IF @RC <> 0 
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'SendAlertOnIndividualFilePurgeErrors', 0
	SET @SendAlertOnIndividualFilePurgeErrors = 0 
END

--If the Netbackup ID is empty, just report on the last Netbackup run.
IF @dbsNetbackupID IS NULL 
	AND @IsRunFromNetbackupJob = 0
BEGIN
	SELECT @dbsNetbackupID = MAX([dbsNetbackupID])
	FROM [DBServices].[dbo].[dbsNetbackup]
END
	
IF @dbsNetbackupID IS NULL 
	AND @IsRunFromNetbackupJob = 1
	RETURN 0 -- Return Success

-------------------------------------------
--Seed the values for this run of the Netbackup log parsing. 
--If both are null then first run, if both are = then this is a continuation 
--of first run, if they are not = then this is subsequent run, used for future 
--feature enhancement.

SELECT @dbsNetbackupRunNumber_MAX = MAX(dbsNetbackupRunNumber)
FROM DBServices.dbo.dbsNetbackupStatus
WHERE dbsNetbackupID = @dbsNetbackupID

--SEED the variables with current information from the log table, only want to update table if it is null or has changed in the log.

SELECT  @dbsNetbackupStatusBackupstartedTime = [dbsNetbackupStatusBackupstartedTime]
	, @dbsNetbackupStatusInitiatingbackupTime = [dbsNetbackupStatusInitiatingbackupTime]
	, @dbsNetbackupStatusBACKUPSTARTTime = [dbsNetbackupStatusBACKUPSTARTTime]
	, @dbsNetbackupStatusBeginningbackupTime = [dbsNetbackupStatusBeginningbackupTime]
	, @dbsNetbackupTotalSize = [dbsNetbackupTotalSize]
	, @dbsNetbackupEndTime = [dbsNetbackupEndTime]
	, @dbsNetbackupStatus = [dbsNetbackupStatus] 
	, @dbsNetbackupClass = [dbsNetbackupClass]
	
FROM [DBServices].[dbo].[dbsNetbackupStatus]
WHERE dbsNetbackupRunNumber = @dbsNetbackupRunNumber
	AND dbsNetbackupID = @dbsNetbackupID

---------------------
--Get the Netbackup log name for this run of Netbackup

SELECT @dbsFSBakLogName = ns.dbsNetbackupLogName
	,@dbsNetbackupFileListName = ns.dbsNetbackupFileListName
	,@dbsNetbackupRequestStartDate = n.dbsNetbackupRequestStartDate
	,@dbsNetbackupRequestEndDate = n.dbsNetbackupRequestEndDate
	,@dbsNetbackupExitStatus = n.dbsNetbackupExitStatus
	
FROM dbo.dbsNetbackup n
INNER JOIN dbo.dbsNetbackupStatus ns
	ON n.dbsNetbackupID = ns.dbsNetbackupID
WHERE ns.dbsNetbackupID = @dbsNetbackupID
	AND ns.dbsNetbackupRunNumber = @dbsNetbackupRunNumber

-------------------------------------------

EXEC @RC = [DBServices].[dbo].[usp_FileExists] @dbsFSBakLogName, @exists OUTPUT
IF @exists = 0
BEGIN
	PRINT 'UBSW: usp_CheckNetbackupStatusDetail: ERROR: Log file not found: ' + @dbsFSBakLogName 
	RETURN 1 -- fail
END
-- else continue

CREATE TABLE #NBLog (NBText nvarchar(4000))
CREATE TABLE #NBFileList (NBText nvarchar(4000))

SET @sql1 = 'TYPE ' + @dbsFSBakLogName

INSERT INTO #NBLog
EXEC master.dbo.xp_cmdshell @sql1

IF @forcefordebug = 1
	SELECT *
	FROM #NBLog

-------------------------------------------
IF @dbsNetbackupStatusBackupstartedTime IS NULL
	OR @forcefordebug = 1
BEGIN
	SELECT @dbsNetbackupStatusBackupstartedTime_text = SUBSTRING(NBText, 16, 19)
	FROM #NBLog
	WHERE UPPER(NBText) LIKE 'BACKUP STARTED%' 

	IF @forcefordebug = 1
		SELECT '@dbsNetbackupStatusBackupstartedTime_text:' 
			+ ISNULL(@dbsNetbackupStatusBackupstartedTime_text, 'dbsNetbackupStatusBackupstartedTime_text is NULL' )
			
	IF ISDATE (@dbsNetbackupStatusBackupstartedTime_text) = 1
		SET @dbsNetbackupStatusBackupstartedTime = @dbsNetbackupStatusBackupstartedTime_text
	ELSE
	IF @dbsNetbackupStatusBackupstartedTime_text IS NOT NULL
			SELECT @dbsNetbackupStatusBackupstartedTime = getdate()
END

-------------------------------------------
IF @dbsNetbackupStatusInitiatingbackupTime IS NULL
	OR @forcefordebug = 1
BEGIN
	SELECT @dbsNetbackupStatusInitiatingbackupTime_text = SUBSTRING(NBText, 1, 8)
	FROM #NBLog
	WHERE UPPER(SUBSTRING(NBText, 10, 17)) = 'INITIATING BACKUP'

	IF @forcefordebug = 1
		SELECT '@dbsNetbackupStatusInitiatingbackupTime_text:'
			+ ISNULL(@dbsNetbackupStatusInitiatingbackupTime_text, '@dbsNetbackupStatusInitiatingbackupTime_text is null')

	IF ISDATE (@dbsNetbackupStatusInitiatingbackupTime_text) = 1
		SET @dbsNetbackupStatusInitiatingbackupTime = @dbsNetbackupStatusInitiatingbackupTime_text
	ELSE
	IF @dbsNetbackupStatusInitiatingbackupTime_text IS NOT NULL
		SET @dbsNetbackupStatusInitiatingbackupTime = getdate()
END

-------------------------------------------
IF @dbsNetbackupStatusBACKUPSTARTTime IS NULL 
	OR @forcefordebug = 1
BEGIN
	SELECT @dbsNetbackupStatusBACKUPSTARTTime_text = SUBSTRING(NBText, 1, 8)
	FROM #NBLog
	WHERE UPPER(SUBSTRING(NBText, 10, 18)) = 'INF - BACKUP START'

	IF @forcefordebug = 1 
		SELECT '@dbsNetbackupStatusBACKUPSTARTTime_text:' 
			+ ISNULL(@dbsNetbackupStatusBACKUPSTARTTime_text, '@dbsNetbackupStatusBACKUPSTARTTime_text is null')
				
	IF ISDATE (@dbsNetbackupStatusBACKUPSTARTTime_text) = 1
		SET @dbsNetbackupStatusBACKUPSTARTTime = @dbsNetbackupStatusBACKUPSTARTTime_text
	ELSE
	IF @dbsNetbackupStatusBACKUPSTARTTime_text IS NOT NULL
		SET @dbsNetbackupStatusBACKUPSTARTTime = getdate()
END

-------------------------------------------
IF @dbsNetbackupStatusBeginningbackupTime IS NULL
	OR @forcefordebug = 1
BEGIN
	SELECT @dbsNetbackupStatusBeginningbackupTime_text = SUBSTRING(NBText, 1, 8)
	FROM #NBLog
	WHERE UPPER(SUBSTRING(NBText, 10, 32)) = 'INF - BEGINNING BACKUP ON SERVER'
	
	IF @forcefordebug = 1
		SELECT '@dbsNetbackupStatusBeginningbackupTime_text:'
			+ ISNULL(@dbsNetbackupStatusBeginningbackupTime_text, '@dbsNetbackupStatusBeginningbackupTime_text is null')

	IF ISDATE (@dbsNetbackupStatusBeginningbackupTime_text) = 1
		SET @dbsNetbackupStatusBeginningbackupTime = @dbsNetbackupStatusBeginningbackupTime_text
	ELSE
	IF @dbsNetbackupStatusBeginningbackupTime_text IS NOT NULL
		SET @dbsNetbackupStatusBeginningbackupTime = getdate()
END

-------------------------------------------
IF @dbsNetbackupTotalSize IS NULL
	OR @forcefordebug = 1
BEGIN
	SELECT @dbsNetbackupTotalSize = NBText
	FROM #NBLog
	WHERE UPPER(SUBSTRING(NBText, 10, 17)) = 'INF - TOTAL SIZE:'
END

IF @forcefordebug = 1 
	SELECT '@dbsNetbackupTotalSize:' + ISNULL(@dbsNetbackupTotalSize, '@dbsNetbackupTotalSize is null')

-------------------------------------------
IF @dbsNetbackupStatus IS NULL 
	OR @forcefordebug = 1
BEGIN
	SELECT @dbsNetbackupStatus = [DBServices].[dbo].[ParseStringWithDelim](NBText, ':')
	FROM #NBLog
	WHERE UPPER(SUBSTRING(NBText, 10, 15)) = 'INF - BACKUP BY'
		AND UPPER(NBText) LIKE '%ON CLIENT%' 
		AND UPPER(NBText) LIKE '%USING POLICY%' 
END	

IF @forcefordebug = 1 
	SELECT '@dbsNetbackupStatus:' + ISNULL(@dbsNetbackupStatus, '@dbsNetbackupStatus is null')

-------------------------------------------
IF @dbsNetbackupEndTime IS NULL
	OR @forcefordebug = 1 
BEGIN
	SELECT @dbsNetbackupEndTime_text = SUBSTRING(NBText, 1, 8)
	FROM #NBLog
	WHERE UPPER(SUBSTRING(NBText, 10, 15)) = 'INF - BACKUP BY'
		AND UPPER(NBText) LIKE '%ON CLIENT%' 
		AND UPPER(NBText) LIKE '%USING POLICY%' 

	IF @forcefordebug = 1 
		 SELECT '@dbsNetbackupEndTime_text:' + ISNULL(@dbsNetbackupEndTime_text, '@dbsNetbackupEndTime_text is NULL')

	IF ISDATE (@dbsNetbackupEndTime_text) = 1
		SET @dbsNetbackupEndTime = @dbsNetbackupEndTime_text
	ELSE
	IF @dbsNetbackupEndTime_text IS NOT NULL
		SET @dbsNetbackupEndTime = getdate()
END	

-------------------------------------------
--FIX FOR Log spacing position issues...
IF @dbsNetbackupClass IS NULL
	SET @dbsNetbackupClass = @NB_Class

--Until we are allowed to pull storage policy from CV again, using generic name.	
IF @CV_Enabled = 1
	SET @dbsNetbackupClass = 'CommVault'

SET @RC = 0
-------------------------------------------
IF @PersistToDBServices = 0 
BEGIN
	SELECT *
	FROM [DBServices].[dbo].[dbsNetbackupStatus]
	WHERE [dbsNetbackupRunNumber]= @dbsNetbackupRunNumber
		AND	[dbsNetbackupID]= @dbsNetbackupID
END ------------------------------------------
ELSE
BEGIN
	IF UPPER(@dbsNetbackupStatus) LIKE '%THE REQUESTED OPERATION WAS PARTIALLY SUCCESSFUL%'
	BEGIN
		UPDATE dbo.dbsNetbackupManifest
		SET dbo.dbsNetbackupManifest.IsSuccess = 1
			, IsSuccessRunNumber = ISNULL(@dbsNetbackupRunNumber, IsSuccessRunNumber)
		WHERE dbo.dbsNetbackupManifest.dbsDBHID IN (
				SELECT dbsDBHID
				FROM dbsDatabaseBackupHistory
				INNER JOIN #NBLog 
					ON UPPER(dbsDatabaseBackupHistory.dbsDBHFileName) = UPPER(SUBSTRING(NBText, 16, (LEN(NBText) - 15)))
				WHERE dbsDatabaseBackupHistory.dbsDBHIsOnDiskFlag = 1 
					AND dbsDatabaseBackupHistory.dbsDBHSentToNBFlag = 1	
				)
			AND dbo.dbsNetbackupManifest.dbsNetbackupID = @dbsNetbackupID
	
		SET @RC = 0
	END ---------------------
	ELSE
	IF UPPER(@dbsNetbackupStatus) LIKE '%THE REQUESTED OPERATION WAS SUCCESSFULLY COMPLETED%'
	BEGIN
		UPDATE dbo.dbsNetbackupManifest
		SET dbo.dbsNetbackupManifest.IsSuccess = 1
		WHERE dbo.dbsNetbackupManifest.IsSuccessRunNumber = @dbsNetbackupRunNumber
			AND dbo.dbsNetbackupManifest.dbsNetbackupID = @dbsNetbackupID

		SET @RC = 0
	END ---------------------
	ELSE
	IF @IsRunFromNetbackupJob = 0 
		AND ISNULL(@dbsNetbackupStatus,'') = ''
	BEGIN
		--If we still have a null, check for the exit status from the job that was placed in the log file. 
		--This will help in cases where the server does not provide feedback in the log.

		SELECT @dbsNetbackupStatus = 'FORCED FAILED: ' 
			+ ISNULL(SUBSTRING(NBText, LEN('NETBACKUP JOB ENDED WITH EXIT STATUS:') +1 , LEN(NBText)), ' No valid exit status from Netbackup job.')
		FROM #NBLog
		WHERE UPPER(NBText) LIKE 'NETBACKUP JOB ENDED WITH EXIT STATUS:%'

		SET @RC = 1
	END	 ---------------------
	ELSE 
	IF @IsRunFromNetbackupJob = 0
		AND @dbsNetbackupRunNumber_MAX > @dbsNetbackupRunNumber
	BEGIN
		SELECT @dbsNetbackupStatus = 'FORCED FAILED: ' 
			+ ISNULL(SUBSTRING(NBText, LEN('NETBACKUP JOB ENDED WITH EXIT STATUS:') +1 , LEN(NBText)), ' No valid exit status from Netbackup job.')
		FROM #NBLog
		WHERE UPPER(NBText) LIKE 'NETBACKUP JOB ENDED WITH EXIT STATUS:%'
	
		SET @RC = 1
	END	 ---------------------
	ELSE
	IF @IsRunFromNetbackupJob = 1 
		AND @dbsNetbackupRunNumber_MAX = @dbsNetbackupRunNumber
	BEGIN
		SELECT @dbsNetbackupStatus = 'FORCED FAILED: '
			+ ISNULL(SUBSTRING(NBText, LEN('NETBACKUP JOB ENDED WITH EXIT STATUS:') +1 , LEN(NBText)), ' No valid exit status from Netbackup job.')
		FROM #NBLog
		WHERE UPPER(NBText) LIKE 'NETBACKUP JOB ENDED WITH EXIT STATUS:%'

		SET @RC = 1
	END	---------------------

	UPDATE [DBServices].[dbo].[dbsNetbackupStatus]
	SET 	 [dbsNetbackupStatusBackupstartedTime] = @dbsNetbackupStatusBackupstartedTime
			, [dbsNetbackupStatusInitiatingbackupTime] = @dbsNetbackupStatusInitiatingbackupTime
			, [dbsNetbackupStatusBACKUPSTARTTime] = @dbsNetbackupStatusBACKUPSTARTTime
			, [dbsNetbackupStatusBeginningbackupTime] = @dbsNetbackupStatusBeginningbackupTime
			, [dbsNetbackupTotalSize] = @dbsNetbackupTotalSize
			, [dbsNetbackupEndTime] = @dbsNetbackupEndTime
			, [dbsNetbackupStatus] = @dbsNetbackupStatus
			, [dbsNetbackupClass] = @dbsNetbackupClass
	WHERE 	[dbsNetbackupRunNumber]= @dbsNetbackupRunNumber
		AND	[dbsNetbackupID]= @dbsNetbackupID

	---------------------
	
	IF DATEDIFF(minute, @dbsNetbackupRequestStartDate , getdate()) BETWEEN 15 AND 16
		AND @dbsNetbackupStatusBACKUPSTARTTime IS NULL
	BEGIN
	 	--Needed to put in some error information into the NT event log 
		--Error in usp_CheckNetbackupStatus, "Netbackup has not started for 15 minutes on server ServerName".  Please chat on #DBServices_msql with this error. 

		SELECT @sqlError1 = 'Error in usp_CheckNetbackupStatus, "Netbackup has not started for 15 minutes on server '
			 +  @ActiveComputerName   + ' for manifest ' + CONVERT (nvarchar(10), @dbsNetbackupID) 
			+ ' ".  Please chat on #DBServices_msql with this error.'
		EXEC [DBServices].[dbo].[usp_UpdatedbsUBSMWEHeartbeat] @sqlError1, 2
	END ---------------------
	ELSE
	IF DATEDIFF(minute, @dbsNetbackupRequestStartDate , getdate()) BETWEEN 30 AND 31
		AND @dbsNetbackupStatusBACKUPSTARTTime IS NULL
	BEGIN
		SELECT @sqlError1 = 'Error in usp_CheckNetbackupStatus, "Netbackup has not started for 30 minutes on server  '
			 +  @ActiveComputerName   + 'for manifest ' + CONVERT (nvarchar(10), @dbsNetbackupID)
			 + ' ".  Please chat on #DBServices_msql with this error.'
		EXEC [DBServices].[dbo].[usp_UpdatedbsUBSMWEHeartbeat] @sqlError1, 3
	END 
END		

IF OBJECT_ID('tempdb..#NBLog') IS NOT NULL     
	DROP TABLE #NBLog

IF OBJECT_ID('tempdb..#NBFileList') IS NOT NULL  
	DROP TABLE #NBFileList

RETURN @RC

------------------------------------------
ENDIT:

IF OBJECT_ID('tempdb..#NBLog') IS NOT NULL     
	DROP TABLE #NBLog

IF OBJECT_ID('tempdb..#NBFileList') IS NOT NULL  
	DROP TABLE #NBFileList
	
PRINT 'UBSMWE: usp_CheckNetbackupStatusDetail: ERROR with manifest ID = ' + CONVERT(varchar(11), @dbsNetbackupID)

RETURN 1 -- Failure

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ChkStaleFileDumps]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ChkStaleFileDumps] (@deviationhrs tinyint = 1)
AS

BEGIN  -- Main

/****************************************************************************************
// @File: usp_ChkStaleFileDumps.SQL
// 
// Purpose:
//   Alert if MWE lists DB FS dump files older than dbsRetainBackupFileDurationHrs
//
// Notes: 
//
// History: Dates are in mm/dd/yyyy format
//
//	 @Date: 09/07/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 Beta 
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//   
****************************************************************************************/

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC tinyint
	,@ErrorMsg nvarchar(255)
	,@dbsRetainBackupFileDurationHrs  nvarchar(128)
	,@StaleFileDumpCnt int

EXEC @RC = dbo.usp_GetdbsInstanceConfig 'dbsRetainBackupFileDurationHrs', @dbsRetainBackupFileDurationHrs

IF @RC = 0
BEGIN
	SELECT TOP 1 @StaleFileDumpCnt = COUNT(dbh.dbsDBHEndDate)
	FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbh WITH (NOLOCK)
	WHERE (dbh.dbsDBHSentToNBFlag = 0 OR dbh.dbsDBHSentToNBFlag IS NULL)
		AND dbh.dbsDBHIsOnDiskFlag = 1  
		AND dbh.dbsDBHEndDate < DATEADD(hh,-(CAST(@dbsRetainBackupFileDurationHrs AS int) + @deviationhrs),getdate()) 

	IF @StaleFileDumpCnt > 0
	BEGIN
		-- Raise an alert
		SET @ErrorMsg = 'UBSMWE Alert: usp_ChkStaleFileDumps: ' + @StaleFileDumpCnt + ' SQL dump files older than the threshold ' 
			+ @dbsRetainBackupFileDurationHrs + @deviationhrs + 'hrs still reside locally on ' 
			+ CONVERT(sysname, SERVERPROPERTY('ServerName')) + ' - Investigation required'

		PRINT @ErrorMsg
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2

		RETURN 1 -- fail
	END
	ELSE -- OK
		RETURN 0
END
ELSE -- error
	RETURN 1

END -- Main

GO
/****** Object:  StoredProcedure [dbo].[usp_chktbllock]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_chktbllock] (@DBName as nvarchar(128) , @tbl as nvarchar(128))
AS 
/****************************************************************************************
// @File: usp_chktbllock.SQL
//
// @Version 6.0.0.29
//
// Purpose:
//   Checks and waits upto 15 secs for table locking 
//
// Notes: This stored procedure is called by other stored procedures 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 14/07/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 02/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 16/03/2015 @Author: Chris Basson @Version: 6.0.0.27 @Action: Bugfix TRR-128
//   @Date: 20/03/2015 @Author: Chris Basson @Version: 6.0.0.28 @Action: Bugfix TRR-128 refined
****************************************************************************************/

BEGIN --main

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @islocked bit
	,@LockedTableRetryAttempts tinyint
	,@ErrorMsg nvarchar(256)
	,@MaxRetries tinyint
	,@DBID int

SET @islocked = 0
SET @LockedTableRetryAttempts = 1
SET @MaxRetries = 5
SET @DBID = DB_ID(@DBName)

IF @DBID IS NOT NULL
	AND ISNULL(@tbl, '') <> ''
BEGIN
	WHILE @LockedTableRetryAttempts <= @MaxRetries  
	BEGIN

		BEGIN TRY
			SELECT TOP 1 @islocked = 1 
			FROM sys.dm_tran_locks tl
			WHERE tl.resource_type = 'OBJECT'
				AND tl.resource_database_id = @DBID
				AND tl.resource_associated_entity_id <= 2147483647 -- TRR-128 workaround
				AND tl.resource_associated_entity_id IS NOT NULL
				AND CHARINDEX(LOWER(@tbl), LOWER(ISNULL(OBJECT_NAME(CAST(tl.resource_associated_entity_id as int), @DBID), 'null')) ) > 0
			OPTION (MAXDOP 1, FAST 200)	
		END TRY

		BEGIN CATCH
			-- Class failure as a lock
			SET @islocked = 1
		END CATCH
		
		IF @islocked = 1
		BEGIN
			SET @ErrorMsg = N'Table lock on ' + @tbl 
				+ ' detected. Trying to handle... (attempt '
				+ CAST(@LockedTableRetryAttempts as varchar(3)) 
				+ '/' + CAST(@MaxRetries as varchar(3))+')'

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info 

			WAITFOR DELAY '00:00:03' -- wait 3 seconds
			SET @LockedTableRetryAttempts = @LockedTableRetryAttempts + 1
		END
		ELSE 
			BREAK -- OK

	END
END -------------------
ELSE
BEGIN
	SET @ErrorMsg = N'UBSMWE: usp_chktbllock: input parameters invalid'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	RETURN 1 
END

-------------------

IF @islocked = 1
BEGIN
	SET @ErrorMsg = N'UBSMWE: usp_chktbllock: Table ' + @DBName + '..' +  @tbl + ' has been locked for over 15 seconds!'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	RETURN 1
END
ELSE
	RETURN 0 -- OK

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_ConfigureCVbackup]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ConfigureCVbackup] 
		@CV_Enabled bit
		,@CV_WindowStartTime char(5) = 'NA'
		,@CV_WindowEndTime char(5) = 'NA'
		,@CV_CommCell nvarchar(255) = 'NA'
		,@CV_RET char(3) = NULL
		,@CV_NodeOneName nvarchar(255) = 'NA'
		,@CV_NodeOneClass nvarchar(255) = 'NA'
		,@CV_NodeTwoName nvarchar(255) = 'NA'
		,@CV_NodeTwoClass nvarchar(255) = 'NA'
		,@CV_NodeThreeName nvarchar(255) = 'NA'
		,@CV_NodeThreeClass nvarchar(255) = 'NA'

AS
/****************************************************************************************
// @File: usp_ConfigureCVbackup.SQL
//
// @Version 6.0.0.33
//
// Purpose:
//   Populate dbsInstanceConfig with CommVault information and turn on/off CommVault.
//
// Notes: This stored procedure is mostly only used during initial install but can be rerun to change existing configuration.
//
// History: Dates are in dd/mm/yyyy format
//
//   @Date: 05/10/2012 @Author: Steve Trogub @Version: 4.2.0 @Action: Created
//   @Date: 05/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 05/11/2014 @Author: Chris Basson @Version: 6.0.0.33 @Action: Bugfix TRRv3 @CV_Enabled
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE	
	@RC int
	,@dbsInstanceFileLocation nvarchar(255)
	,@astr nvarchar(1000)
	,@CVRET nvarchar(8)
	,@CVTRRurl nvarchar(64)
	,@ActiveComputerName nvarchar(32)
	,@CVInstance nvarchar(64)
	,@CVClient nvarchar(64)
	,@clu nvarchar(30)
	,@dbsBackupProcessor tinyint

---------------------------------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT

IF @dbsBackupProcessor NOT IN (4,5)
BEGIN
	PRINT 'Please note usp_ConfigureCVbackup is only applicable for TRR (CommVault) configurations: dbsBackupProcessor = ' + CAST(@dbsBackupProcessor as char(1))
	RETURN 1
END

IF @CV_Enabled IS NULL
BEGIN
	PRINT 'UBSMWE: usp_ConfigureCVbackup prerequisite: Please specify a value for @CV_Enabled'
	RETURN 1
END

---------------------------------------------
IF @CV_Enabled = 1
	AND @dbsBackupProcessor = 4
BEGIN
	-- Build CV FS backup registration BAS cmd

	IF @CV_RET IS NOT NULL
		AND @CV_RET NOT IN ('XXS', 'XSS', 'SSS', 'XXL', 'XSL', 'SSL', 'XLL', 'SLL', 'LLL', 'AUT') 
	BEGIN
		PRINT 'An invalid data retention code: ' + @CV_RET + ' has been specified (options:'
			+ 'XXS, XSS, SSS, XXL, XSL, SSL, XLL, SLL, LLL, AUT)' 
		GOTO handle_error
	END
	ELSE
	BEGIN
		SET @CVRET='&ret=' + @CV_RET

		IF @CV_RET = 'AUT'
			SET @CVRET=''
	END

	--Get TRR info
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVTRRurl', @CVTRRurl OUTPUT
	SET @CVTRRurl = LTRIM(RTRIM(@CVTRRurl))

	IF CAST(SERVERPROPERTY('IsClustered') as bit) = 1
	BEGIN
		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsIsInstanceClusteredFlag', 1
		EXEC [DBServices].[dbo].usp_UpdateActiveServerName
	END

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT

	-- get host details
	EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
	SET @clu = '&clu=' + @CVClient
	PRINT 'Instance: ' + @CVInstance
	PRINT 'Client: ' + @CVClient 
			
	SET @astr = @CVTRRurl + '/SqlAddFsBackupSet?inst=' + LOWER(@CVInstance) + @clu + @CVRET 				
	PRINT @astr
	
	-- EXEC BAS reg cmd
	EXEC usp_wget @astr

    --http interface takes time so need to wait for commands to propagate
    WAITFOR DELAY '00:00:30'

END ---------------------------------------------
ELSE
IF @dbsBackupProcessor = 5
BEGIN 
	PRINT 'Please note: TRR v3 CommVault FileSystem backup registration is now performed via SNow'
	PRINT ' => only local CV UBSMWE parameters may be set with usp_ConfigureCVbackup'
END

---------------------------------------------
-- Set given UBSME CV Config options

-- Ensure the CV FS folder exists

--Get the currently configured backup drive and append the CVbackup directory
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

IF @RC = 0
BEGIN
	SET @astr = 'if not exist ' + @dbsInstanceFileLocation + '\CVbackup' 
		+ ' md ' + @dbsInstanceFileLocation + '\CVbackup'
	EXEC master..xp_cmdshell @astr
END
ELSE
BEGIN
	PRINT 'UBSMWE: usp_ConfigureCVbackup: Unhandled exception - Unable to determine dbsInstanceFileLocation'
	GOTO handle_error
END

----------------------

EXEC [DBServices].[dbo].usp_ConfigureUBSMWE 'CV_Enabled', @CV_Enabled
EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'NB_Enabled', @CV_Enabled -- quiet

----------------------

IF  @CV_CommCell <> 'NA'
BEGIN
	IF @CV_NodeOneName = 'NA' 
		SET @CV_NodeOneName = 'auto_storage_policy'
	
	EXEC [DBServices].[dbo].usp_ConfigureUBSMWE 'CVFQDNCommCell', @CV_CommCell
END

----------------------

IF @CV_NodeOneName <> 'NA'
BEGIN
    SET @astr = 'CV_Class_' + UPPER(@CV_NodeOneName)
    EXEC [DBServices].[dbo].usp_ConfigureUBSMWE @astr, @CV_NodeOneClass
END

----------------------

IF @CV_NodeTwoName <> 'NA'
BEGIN
    SELECT @astr = 'CV_Class_' + @CV_NodeTwoName
    EXEC [DBServices].[dbo].usp_ConfigureUBSMWE @astr, @CV_NodeTwoClass
END

----------------------

IF @CV_NodeThreeName <> 'NA'
BEGIN
    SELECT @astr = 'CV_Class_' + @CV_NodeThreeName
    EXEC [DBServices].[dbo].usp_ConfigureUBSMWE @astr, @CV_NodeThreeClass
END

----------------------

IF @CV_WindowStartTime <> 'NA'
    EXEC [DBServices].[dbo].usp_ConfigureUBSMWE 'NB_WindowStartTime', @CV_WindowStartTime

IF @CV_WindowEndTime <> 'NA'
    EXEC [DBServices].[dbo].usp_ConfigureUBSMWE 'NB_WindowEndTime', @CV_WindowEndTime

----------------------

SELECT CAST(dbsInstanceConfigName as varchar(40)) as 'dbsInstanceConfigName', dbsInstanceConfigValue 
FROM [DBServices].[dbo].dbsInstanceConfig 
WHERE dbsInstanceConfigName LIKE 'CV%'

RETURN 0

---------------------------------------------
handle_error:

RETURN 1

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ConfigureCVSubclients]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ConfigureCVSubclients] 	
						 @DBName nvarchar(128) = NULL
						,@dbsConfigType nvarchar(20) = NULL
						,@dbsOperation nvarchar(6) = NULL
						,@dbsRet char(3) = NULL
						,@dbsStreams char(1) = NULL
						--,@dbsSystemOnly bit = NULL -- not in use
						,@dbsSubclientGroupDistributionMode tinyint = NULL --0=Size, 1=Add to s.client with least DB's ,2=Named Group
						,@SkipCVList bit = 0
AS

/****************************************************************************************
// @File: usp_ConfigureCVSubclients.SQL
// @Version: 6.0.0.17
// 
// Purpose:
//   Create Subclients for CommVault Configured instance
//
// Notes: This stored procedure can not be rerun to change existing Subclient configuration. 
//
// History: Dates are in mm/dd/yyyy format
//
//  @Date: 06/05/2013 @Author: Steve Trogub @Version: 5.0.5 @Action: Inception.
//  @Date: 06/15/2013 @Author: Steve Trogub @Version: 5.0.5 @Action: support for Multi Database Subclients
//  @Date: 06/24/2013 @Author: Steve Trogub @Version: 5.0.5 @Action: add MOVE between Subclients
//  @Date: 09/11/2013 @Author: Steve Trogub @Version: 5.0.6 @Action: add support for new BAS cluster &clu paramter for all commands
//  @Date: 10/02/2014 @Author: Andrew Calvett @Version 5.0.10 @Action: Added support for GROUP(s)
//  @Date: 11/06/2014 @Author: Chris Basson @Version 5.0.11 @Action: Minor updates
//	@Date: 12/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//	@Date: 19/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.3 @Action: TRRv3 Beta
//	@Date: 02/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.5 @Action: TRRv3 Beta
//	@Date: 09/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.6 @Action: TRRv3 Beta
//	@Date: 31/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta
//	@Date: 12/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 bugfix
//	@Date: 05/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.14 @Action: TRRv3 review
//	@Date: 16/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.17 @Action: TRRv3 bugfix
//
// --new retention codes to be implemented
// XXS, XSS, SSS, XXL, XSL, SSL, XLL, SLL, LLL (Daily/Weekly/Monthly, X=none/S=STR/L=LTR).
// SqlMoveDatabase?inst=NLDN3051NAP&db=Ginger&dbtype=SIMPLE&streams=2&ret=STR
****************************************************************************************/

BEGIN  --Begin main()

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE
	@ActiveComputerName nvarchar(255)
	,@AgentJobID binary(16)
	,@clu nvarchar(64)
	,@count int 
	,@CV_REGISTERED bit
	,@CVClient nvarchar(40)
	,@CVFQDNCommCell nvarchar(100)
	,@CVInstance nvarchar(40)
	,@CV_Parallel_Ops bit
	,@CVRET nvarchar(8)
	,@CVSubClient nvarchar(255)
	,@CVTRRurl nvarchar(256)
	,@DBBackupType nvarchar(14)
	,@DefaultWaitDelay char(8)
	,@fail int
	,@isMirrored bit
	,@isActive bit
	,@message nvarchar(255)
	,@mirrorRole smallint
	,@RC int
	,@response nvarchar(max)
	,@return_value int
	,@searchCmd nvarchar(max)
	,@SQL nvarchar(max)
	,@WFCommand varchar(max)
	,@CV_SubclientGroupingType tinyint
	,@dbsConfigTypeGroupIn nvarchar(20)
	,@dbsConfigTypeGroupOut nvarchar(20)
	,@dbsBackupProcessor tinyint
	,@isLog char(1)
	,@DB_Name varchar(128)
	,@RecoveryType nvarchar(20) 
	,@Command nvarchar(255)
	,@dbsSubclientName nvarchar(255)
	,@dbsDatabaseUID uniqueidentifier
----------------------------------------------------------------
-- Init Vars
                                        
SET @DefaultWaitDelay = '00:00:30'
SET @count = 0
SET @fail=0
SET @dbsOperation = UPPER(LTRIM(RTRIM(@dbsOperation))) 
SET @dbsConfigType = UPPER(LTRIM(RTRIM(@dbsConfigType))) 
SET @dbsRet = UPPER(@dbsRet) 

IF ISNULL(@dbsStreams,'') = ''
	OR ISNUMERIC (@dbsStreams) = 0
	SET @dbsStreams = '2' -- default to 2 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor',  @dbsBackupProcessor OUTPUT

IF @dbsBackupProcessor <> 4
BEGIN
	PRINT @DBName + ': usp_ConfigureCVSubclients is only supported for client side SQL iDA scheduled backups (ie. TRRv2, dbsBackupProcessor = 4).'
		+ char(13) + 'Commvault Scheduled backups (TRRv3): Subclient configuration amendments may be requested via a Backups Services SNow ticket.'
		
	RETURN 1 -- quit with failure
END

------------------------------	
--check if cv_cmdshell exists
IF NOT EXISTS (SELECT 1 FROM [DBServices].[sys].[objects] WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @message = '[DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1 '
	GOTO handle_error
END

------------------------------	
IF @dbsOperation NOT IN ('MOVE','ADD') 
BEGIN
	PRINT 'You must specify valid @dbsOperation parameter < ADD | MOVE >'
	RETURN 1
END

IF @dbsOperation = 'ADD' 
BEGIN
	SET @CVSubClient = DBServices.dbo.ufn_CV_SubclientforDB(@DBName)
	IF @CVSubClient <> 'Subclient_not_found'	
	BEGIN
		PRINT 'A database can only be a member of one Subclient; ' 
			+ @DBName + ' is already a member of: ' + @CVSubClient 
			+ '. Use @dbsOperation=''MOVE'' if you wish to move the DB to a ' + @dbsConfigType + ' type Subclient'
		RETURN 1
	END
END

IF LEFT(@dbsConfigType,5) = 'GROUP'
	AND @dbsSubclientGroupDistributionMode = NULL
BEGIN
	PRINT 'Please specify @dbsSubclientGroupDistributionMode (0=Size, 1=Add to group with the least DBs, 2= Named Group) for GROUP type Subclients'
	RETURN 1
END

----------------------------------------------------------------
--load configuration values

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Parallel_Ops', @CV_Parallel_Ops OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVTRRurl', @CVTRRurl OUTPUT	
SET @CVTRRurl=LTRIM(RTRIM(@CVTRRurl))

--XXS, XSS, SSS, XXL, XSL, SSL, XLL, SLL, LLL (Daily/Weekly/Monthly, X=none/S=STR/L=LTR).
IF @dbsRet IS NULL OR @dbsRet NOT IN ('XXS', 'XSS', 'SSS', 'XXL', 'XSL', 'SSL', 'XLL', 'SLL', 'LLL', 'AUT' ) 
BEGIN
    PRINT 'You have specified an invalid retention type: ' + @dbsRet
		+ ' - Valid retentions: XXS, XSS, SSS, XXL, XSL, SSL, XLL, SLL, LLL (Daily/Weekly/Monthly; X=none/S=STR/L=LTR)'
	RETURN 1
END
ELSE
	SET @CVRET= '&ret=' + @dbsRet

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
SET @clu = '&clu=' + @CVClient

PRINT 'Client: ' + @CVClient 
PRINT 'Instance: ' + @CVInstance
		
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_REGISTERED', @CV_REGISTERED OUTPUT
IF @CV_REGISTERED <> 1
BEGIN
	PRINT 'ERROR: CV Instance not registered - please register the instance using usp_RegisterCVcmdshell'
	GOTO handle_error
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT

----------------------------------------------------------------
--We do this so we don't have to worry about what users put in as we want a static value of GROUP
--to do all the checks against

IF LEFT(@dbsConfigType, 5) = 'GROUP'
BEGIN
	-- Verify BRAT version
	EXEC @RC = [DBServices].[dbo].[usp_CVBRATchk] @dbsBackupProcessor = @dbsBackupProcessor
	IF @RC <> 0
		RETURN 1
		
	SET @dbsConfigTypeGroupIn = @dbsConfigType
	SET @dbsConfigType = 'GROUP'
END

    
IF @dbsConfigType NOT IN ( 'SIMPLE', 'TRANSACTIONAL', 'SINGLE', 'GROUP')
BEGIN
    PRINT 'ERROR: An invalid Subclient type ' + @dbsConfigType + ' has been specified'
	PRINT 'Valid options: SIMPLE, TRANSACTIONAL, SINGLE, GROUP'
	RETURN 1
END	

------------------------------	
--check database state to decide if we need to default to specific Subclient type or skip adding altogether.

SET @RecoveryType = UPPER(CONVERT(nvarchar(20), DATABASEPROPERTYEX(@DBName, 'recovery')))
IF @RecoveryType <> 'SIMPLE' 
	SET @RecoveryType = 'TRANSACTIONAL'

SELECT @isMirrored = B.mirroring_state
	, @mirrorRole = B.mirroring_role 
FROM sys.databases A WITH (NOLOCK)
INNER JOIN sys.database_mirroring B WITH (NOLOCK)
	ON A.database_id=B.database_id 
WHERE [name] = @DBName
ORDER BY A.name 

EXEC DBServices.dbo.usp_isLogshipped @DBName, @isLog OUTPUT
		
SELECT	@DBBackupType = CAST ( 
				( CASE
	 				WHEN @isLog ='P' THEN 'LS_Primary'
	 				WHEN @isLog ='S' THEN 'STANDBY'
					WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Recovery' )  IS NULL
						THEN 'Decommissioned'
					WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Status' ) <> 'ONLINE'
						THEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Status' )
					WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'IsInStandBy' ) = 1 THEN 'STANDBY'
					WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Updateability' ) <> 'READ_WRITE'
						THEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Updateability' )
					ELSE CONVERT(nvarchar(20), DATABASEPROPERTYEX( d.dbsDatabaseName , 'Recovery' ) )
				END ) 
					as nvarchar(128) ) 	
		,@dbsDatabaseUID = d.[dbsDatabaseUID]   
		,@isActive = d.[dbsDatabaseIsActive]
FROM [DBServices].[dbo].[dbsDatabase] d
	LEFT OUTER JOIN [DBServices].[dbo].[dbsDatabaseBackup] db 
	ON d.[dbsDatabaseUID] = db.dbsDatabaseUID
WHERE d.dbsDatabaseName LIKE @DBName + '%'	

IF @dbsDatabaseUID IS NULL 
BEGIN
    PRINT 'ERROR: Unable to identify the database ' + @DBName
		+ ' within UBSMWE - please restart the UBSMWE_Engine_(...) job and after a few minutes try again'
	RETURN 1
END

------------------------------------------
-- if Mirror DB check state 

IF @isMirrored = 1 
BEGIN
	IF @dbsConfigType = 'SIMPLE'
	BEGIN
		PRINT 'Database ' + @DBName + ' is ' 
			+ CASE @mirrorRole
				WHEN 1 THEN 'Principal'
				ELSE 'Secondary'
				END
			+ ' in Mirrored pair. Defaulting to TRANSACTIONAL type Subclient.'

		SET @dbsConfigType = 'TRANSACTIONAL'
	END
	---------------------

	IF @mirrorRole <> 2 
	BEGIN
		SET @SQL = N'SELECT @intTableCount=COUNT(*) 
			FROM ['+ @DBName +'].sys.database_files
			WHERE state > 0'
	
		EXEC sp_executesql @SQL, N'@intTableCount int OUTPUT', @return_value OUTPUT

		IF @return_value > 0  
		BEGIN
			SET @message =  'Cannot add DB ' + @DBName 
				+ ' for full/diff backup due to unsupported database state. One of more Filegroups is offline.'
			GOTO handle_error
		END
		ELSE
			PRINT 'Confirmed DB ['+ @DBName +'] is online.'
	END
END

------------------------------------------
-- Validate request
	
IF (@dbsConfigType <> @RecoveryType 
		AND @dbsConfigType NOT IN ('SINGLE','GROUP')
		AND @isLog ='N')
BEGIN
	SET @message = 'The DB ' + @DBName + ' does not meet the requirements for the Subclient type ' + @dbsConfigType 
		+ ' - permissible @dbsConfigType options: ' + @RecoveryType + ', SINGLE or GROUP'

	GOTO handle_error
END  ---------------------
ELSE
IF (@isLog IN ('P','S') 
		AND @dbsConfigType IN ('TRANSACTIONAL'))
BEGIN
	SET @message = 'Database '+ @DBName  
		+ ' permissible Subclients for Logshipped DBs are: SIMPLE, SINGLE and GROUP'
	GOTO handle_error
END  ---------------------
ELSE
IF @dbsConfigType = 'SINGLE'
	AND LEN(@DBName) > 60 
	PRINT 'WARNING: the given Database name exceeds 60 characters in length;'
		+ ' consequently its name will be truncated by CV in the SINGLE Subclient name.'

------------------------------------------
-- DO  

PRINT '=> Sending the configuration request to CV'
PRINT 'Please wait....this will take some time, take a break' 

PRINT 'Request '+ @dbsOperation + ' ' + @DBName 
	+ ' to Subclient type ' + @dbsConfigType 

-- Branch according to op
IF @dbsOperation = 'ADD'
	GOTO ADDSubclient
ELSE
IF @dbsOperation = 'MOVE'
	GOTO MOVESubclient

---------------------------------
ADDSubclient:

IF @dbsOperation = 'ADD' 
BEGIN
	IF @dbsConfigType IN('SIMPLE', 'TRANSACTIONAL') 
	BEGIN
		SET @SQL = @CVTRRurl + '/SqlAddDatabase?inst=' + @CVInstance + '&db=' 
		+ @DBName + '&dbtype=' + @dbsConfigType 
		+ '&streams=' + @dbsStreams  + @CVRET + @clu
	END  ---------------------
	ELSE
	IF @dbsConfigType = 'GROUP'
	BEGIN
		--This proc returns the GROUP to add the database to after all the checks etc are complete.
		EXEC @RC = DBServices.dbo.usp_GenerateSubclientGroup
					 @DBName = @DBName 
					,@dbsSubclientGroupDistributionMode = @dbsSubclientGroupDistributionMode
					,@dbsConfigType = @dbsConfigTypeGroupIn 
					,@dbsConfigTypeGroupOut =  @dbsConfigTypeGroupOut OUTPUT
					,@dbsFailed = @fail OUTPUT

		IF @RC <> 0 
			OR @fail = 1
		BEGIN
			SET @message = 'Unexpected error in usp_GenerateSubclientGroup'
			GOTO handle_error
		END
			
		SET @SQL = @CVTRRurl + '/SqlAddDatabase?inst=' + @CVInstance 
			+ '&db=' + @DBName + '&dbtype=' 
			+ @dbsConfigTypeGroupOut + '&streams=' + @dbsStreams + @CVRET + @clu
	END  ---------------------
	ELSE
	BEGIN -- SINGLE (bit odd)
		SET @SQL = @CVTRRurl + '/SqlAddDatabase?inst=' + @CVInstance
			+ '&db=' + @DBName + '&streams=' + @dbsStreams  +  @CVRET + @clu
	END  ---------------------
	
	PRINT @SQL

	EXEC @RC = usp_wget @SQL 

	IF @RC <> 0
	BEGIN
		SET @message = 'ERROR: CV BAS configuration command failed'
		GOTO handle_error
	END
END

GOTO QUIT

----------------------------------------------------------------
--MOVE between subclients logic
MOVESubclient:

IF @dbsConfigType = 'GROUP' --Handle group Subclient logic
BEGIN
	--This proc returns the GROUP to add the database to after all the checks etc are complete.
	EXEC @RC = DBServices.dbo.usp_GenerateSubclientGroup
				@DBName = @DBName 
				,@dbsSubclientGroupDistributionMode = @dbsSubclientGroupDistributionMode
				,@dbsConfigType = @dbsConfigTypeGroupIn 
				,@dbsConfigTypeGroupOut =  @dbsConfigTypeGroupOut OUTPUT
				,@dbsFailed = @fail OUTPUT

	IF @RC <> 0 
		OR @fail = 1
	BEGIN
		SET @message = 'Unexpected error in usp_GenerateSubclientGroup'
		GOTO handle_error
	END
				
	SET @SQL = @CVTRRurl + '/SqlMoveDatabase?inst=' + @CVInstance 
		+ '&db=' + @DBName + '&dbtype=' + @dbsConfigTypeGroupOut 
		+ '&streams=' + @dbsStreams + @CVRET + @clu
END
ELSE
BEGIN
	SET @SQL = @CVTRRurl + '/SqlMoveDatabase?inst=' + @CVInstance
		+ '&db=' + @DBName + '&dbtype=' + @dbsConfigType
		+ '&streams=' + @dbsStreams + @CVRET + @clu
END

PRINT @SQL

EXEC @RC = usp_wget @SQL 
IF @RC <> 0
BEGIN
	SET @message = 'ERROR: CV BAS configuration command has failed'
	GOTO handle_error
END

---------------------------
QUIT:

--wait for the move/add script to finish running AND update latest configuration ON the server
IF @SkipCVList = 0
BEGIN
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay

	PRINT 'Updating local Subclient data...'
	SET @SQL =  '[DBServices].[dbo].[usp_CVList] @CVClient= ''' + @CVClient 
		+ ''', @CVInstance= ''' + @CVInstance 
		+ ''', @Force=1'
	PRINT @SQL
	EXEC (@SQL)

	-- Verify local Subclient data
	SET @CVSubClient = DBServices.dbo.ufn_CV_SubclientforDB(@DBName)
	IF (@dbsConfigType <> 'SINGLE' AND @CVSubClient NOT LIKE '%' + @dbsConfigType + '%')
		OR (@dbsConfigType = 'SINGLE' AND @CVSubClient NOT LIKE '%' + LEFT(@DBName,60) + '%')
	BEGIN
		PRINT 'ERROR: Unhandled exception - ' + @DBName + ' is a member of: ' + @CVSubClient 
			+ ' - Subclient type requested: ' + @dbsConfigType 
		RETURN 1
	END
	ELSE 
		RETURN 0
END
ELSE 
BEGIN
	PRINT 'Skipping Subclient validation upon request..'
	PRINT '-----------------------------------------------------------------------------------------------------------------'
	PRINT 'IMPORTANT: EXECUTE DBServces..usp_CVList_local at the end of your change in order for it to take effect!'
	PRINT '-----------------------------------------------------------------------------------------------------------------'

	RETURN 0
END

---------------------------
handle_error:
SET @message = 'UBSMWE: usp_ConfigureCVSubclients: ' + @message
EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1        
  
RETURN 1

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ConfigureExclusion]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ConfigureExclusion]
						 @DBName nvarchar(128)
						,@dbsExclusionType nvarchar(255)
						,@dbsExclusionSubType nvarchar(255)
						,@dbsExceptionActive bit = 0
						,@dbsAlign tinyint = 0
						,@dbsRetain int = 23
AS
/****************************************************************************************
// @File: usp_ConfigureExclusion.sql
//
// Purpose:
//   Populate DBServices.dbo.dbsDatabasepException to allow
//         databases to be excluded from various functions
//
//   @Date: 06/30/2010 @Author: Steve Trogub @Version: 2.5.4.3 @Action: Created
//   @Date: 11/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 25/11/2014 @Author: Chris Basson @Version: 6.0.0.13 @Action: TRRv3 Beta
//   @Date: 25/11/2015 @Author: Chris Basson @Version: 6.0.0.41 @Action: minor bugfix - ExclusionType = 'maintenance'
****************************************************************************************/

BEGIN -- main
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
		,@dbsUID uniqueidentifier
		,@dbsExceptionID int
		,@ErrorMsg nvarchar(255)

---------------------
SET @dbsExclusionType = LOWER(LTRIM(RTRIM(@dbsExclusionType)))
SET @dbsExclusionSubType = LOWER(LTRIM(RTRIM(@dbsExclusionSubType)))

IF @dbsExclusionType NOT IN ('backup','maintenance','filesystem')
BEGIN
	SET @ErrorMsg = 'Invalid @dbsExclusionType value passed (options: backup, maintenance)'
	PRINT @ErrorMsg
	GOTO END_IT
END

SET @ErrorMsg = CASE
		WHEN @dbsExclusionType = 'backup' AND @dbsExclusionSubType NOT IN ('external', 'no_full', 'partial', 'full', 'differential', 'transaction_log')
			THEN 'Invalid @dbsExclusionSubType parameter passed (options: external, no_full, partial, full, differential, transaction_log)'

		WHEN @dbsExclusionType = 'maintenance'
			AND @dbsExclusionSubType NOT IN ('indexrebuild', 'warehouse_indexrebuild')
			AND @dbsExclusionSubType NOT LIKE 'updatestats@__:__'
			THEN 'Invalid @dbsExclusionSubType parameter passed (options: indexrebuild, warehouse_indexrebuild, updatestats@hh:mm)'

		WHEN @dbsExclusionType = 'maintenance' 
			AND @dbsExclusionSubType LIKE 'updatestats@__:__'
			AND NOT ISDATE(RIGHT(@dbsExclusionSubType,5)) = 1
			THEN 'Invalid @dbsExclusionSubType passed; a valid updatestats execution time is required (24hr format: updatestats@hh:mm)'

		ELSE NULL
	END

IF @ErrorMsg IS NOT NULL
BEGIN
	PRINT @ErrorMsg
	GOTO END_IT
END

IF @dbsExclusionSubType IN ('partial', 'full', 'differential')
	AND @dbsAlign NOT BETWEEN 0 AND 7
BEGIN
	SET @ErrorMsg = 'The alignment day (@dbsAlign) must be between 1 (Sunday) and 7 (Saturday)'
	PRINT @ErrorMsg
	GOTO END_IT
END

IF @dbsExclusionSubType IN ('partial', 'full', 'differential', 'transaction_log')
	AND @dbsRetain NOT BETWEEN 1 AND 672
BEGIN
	SET @ErrorMsg = 'The @dbsRetain parameter (file retention hrs) must be between 1 and 672'
	PRINT @ErrorMsg
	GOTO END_IT
END

--------------------------------------------------------------
-- Insert into DBServices.dbo.dbsDatabaseException

SELECT @dbsExceptionID = ISNULL(MAX(dbsDatabaseExceptionID), 0) + 1 
FROM DBServices.dbo.dbsDatabaseException

SELECT @dbsUID = CAST([dbsDatabaseUID] as char(36))
FROM [DBServices].[dbo].[dbsDatabase]
WHERE  dbsDatabaseName = @DBName
	AND dbsDatabaseIsActive = 1

---------------------

INSERT INTO DBServices.dbo.dbsDatabaseException
VALUES(@dbsExceptionID
	,@dbsExclusionType
	,@dbsExclusionSubType
	,@dbsUID
	,@DBName
	,getdate()
	,suser_sname()
	,@dbsExceptionActive
	,@dbsAlign
	,@dbsRetain )

SET @RC = @@ERROR

IF @RC = 0 
	AND @dbsExclusionSubType = 'external'
	UPDATE DBServices.dbo.dbsDatabaseBackup
	SET dbsDBExternalBackupFlag = 0
	WHERE dbsDatabaseUID = @dbsUID

RETURN @RC

--------------------------------------------------------------
END_IT:

RETURN 1

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_ConfigureNetbackup]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_ConfigureNetbackup] 	@NB_Enabled nvarchar(255) = 'NA'
						,@NB_WindowStartTime nvarchar(255) = 'NA'
						,@NB_WindowEndTime nvarchar(255) = 'NA'
						,@NB_NodeOneName nvarchar(255) = 'NA'
						,@NB_NodeOneClass nvarchar(255) = 'NA'
						,@NB_NodeTwoName nvarchar(255) = 'NA'
						,@NB_NodeTwoClass nvarchar(255) = 'NA'
						,@NB_NodeThreeName nvarchar(255) = 'NA'
						,@NB_NodeThreeClass nvarchar(255) = 'NA'
						
						--,@NB_LogFile nvarchar(255) = 'NA'
						--,@NB_FileList nvarchar(255) = 'NA'
						--,@NB__BPBackup_ExecutableLocation nvarchar(255) = 'C:\Program Files\Veritas\NB_\bin\bpbackup.exe'


--EXEC usp_UpdatedbsInstanceConfig 'NB_WindowStartTime', '01:30'
--EXEC usp_UpdatedbsInstanceConfig 'NB_WindowEndTime', '09:30'


AS

SET DATEFORMAT ymd
--xp_cmdshell '"C:\Program Files\Veritas\NB_\bin\bpbackup.exe" -c NZURC302_SAN -L r:\mssql\backup\NB_\proglog.txt -w -f r:\mssql\backup\NB_\backuplist.txt'
--EXIT STATUS 239: the specified client does not exist in the specified class

/****************************************************************************************
// @File: usp_ConfigureNB_.SQL
// 
// Purpose:
//   Populate dbsInstanceConfig with NB_ information and turn on/off NB_ calling...
//
// Notes: This stored procedure is mostly only used during initial install but can be rerun to change existing configuration. 
//
// History: Dates are in dd/mm/yyyy format
//
//   @Date: 05/10/2004 @Author: Kevin Wagner @Version: 1.5.0 @Action: Created
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 27/02/2007 @Author: Kevin Wagner @Version: 2.5.2	 @Action: Updated for change in Netbackup File Location.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

BEGIN  --Begin main()


PRINT '/************************************************************************************************************/'
PRINT 'Start Running of usp_ConfigureNetbackup at ' + CONVERT ( varchar ( 255 )  , getdate() , 114  )+ ' on ' + @@servername
--PRINT '/************************************************************************************************************/'

DECLARE  @RC						int
		,@dbsInstanceFileLocation	nvarchar(255)
		,@sql1						nvarchar(255)
		,@sql2						nvarchar(4000)


/*
// Set current status in heartbeat
*/
SET NOCOUNT ON
	EXEC usp_UpdatedbsUBSMWEHeartbeat 'start usp_ConfigureNetbackup'

	DELETE from dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_WorkDirectory'
/*
//    The idea here is to initialize the dbsInstance table with default settings for NB_
*/

--,@NB_Enabled nvarchar(255) = 'NA'
	IF @NB_Enabled = '1'
		BEGIN
			--Set enabled flag to true for Netbackup
			EXEC usp_UpdatedbsInstanceConfig 'NB_Enabled', 1
			--Get the currently configured backup drive and append the Netbackup directory
			EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT
			--Set the NB_ work directory location 

			--Now, create the directory...
			SELECT @sql2 = 'if not exist ' + @dbsInstanceFileLocation + '\Netbackup' + ' md '  + @dbsInstanceFileLocation + '\Netbackup'
			PRINT @sql2
			EXEC master..xp_cmdshell @sql2

		END

	IF @NB_Enabled = '0'

		BEGIN
			EXEC usp_ConfigureUBSMWE 'NB_Enabled', 0
		END
		

--,@NB__BPBackup_ExecutableLocation nvarchar(255) = 'NA'
--	IF @NB__BPBackup_ExecutableLocation <> 'NA' 
--Force this setting to be 'C:\Program Files\Veritas\NB_\bin\bpbackup.exe', can then change using usp_ConfigureUBSMWE

		BEGIN
			EXEC usp_ConfigureUBSMWE 'NB_BPBackup_ExecutableLocation', 'C:\Program Files\Veritas\Netbackup\bin\bpbackup.exe'
		END


--@NB_NodeOneName nvarchar(255) = 'NA'
--Changing config values to be NB_Class_NodeName, ClassName
	IF @NB_NodeOneName <> 'NA'
		BEGIN
			SELECT @sql1 = 'NB_Class_' + UPPER(@NB_NodeOneName)
			EXEC usp_ConfigureUBSMWE	@sql1, @NB_NodeOneClass 

		END

--@NB_NodeTwoName nvarchar(255) = 'NA'
	IF @NB_NodeTwoName <> 'NA'
		BEGIN
			SELECT @sql1 = 'NB_Class_' + @NB_NodeTwoName
			EXEC usp_ConfigureUBSMWE	@sql1, @NB_NodeTwoClass

		END

--@NB_NodeThreeName nvarchar(255) = 'NA'
	IF @NB_NodeThreeName <> 'NA'
		BEGIN
			SELECT @sql1 = 'NB_Class_' + @NB_NodeThreeName
			EXEC usp_UpdatedbsInstanceConfig	@sql1, @NB_NodeThreeClass

		END
	
--,@NB_WindowStartTime nvarchar(255) = 'NA'
	IF @NB_WindowStartTime <> 'NA'
		BEGIN
			EXEC usp_UpdatedbsInstanceConfig	'NB_WindowStartTime', @NB_WindowStartTime

		END

--,@NB_WindowEndTime nvarchar(255) = 'NA'
	IF @NB_WindowEndTime <> 'NA'
		BEGIN
			EXEC usp_UpdatedbsInstanceConfig	'NB_WindowEndTime', @NB_WindowEndTime

		END



--EXEC usp_ConfigureUBSMWE
SET NOCOUNT ON

select cast(dbsInstanceConfigName as varchar(40)) as 'dbsInstanceConfigName', dbsInstanceConfigValue   from dbsInstanceConfig WHERE dbsInstanceConfigName LIKE 'NB%'


/*
// Set current status in heartbeat
*/
	EXEC usp_UpdatedbsUBSMWEHeartbeat 'finish usp_ConfigureNetbackup'

--PRINT '/************************************************************************************************************/'
PRINT 'Finished Running of usp_ConfigureNetbackup at ' + CONVERT ( varchar ( 255 )  , getdate() , 114  )+ ' on ' + @@servername
PRINT '/************************************************************************************************************/'

	

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ConfigureUBSMWE]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ConfigureUBSMWE] 
					@dbsInstanceConfigName nvarchar(255) = NULL
					,@dbsInstanceConfigValue nvarchar(255) = NULL
AS

/****************************************************************************************
// @File: usp_ConfigureUBSMWE.SQL
// 
// Purpose:
//   Update dbsInstanceConfig with New config value or report current config...
//
// Notes: This stored procedure can be rerun to change existing configuration. 
//
// History: Dates are in mm/dd/yyyy format
//
//   @Date: 10/05/2004 @Author: Kevin Wagner @Version: 1.5.0 @Action: Inception.
//   @Date: 08/02/2006 @Author: Rakesh Bist @Version: 1.5.3 @Action: Added WorkFlow tasks component.
//   @Date: 09/23/2006 @Author: Kevin Wagner @Version: 2.0 @Action: Removed WorkFlow tasks component.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//   @Date: 28/07/2010 @Author: Steve Trogub @Version: 2.5.4.3 @Action: SQL2000 diff backup check and reconfigure.
//	 @Date: 22/07/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta 
//	 @Date:	12/08/2014 @Author: Chris Basson @Version: 6.0.0.1 @Action: TRRv3 Beta 
//	 @Date:	20/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta 
//	 @Date:	06/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//	 @Date:	29/10/2014 @Author: Chris Basson @Version: 6.0.0.9 @Action: TRRv3 Beta
//	 @Date:	10/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//	 @Date:	08/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta
//	 @Date:	12/12/2014 @Author: Chris Basson @Version: 6.0.0.15 @Action: TRRv3 TRR-103
//	 @Date:	27/01/2015 @Author: Chris Basson @Version: 6.0.0.22 @Action: TRRv3 TRR-119 - request
//	 @Date: 20/02/2015 @Author: Chris Basson @Version: 6.0.0.25 @Action: Feature request: add DB backup monitoring for CV TRRv3 
//	 @Date: 19/03/2015 @Author: Chris Basson @Version: 6.0.0.28 @Action: Bugfix for dbsDatabaseFullBackupStartTime - to set WF job time
//   @Date: 31/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: TRR-132 Feature request for DB file backup subfolders
//   @Date: 16/04/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Minor bugfix for dbsInstanceFileLocation 
//   @Date: 10/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Minor - added param DisableAdv
//   @Date: 01/10/2015 @Author: Chris Basson @Version: 6.0.0.39 @Action: Minor - Clarified error msg
//	 @Date: 15/10/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Feature request: Long running Sunday Workflow alert (dbsMaintLongRunConcernHrs)

****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @MajorVersion tinyint
		,@RC int
		,@astr nvarchar(512)
		,@CurrentdbsInstanceConfigValue nvarchar(255)
		,@CR char(1)
		,@exists bit
		,@ErrorMsg varchar(512)
		,@CVFSBackupSet nvarchar(128)
		,@CVFSSubclient nvarchar(128)
		,@CV_Enabled bit
		,@CV_REGISTERED bit

-------------------

SET @MajorVersion = dbo.ufn_InstanceMajorVersion()
SET @dbsInstanceConfigName = LTRIM(RTRIM(@dbsInstanceConfigName))
SET @dbsInstanceConfigValue = LTRIM(RTRIM(@dbsInstanceConfigValue))
SET @RC = 0
SET @CR = CHAR(13) -- Carridge return
SET @exists = 0

-- Don't allow empty strings
IF @dbsInstanceConfigName = '' 
	SET @dbsInstanceConfigName = NULL

IF @dbsInstanceConfigValue = '' 
	SET @dbsInstanceConfigValue = NULL

----------------------------------------------------------------------
-- Validation:

IF @dbsInstanceConfigName IS NOT NULL AND @dbsInstanceConfigValue IS NULL
BEGIN
	-- List given config
	SELECT dbsInstanceConfigName, dbsInstanceConfigValue
	FROM dbo.dbsInstanceConfig
	WHERE dbsInstanceConfigName = @dbsInstanceConfigName

	GOTO END_IT
END -------------------
ELSE -- List if no params passed
IF @dbsInstanceConfigName IS NULL AND @dbsInstanceConfigValue IS NULL
BEGIN
	SELECT dbsInstanceConfigName, dbsInstanceConfigValue
	FROM dbo.dbsInstanceConfig
	ORDER BY dbsInstanceConfigName

	GOTO END_IT
END -------------------
ELSE -- check bit type params
IF @dbsInstanceConfigName IN ( 
							'CV_Enabled'
							,'CV_FSIncSysDB'
							,'CV_Parallel_Ops'
							,'dbsDiffBackup'
							,'dbsExcludeAllUserDatabases'
							,'dbsFGRPBackup'
							,'dbsForceCVKill'
							,'DisableBackupInformationalMessages'
							,'IncludeReadOnlyBackups'
							,'IndexRebuildOnline'
							,'IndexSortinTempDB'
							,'IndexTblLockCheck'
							,'IndexFailovertoREORG'
							,'MSCCQProcessEnabled'
							,'NB_Enabled'
							,'NB_OKToExecuteFlag'
							,'NB_WindowFlag'
							,'SEGREGATE_MANIFEST'
							,'SendAlertOnIndividualFilePurgeErrors'
							,'WITH_PHYSICAL_ONLY'
							,'dbsUpdateStatsASAP'
							,'DisableBMAlerts'
							,'dbsBakTlogConcernCVOnly'
							,'dbsFSDBSubfolders'
							,'DisableMSSQLCentral'
							,'DisableAdv'
							)
	AND @dbsInstanceConfigValue NOT IN ('0','1')
BEGIN
	PRINT @dbsInstanceConfigName + ' is a flag thus can only be 0 or 1 - unable to configure'

	SET @RC=1
	GOTO END_IT
END -------------------
ELSE -- check file path type params
IF @dbsInstanceConfigName IN ( 
							'CV_BRATPath'
							,'CV_ExecutableLocation'
							,'CV_RootPath'
							,'dbsInstanceFileLocation'
							,'NB_BPBackup_ExecutableLocation'
							,'NB_WorkDirectory'
							,'dbsJobLogPathOverride'
							)
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_FileExists] @dbsInstanceConfigValue, @exists OUTPUT
	IF  @exists = 0
		PRINT 'WARNING: ' + @dbsInstanceConfigName + ': ' + @dbsInstanceConfigValue + ' either does not exist or the MSSQL Service account does not have access!'
END -------------------
ELSE -- check date time type params
IF @dbsInstanceConfigName IN ( 
							'dbsDatabaseDBCCStartTime'
							,'dbsDatabaseFullBackupStartTime'
							,'dbsDatabaseIDXReorgStartTime'
							,'dbsDatabaseLogBackupEndTime'
							,'dbsDatabaseLogBackupStartTime'
							,'IndexRetryDelay'
							,'NB_WindowEndTime'
							,'NB_WindowStartTime'
							,'dbsDBBackupChk_SleepDT'
							)
	AND ISDATE(@dbsInstanceConfigValue) = 0
BEGIN
	PRINT @dbsInstanceConfigName + ' must be a valid time - unable to configure'

	SET @RC=1
	GOTO END_IT
END -------------------
ELSE -- check range type params
BEGIN
	SET @ErrorMsg = CASE 
		WHEN @dbsInstanceConfigName = 'dbsBackupProcessor' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 5
				THEN  ' must be a value between 1 and 5'
		WHEN @dbsInstanceConfigName = 'debug' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 3
				THEN ' must be a value between 1 (quiet) and 3 (verbose)'

		WHEN @dbsInstanceConfigName = 'CV_SubclientGroupingType' AND @dbsInstanceConfigValue NOT BETWEEN 0 AND 2
				THEN  ' must be a value of 0,1 or 2'
		WHEN @dbsInstanceConfigName = 'CV_SubclientGroupingNumGroups' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 8
				THEN  ' must be a value between 1 and 8'
		WHEN @dbsInstanceConfigName = 'dbsDatabaseCVTimeoutMinutes' AND @dbsInstanceConfigValue NOT BETWEEN 20 AND 1380
				THEN  ' must be a value between 20 and 1380'

		WHEN @dbsInstanceConfigName = 'IndexDeadline' AND (ISDATE(@dbsInstanceConfigValue) = 0 AND @dbsInstanceConfigValue IS NOT NULL)
				THEN ' must be a valid time (format hh:mm)'
		WHEN @dbsInstanceConfigName = 'IndexFragmentationLimitPercent' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 99
				THEN  ' must be a value between 1 and 99'

		WHEN @dbsInstanceConfigName = 'MaxConcurrentBUFull' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 5
				THEN  ' must be a value between 1 and 5'
		WHEN @dbsInstanceConfigName = 'MaxConcurrentBULog' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 5
				THEN  ' must be a value between 1 and 5'
		WHEN @dbsInstanceConfigName = 'MaxConcurrentDBCheck' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 3
				THEN  ' must be a value between 1 and 3'
		WHEN @dbsInstanceConfigName = 'MaxConcurrentIDXReBld' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 3
				THEN  ' must be a value between 1 and 3'
		WHEN @dbsInstanceConfigName = 'MaxConcurrentIDXUpdSt' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 5
				THEN  ' must be a value between 1 and 5'
		WHEN @dbsInstanceConfigName = 'dbsBUFFERCOUNT' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 40
				THEN  ' must be a value between 1 and 40'

		WHEN @dbsInstanceConfigName = 'NetbackupErrorLimit' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 10
				THEN  ' must be a value between 1 and 10'
		WHEN @dbsInstanceConfigName = 'NetbackupErrorRerunDelay' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 10
				THEN  ' must be a value between 1 and 10'
		WHEN @dbsInstanceConfigName = 'NetbackupErrorRerunDelayMinutes' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 60
				THEN  ' must be a value between 1 and 60' 

		WHEN @dbsInstanceConfigName = 'MAXDOP' AND @dbsInstanceConfigValue NOT BETWEEN 0 AND 8
				THEN  ' must be a value between 0 and 8'

		WHEN @dbsInstanceConfigName = 'dbsUpdateStatsMaxRetryMins' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 1380
				THEN ' must be a value between 1 and 1380'

		WHEN @dbsInstanceConfigName = 'dbsDiffBackupThreshold' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 99
				THEN  ' must be a value between 1 and 99'
		WHEN @dbsInstanceConfigName = 'dbsDiffnPartFullBackupAlignDay' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 7
				THEN  ' must be a value between 1 (SUN) and 7 (SAT)'

		WHEN @dbsInstanceConfigName = 'dbsLocalHistoryRetainDays' AND @dbsInstanceConfigValue NOT BETWEEN 7 AND 1095
				THEN ' must be a value between 7 and 1095'

		WHEN @dbsInstanceConfigName = 'DeleteRetryIntervalSeconds' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 600
				THEN ' must be a value between 1 and 600'

		WHEN @dbsInstanceConfigName = 'dbsBackupLUN_SpaceThresholdPerc' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 99
				THEN  ' must be a value between 1 and 99'
		WHEN @dbsInstanceConfigName = 'dbsBackupLUN_RetryMins' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 120
				THEN  ' must be a value between 1 and 120'

		WHEN @dbsInstanceConfigName = 'MainCycleCountMinutes' AND @dbsInstanceConfigValue NOT BETWEEN 360 AND 1380
				THEN  ' must be a value between 360 and 1380'

		WHEN @dbsInstanceConfigName = 'dbsFSBakMinHrs' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 23
				THEN  ' must be a value between 1 and 23'

		WHEN @dbsInstanceConfigName = 'dbsBakFullConcernHrs' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 720
				THEN  ' must be a value between 1 and 720'

		WHEN @dbsInstanceConfigName = 'dbsBakDiffConcernHrs' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 720
				THEN  ' must be a value between 1 and 720'

		WHEN @dbsInstanceConfigName = 'dbsBakTlogConcernMins' AND @dbsInstanceConfigValue NOT BETWEEN 1 AND 1380
				THEN  ' must be a value between 1 and 1380. Note min value = (CV_SchedTlogBakMins *2) + 1 mins'

		WHEN @dbsInstanceConfigName = 'CV_SchedTlogBakMins'
				THEN ' Info only, CV TLog backup frequency can modified via a SNow request'

		WHEN @dbsInstanceConfigName = 'dbsMaintLongRunConcernHrs' AND @dbsInstanceConfigValue NOT BETWEEN 2 AND 24
				THEN ' must be a value between 2 and 24 hrs'

		ELSE NULL
		END 

	IF @ErrorMsg IS NOT NULL
	BEGIN
		PRINT @dbsInstanceConfigName + @ErrorMsg + ' - unable to configure'

		SET @RC=1
		GOTO END_IT
	END
END -------------------

----------------------------------------------------------------------
-- Get current value

SET @CurrentdbsInstanceConfigValue = ''
EXEC @RC = DBServices.dbo.usp_GetdbsInstanceConfig @dbsInstanceConfigName, @CurrentdbsInstanceConfigValue OUTPUT ,1
IF @RC <> 0
	PRINT @dbsInstanceConfigName + ' does not exist - creating..'
ELSE
	PRINT 'Original value of ' + @dbsInstanceConfigName + ' = ' + @CurrentdbsInstanceConfigValue

----------------------------------------------------------------------
-- Special cases

-- Workflow job parameters
IF @dbsInstanceConfigName IN ('dbsDatabaseFullBackupStartTime')
BEGIN
	EXEC @RC = DBServices.dbo.usp_UpdateWorkFlowJob 
						@WFJobName = 'UBSMWE_WF_Daily_BUFull'
						,@WFJobStartTime = @dbsInstanceConfigValue
						,@WFJobStatus = 1
	IF @RC <> 0
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_ConfigureUBSMWE: ERROR Parameter ' + @dbsInstanceConfigName 
			+ ' : ' + @dbsInstanceConfigValue + ' Unable to complete the operation'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
		
		SET @RC = 1
		GOTO END_IT
	END -------------------
END
ELSE
--------------------------------------
-- 'NB_WorkDirectory','dbsInstanceFileLocation'

IF @dbsInstanceConfigName IN ('dbsInstanceFileLocation', 'NB_WorkDirectory','dbsJobLogPathOverride')
BEGIN
	IF RIGHT(@CurrentdbsInstanceConfigValue, 1) = '\' 
		SET @CurrentdbsInstanceConfigValue = LEFT (@CurrentdbsInstanceConfigValue , LEN (@CurrentdbsInstanceConfigValue) - 1)

	IF RIGHT(@dbsInstanceConfigValue, 1) = '\' 
		SET @dbsInstanceConfigValue = LEFT (@dbsInstanceConfigValue , LEN (@dbsInstanceConfigValue) - 1)

	EXEC @RC = [DBServices].[dbo].[usp_FileExists] @dbsInstanceConfigValue, @exists OUTPUT
	IF  @exists = 0
	BEGIN
		PRINT 'Folder ' + @dbsInstanceConfigValue + ' does not exist - attempting to create'
		SET @astr = N'mkdir ' + @dbsInstanceConfigValue
		EXEC @RC = master..xp_cmdshell @astr, no_output

		IF @RC <> 0
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_ConfigureUBSMWE: ERROR Parameter ' + @dbsInstanceConfigName 
				+ ' : ' + @dbsInstanceConfigValue + ' path not found. Unable to complete the operation'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
			
			SET @RC = 1
			GOTO END_IT
		END -------------------
		ELSE 
		BEGIN
			PRINT '- Successful'
			SET @exists = 1
		END
	END
	ELSE 
		PRINT 'Path: ' + @dbsInstanceConfigValue + ' found'

	IF @dbsInstanceConfigName IN ('dbsInstanceFileLocation')
	BEGIN
		PRINT 'dbsInstanceFileLocation => updating table [DBServices]..[dbsDatabaseBackup] accordingly...'

		UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
		SET [dbsDBFileLocation] = REPLACE([dbsDBFileLocation], @CurrentdbsInstanceConfigValue, @dbsInstanceConfigValue)
		WHERE [dbsDBBackupType] NOT IN ('Decommissioned')
	END
END

--------------------------------------
 -- dbsBackupProcessor handler
IF @dbsInstanceConfigName = 'dbsBackupProcessor'
BEGIN

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_REGISTERED', @CV_REGISTERED OUTPUT
	IF ISNULL(@CV_REGISTERED,0) = 0
		AND @dbsInstanceConfigValue = 5
	BEGIN
		PRINT @CR
		PRINT '--------------------------------------------------------------------------------'
		PRINT 'TRRv3: CommVault Scheduled backups' + @CR
		PRINT '*** Important Notice ***' + @CR
		PRINT 'CommCell client registration / verification required'
		PRINT '* See step 7 "CommCell client registration" of the UBSMWE Operations Guide for details' + @CR
		PRINT '=> Following the SUCCESSFUL execution of [usp_RegisterCVcmdshell]'
		PRINT '	AND a SUCCESSFUL restart of the CV services'+ @CR
		PRINT 'This command will need to be re-executed in order for UBSMWE to proceed with the'
		PRINT 'validation and configuration for CommVault Scheduled backups, namely:' + @CR
		PRINT '	EXEC [DBServices]..[usp_ConfigureUBSMWE] ''dbsBackupProcessor'',  5' + @CR
		PRINT '! Critical errors will occur if these steps are not completed successfully !'
		PRINT '--------------------------------------------------------------------------------' + @CR

		EXEC @RC = DBServices.dbo.usp_UpdatedbsInstanceConfig @dbsInstanceConfigName , @dbsInstanceConfigValue 

		GOTO END_IT
	END
	
	ELSE

	PRINT '--------------------------------------------------------------------------------'
	PRINT 'Please note a number of configuration parameters will also be set'
	PRINT 'as part of the dbsBackupProcessor change:'
	PRINT @CR + 'Original values:'
	
	SELECT * 
	FROM DBServices.dbo.dbsInstanceConfig
	WHERE dbsInstanceConfigName IN ('CV_Parallel_Ops','NB_Enabled','CV_Enabled','CV_FSIncSysDB'
									,'dbsExcludeAllUserDatabases','dbsRetainBackupFileDurationHrs')

	IF @dbsInstanceConfigValue IN ('1','2','3')	-- Local dumps
	BEGIN
		-- Reset flags which may have been set for CV
		EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_FSIncSysDB', '1'
		EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_Parallel_Ops', '0'
		EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsExcludeAllUserDatabases', '0'
		EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsRetainBackupFileDurationHrs','23'
	END -------------------

	ELSE
	IF @dbsInstanceConfigValue IN ('4','5')	-- CommVault 
	BEGIN
		-- Verify BRAT version

		DECLARE @dbsBackupProcessor as tinyint
		SET @dbsBackupProcessor = CAST(@dbsInstanceConfigValue as tinyint)

		EXEC @RC = [DBServices].[dbo].[usp_CVBRATchk] @dbsBackupProcessor = @dbsBackupProcessor, @init = 1
		IF @RC <> 0
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_ConfigureUBSMWE: ERROR BRAT pre-requisite check failed - Parameter ' + @dbsInstanceConfigName 
				+ ' : ' + @dbsInstanceConfigValue + ' Unable to complete the operation'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2

			GOTO END_IT
		END

		EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT
		IF @CV_Enabled = 1
		BEGIN
			EXEC @RC = [DBServices].[dbo].[usp_CVFSBackupSet] @CVFSBackupSet OUTPUT, @CVFSSubclient OUTPUT, @Init=1
			IF @RC <> 0
				PRINT 'Info: This instance has NOT been registered for CV Filesystem backups'
			ELSE
				PRINT 'Info: Registered for CV Filesystem backups'
		END
		-------------------
		-- CV NT AUTHORITY\SYSTEM permissions check

		IF  IS_SRVROLEMEMBER ('sysadmin','NT AUTHORITY\SYSTEM') = 0
		BEGIN
			PRINT 'Prerequisite: NT AUTHORITY\SYSTEM is not a member of the sysadmins role' + @CR
			PRINT 'Attempting to add role member:'
			EXEC @RC = sp_addrolemember @rolename = 'sysadmin', @membername = 'NT AUTHORITY\SYSTEM'

			IF @RC <> 0
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_ConfigureUBSMWE: ERROR unable to add NT AUTHORITY\SYSTEM to the sysadmins role - Parameter '
					+ @dbsInstanceConfigName 
					+ ' : ' + @dbsInstanceConfigValue + ' Unable to complete the operation'
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2

				GOTO END_IT
			END
			ELSE 
				PRINT 'OK - NT AUTHORITY\SYSTEM added to the sysadmins role'
		END		

		-------------------
		-- Checks OK - proceed

		EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_Parallel_Ops', '1'

		IF @dbsInstanceConfigValue = '5' -- TRRv3 Scheduling
		BEGIN		
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_FSIncSysDB', '0'
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsExcludeAllUserDatabases', '1'
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsRetainBackupFileDurationHrs','71'
		END -------------------
		ELSE
		BEGIN -- @dbsInstanceConfigValue = '4'	-- Client initiated CV SQL iDA Backups
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_FSIncSysDB', '1'
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsExcludeAllUserDatabases', '0'
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsRetainBackupFileDurationHrs','23'
		END
	END

	-------------------
	PRINT @CR + 'NEW values:'
	
	SELECT * 
	FROM DBServices.dbo.dbsInstanceConfig
	WHERE dbsInstanceConfigName IN ('CV_Parallel_Ops','NB_Enabled','CV_Enabled','CV_FSIncSysDB'
									,'dbsExcludeAllUserDatabases','dbsRetainBackupFileDurationHrs')

	PRINT @CR + '*** Please keep this info in case there is a need to revert ***' + @CR

	PRINT '--------------------------------------------------------------------------------'

END -- dbsBackupProcessor handler

----------------------------------------------------------------------	
----------------------------------------------------------------------	
-- SET given config parameter

IF @dbsInstanceConfigName IS NOT NULL
	AND @dbsInstanceConfigValue IS NOT NULL
BEGIN
	-- Checks, preupdate tasks OK, update dbsInstanceConfig table DO

	EXEC @RC = DBServices.dbo.usp_UpdatedbsInstanceConfig @dbsInstanceConfigName , @dbsInstanceConfigValue 

	IF @RC <> 0
	BEGIN
		PRINT 'UBSMWE: usp_ConfigureUBSMWE: Unhandled exception occured whilst updating the dbsInstanceConfig table value for ' + @dbsInstanceConfigName 
		RETURN 1
	END
	ELSE
		PRINT 'OK - set ' + @dbsInstanceConfigName + ' = ' + @dbsInstanceConfigValue

	------------------------
	-- Post update tasks:

	IF @dbsInstanceConfigName IN ('dbsBackupProcessor', 'dbsJobLogPathOverride', 'dbsInstanceFileLocation')
		EXEC DBServices.dbo.usp_UpdatedbsDatabaseBackup @Init=1	-- Reinitialise WF backup jobs

	IF @dbsInstanceConfigName IN ('dbsInstanceFileLocation', 'dbsJobLogPathOverride')
	BEGIN
		PRINT '=> Updating UBSMWE Job Log folders accordingly...'
	
		EXEC [DBServices].[dbo].usp_UpdateUBSMWEJobLogs
	END

	SELECT TOP 1 @astr = [name] 
	FROM msdb.dbo.sysjobs sj WITH (NOLOCK)
	WHERE [name] LIKE 'UBSMWE_Engine_%'

	PRINT '--------------------------------------------------------------------------------'
	PRINT @CR + '=> Restart the job ' + @astr + ' to ensure the change takes effect.'
	PRINT @CR + '*** Please note an initial cycle can take upto 15mins to process ***'

END

------------------------
END_IT:
RETURN @RC

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CreateGUIDPassword]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_CreateGUIDPassword]
	@VVCNewPassword varchar(50) OUTPUT
--RETURNS
--	varchar(50)
AS
/****************************************************************************************
// @File: usp_CreateGUIDPassword.SQL
// 
// Purpose:
//   Generate new sa password..
//
// Notes: For MORCS compliance.
//
// History: Dates are in dd/mm/yyyy format
//
//   @Date: 16/02/2008 @Author: Kevin Wagner (Charley) @Version: 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

BEGIN 

	-- Creating a local variable with DECLARE/SET syntax.
	DECLARE @VUINewUID uniqueidentifier -- xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
-- 	DECLARE @VVCScrambledUID varchar(50)--uniqueidentifier -- xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
--	DECLARE @VVCNewPassword varchar(50)

	SELECT @VUINewUID = NEWID()

-- 	SET @VVCScrambledUID = CAST (@VUINewUID AS VARCHAR(50))

	--SELECT SUBSTRING(@myid,19,18)+SUBSTRING(@myid,1,18)
	SET @VVCNewPassword=RIGHT(@VUINewUID,18)+LEFT(@VUINewUID,18)

--	PRINT @VUINewUID
--	PRINT @VVCNewPassword

-- 	SET @VVCNewPassword = @VVCScrambledUID

--    RETURN (@VVCNewPassword)
END;

GO
/****** Object:  StoredProcedure [dbo].[usp_Createtxtfile]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_Createtxtfile] (
				@FileName varchar(255)
				,@Contents nvarchar(max))
AS

/****************************************************************************************
// @File: usp_Createtxtfile.SQL
//
// @Version 6.0.0.2
//
// Purpose:
//   Creates an output text file with the given contents
//
// Notes: System only 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 13/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.2 @Action: TRRv3 Beta 
****************************************************************************************/
BEGIN -- Main

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @RC int
	,@Errormsg varchar(255) 
	,@fso int 
	,@fileObject int 

--Create a handle to the File System Object
EXECUTE @RC = sp_OACreate 'Scripting.FileSystemObject', @fso OUT
IF @RC <> 0 
BEGIN
	SET @Errormsg =  'UBSME: usp_Createtxtfile: Error sp_OACreate "Scripting.FileSystemObject", @fso OUT'
	GOTO END_IT
END

--Create a handle to the File Object
EXECUTE @RC = sp_OAMethod @fso, 'OpenTextFile', @fileObject OUT, @FileName, 8, 1
IF @RC <> 0
BEGIN
	SET @Errormsg =  'UBSME: usp_Createtxtfile: Error sp_OAMethod @FS, "OpenTextFile", @fileObject OUT, ' + @FileName + ', 8, 1'
	GOTO END_IT
END

--Actually write the information to the text file object
EXECUTE @RC = sp_OAMethod @fileObject, 'Write', NULL, @Contents
IF @RC <> 0
BEGIN
	SET @Errormsg = 'UBSME: usp_Createtxtfile: Error sp_OAMethod WriteLine. Volume may be out of space'
	GOTO END_IT
END     

--Since this is real code, need to destroy the objects
EXECUTE @RC = sp_OADestroy @fileObject
IF @RC <> 0 
BEGIN
	SET @Errormsg =  'UBSME: usp_Createtxtfile: Error sp_OADestroy @fileObject: ' + @FileName
	GOTO END_IT
END

--Since this is real code, need to destroy the objects
EXECUTE @RC = sp_OADestroy @fso
IF @RC <> 0 
BEGIN
	SET @Errormsg = 'UBSME: usp_Createtxtfile: Error sp_OADestroy @fso: ' + @FileName
	GOTO END_IT
END

SET QUOTED_IDENTIFIER OFF
RETURN 0

END_IT:
EXEC [DBServices].[dbo].[usp_LogEvent] @Errormsg, 1 --info event

RETURN 1

END -- Main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVBackup]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVBackup] (@DBName sysname = NULL
									,@CVSubClient nvarchar(255)= NULL -- Note DBName takes precedence over Subclient
                                    ,@BackupType tinyint = 20 -- 0 full, 1 tlog, 2 incremental, 3 CV Tlog de-stage, 20 auto (default)
                                    ,@ALL bit = 0 -- all subclients
                                    ,@OnDemand bit = 0)  
AS

/****************************************************************************************
// @File: usp_CVBackup.SQL
//
// Purpose:
//   Perform Backup to CommVault
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: 4.1.0 @Action: Perform CommVault backups
//   @Date: 10/25/2012 @Author: Steve Trogub @Version: 5.0.1 @Action: QS_Joblist workaround
//   @Date: 10/25/2012 @Author: Steve Trogub @Version: 5.0.2 @Action: BUG for report output delimiter variation
//   @Date: 04/15/2013 @Author: Steve Trogub @Version: 5.0.4 @Action: Added user defined operation timeout feature dbsDatabaseCVTimeoutMinutes
//   @Date: 06/15/2013 @Author: Steve Trogub @Version: 5.0.5 @Action: BRAT support ( 3 new ways to backup to CommVault )
//   @Date: 02/05/2014 @Auther: Andrew Calvett @Version: 5.0.10 @Action: Grouped subclient support to enable multiple backup "streams" 
//	 *** requires BRAT 11.3.3
//   @Date: 12/06/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta
//   @Date: 02/09/2014 @Author: Chris Basson @Version: 6.0.0.5 @Action: TRRv3 Beta
//   @Date: 08/09/2014 @Author: Chris Basson @Version: 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 02/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 17/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 20/11/2014 @Author: Chris Basson @Version: 6.0.0.12 @Action: TRRv3 Beta
//   @Date: 06/07/2015 @Author: Chris Basson @Version: 6.0.0.35 @Action: Workaround: TRRv2: Incrementals not occuring if > 1 retention period per instance
//   @Date: 29/09/2015 @Author: Chris Basson @Version: 6.0.0.38 @Action: Bugfix: reset dbsDatabaseBackup flags 

****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE	@count int 
	,@counter int
	,@clu nvarchar(30)
	,@CVClient nvarchar(128)
	,@CVFQDNCommCell nvarchar(100)
	,@CVInstance nvarchar(128)
	,@CVStoragePolicy nvarchar(512)
	,@CVTRRurl nvarchar(256)
	,@dbsDatabaseUID uniqueidentifier
	,@dbsDatabaseIsSystemObjectFlag bit
	,@dbsInstanceFileLocation nvarchar(127)
	,@dbsize nvarchar(255)
	,@dbsTranPresent int
	,@DefaultWaitDelay char(8)
	,@fail bit
	,@filelength int
	,@FoundJobID int
	,@IsClustered bit
	,@isJobFailed int
	,@jobID nvarchar(30)
	,@JobStatus int
	,@jobTimeout nvarchar(8)
	,@message nvarchar(383)
	,@OndemandFile nvarchar(255)
	,@OperationStartTime datetime
	,@Pos int
	,@PosPrev int
	,@RC int
	,@response nvarchar(max)
	,@rstring nvarchar(128)
	,@BRATCmd nvarchar(max)
	,@SQL nvarchar(max)
	,@SubclientVerified int
	,@tempString nvarchar(max)
	,@Type varchar(15)
	,@UTCDate datetime
	,@UTCoffset int
	,@CV_SubclientGroupingType tinyint
	,@CV_SubclientGroupingNumGroups tinyint
	,@dbsBackupProcessor tinyint
	,@stdmsg varchar(127)
    ,@dbsDatabaseFullBackupStartTime char(5)
    ,@dbsDatabaseLogBackupStartTime char(5)
	,@dbsDatabaseLogBackupIntervalMinute tinyint

--------------------------------------------------------------------------------------
-- Constants
                                                        
--identify Locale
-- convert local date to utc date
SET @UTCDate = DATEADD(Hour, DATEDIFF(Hour, GETUTCDATE(), GETDATE()), GETDATE())
-- convert utc date to local date
SET @UTCoffset = CAST(DATEDIFF(Hour, GETUTCDATE(), GETDATE()) as int)

SET @message =''
SET @stdmsg = ' (note Subclient names are case sensitive); EXEC DBServices..usp_Help_BackupMethod and try again.'

-- SET @DBName = RTRIM(LTRIM(@DBName)) - Bugfix - do not trim DBName
IF @DBName = ''  
	SET @DBName = NULL -- set empty string to NULL

SET @CVSubClient = RTRIM(LTRIM(@CVSubClient)) 
IF @CVSubClient = ''  
	SET @CVSubClient = NULL -- set empty string to NULL

SET @BackupType = ISNULL(@BackupType, 20) -- default 20 = auto
SET @ALL = ISNULL(@ALL, 0) 
SET @OnDemand = ISNULL(@OnDemand, 0)
SET @OperationStartTime = getdate()

--------------------------------------------------------------------------------------
-- Input param Checks

SET @fail = 0

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT

--Basic dbsBackupProcessor checks
IF @dbsBackupProcessor NOT IN (4,5) 
BEGIN 
	SELECT @stdmsg = dbsDatabaseBackupProcessorName 
	FROM [DBServices].[dbo].dbsDatabaseBackupProcessor 
	WHERE dbsDatabaseBackupProcessorID = @dbsBackupProcessor

	PRINT 'UBSMWE is configured with a backup processor of ' + CAST (@dbsBackupProcessor as char(1)) + ' - ' + @stdmsg
	PRINT 'To proceed with a CommVault backup UBSMWE needs to be configured with a dbsBackupProcessor value of 4 or 5'
	PRINT 'Please see the UBSMWE installation guide for more info.'
	GOTO END_IT
END 

IF @ALL = 1 
	AND (@DBName IS NOT NULL OR @CVSubClient IS NOT NULL)
BEGIN -- @ALL conflict -------------------

	PRINT 'Conflicting parameters - @ALL=1 cannot specified with a database name nor Subclient name. This parameter is for backuping all DBs - use with caution!'
	GOTO END_IT
END --------------------
ELSE 
IF @ALL <> 1
	AND @DBName IS NULL
	AND @CVSubClient IS NULL  
BEGIN -- Missing params -------------------

	PRINT 'Either a Database or Subclient name needs to be specified. Note these are case sensitive.'
	GOTO END_IT
END --------------------
ELSE 
IF @DBName IS NOT NULL 
BEGIN -- Backup using DBName param -------------------

	SET @dbsDatabaseUID = NULL

	SELECT TOP 1 @dbsDatabaseUID = dbsDatabaseUID
	FROM [DBServices].[dbo].[dbsDatabase] db
	WHERE db.dbsDatabaseIsActive = 1
		AND db.dbsDatabaseName = @DBName
	
	IF 	@dbsDatabaseUID IS NULL
	BEGIN
		SET @message = 'The DB ' + @DBName + ' could not be identified; it may be inactive ' + @stdmsg
		SET @fail = 1
		GOTO HANDLE_ERROR
	END --------------------
	ELSE	-- DB appears active - get Subclient
	BEGIN
		SET @CVSubClient = DBServices.dbo.ufn_CV_SubclientforDB (@DBName) 
		IF ISNULL(@CVSubClient,'')=''
		BEGIN
			SET @message = 'The Subclient for DB ' + @DBName + ' could not be identified ' + @stdmsg
			SET @fail = 1
			GOTO HANDLE_ERROR
		END
	END
END --------------------
ELSE 
IF @CVSubClient IS NOT NULL -- Only a Subclient given
BEGIN -- Backup using CVSubClient param -------------------

	-- note input parameter not derived
	-- Determine if an active DB exists within the given Subclient
	SELECT TOP 1 @dbsDatabaseUID = dbsD.dbsDatabaseUID
				,@DBName = dbsD.dbsDatabaseName
	FROM [DBServices].[dbo].[dbsDatabase] dbsD
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
		ON dbsSubDB.[dbsDatabaseUID] = dbsD.[dbsDatabaseUID]
	WHERE dbsD.dbsDatabaseIsActive = 1
		AND dbsSubDB.dbsSubclientName = @CVSubClient
	ORDER BY dbsD.dbsDatabaseEntryDate DESC

	IF 	@dbsDatabaseUID IS NULL
	BEGIN
		SET @message = 'The Subclient specified either does not exists or contains no active databases.' + @stdmsg
		SET @fail = 1
		GOTO HANDLE_ERROR
	END
	ELSE
		SET @OnDemand = 0	-- In case user incorrectly specifies 1
END

IF @OnDemand = 1 
	AND @BackupType <> 0
BEGIN
	SET @message = 'Due to a CommVault limitation; OnDemand backups can only be of type FULL (@BackupType=0) - unable to proceed' 
	SET @fail = 1
	GOTO HANDLE_ERROR
END

IF @dbsBackupProcessor = 5
BEGIN
	PRINT '*********************************************************************************************'
	PRINT 'CV Scheduled backups identified:' + CHAR(13)

	IF @BackupType = 1
	BEGIN
		PRINT '=> Please note Ad-hoc TLog backups are currently NOT possible in TRRv3!' + CHAR(13)
		PRINT '   WARNING - manually taking a tlog dump outside of CV will break the DBs backup chain' + CHAR(13)
		PRINT '*********************************************************************************************'
		GOTO END_IT
	END --------------------
	ELSE
	IF @BackupType = 3
	BEGIN
		PRINT '=> Proceeding to de-stage TLog file dumps freeing up disk space.' + CHAR(13)
		PRINT '*********************************************************************************************'
	END
END
ELSE 
IF @dbsBackupProcessor <> 5
	AND @BackupType = 3
BEGIN
	PRINT 'The parameter @BackupType = 3 is only applicable for CV Scheduled backups - unable to proceed' + CHAR(13)
	GOTO END_IT
END

--------------------------------------------------------------------------------------
-- Determine UBSMWE config
                                                  
SET @DefaultWaitDelay = '00:00:30'
SET @count = 0
SET @filelength = 8
SET @clu = ''

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupStartTime', @dbsDatabaseLogBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupIntervalMinute', @dbsDatabaseLogBackupIntervalMinute OUTPUT

--load configuration values
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

--get CV details
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVTRRurl', @CVTRRurl OUTPUT
	SET @CVTRRurl=LTRIM(RTRIM(@CVTRRurl))

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT
SET @CVFQDNCommCell=LTRIM(RTRIM(@CVFQDNCommCell))

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_SubclientGroupingType', @CV_SubclientGroupingType OUTPUT
IF @CV_SubclientGroupingType IS NULL
	SET @CV_SubclientGroupingType = 0
	
IF @CV_SubclientGroupingType > 0	-- Configured for GROUP Subclients - get num of groups
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_SubclientGroupingNumGroups', @CV_SubclientGroupingNumGroups OUTPUT

-- get host details
EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 

SET @clu = '&clu=' + @CVClient

PRINT 'Instance: ' + @CVInstance
PRINT 'Client: ' + @CVClient 

SET @Type = CASE
				WHEN @BackupType = 0 THEN 'full' -- Full Backup
				WHEN @BackupType = 1 THEN 'log' -- Tlog backup
				WHEN @BackupType = 2 THEN 'incremental' -- Differential backup
				WHEN @BackupType = 3 THEN 'log' -- CV TLog de-stage
				ELSE 'auto' -- CV auto detect full or incremental
			END

IF (@ALL = 1) 
	OR @CV_SubclientGroupingType IN (1,2)
BEGIN
	SELECT @dbsTranPresent = COUNT(dbsD.[dbsDatabaseUID])	   
	FROM [DBServices].[dbo].[dbsDatabase] dbsD
	INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB
		ON dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
		ON dbsSubDB.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	WHERE dbsD.dbsDatabaseIsActive = 1 
		AND dbsSubDB.dbsSubclientName LIKE '%TRANSACTIONAL' 
END --------------------
ELSE
IF @OnDemand = 0
BEGIN
	PRINT '--------------------------------------------------------------------------------------'
	PRINT 'CV Ad-Hoc scope: DBs within Subclient: ' + @CVSubClient + CHAR(13)

	SELECT DISTINCT dbsD.dbsDatabaseName as 'DBName'
	FROM [DBServices].[dbo].[dbsDatabase] dbsD
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
		ON dbsSubDB.[dbsDatabaseUID] = dbsD.[dbsDatabaseUID]
	WHERE dbsD.dbsDatabaseIsActive = 1
		AND dbsSubDB.dbsSubclientName = @CVSubClient
	ORDER BY dbsD.dbsDatabaseName DESC

	PRINT '--------------------------------------------------------------------------------------'
END

--------------------------------------------------------------------------------------
-- Pre-requisites check

-- DBName Check:

IF @ALL <> 1
	AND LEN(@DBName) > 0
BEGIN
	--check if the database specified actually exist on the instance
	IF LEN(@DBName) > 60 
		PRINT 'WARNING: DB name ' + @DBName 
			+ ' is over 60 characters in length - consequently its name will appear truncated by CV'

	IF NOT EXISTS (SELECT 1
				FROM master.dbo.sysdatabases
				WHERE ('[' + [name] + ']' = @DBName  
					OR [name] = @DBName))
	BEGIN
		SET @message = 'Unable to action ' + @DBName
			 + ' as it cannot be found in the instance specified - Please verify the input parameters'
		SET @fail = 1
		GOTO HANDLE_ERROR
	END

	SELECT @SQL = N'SELECT @intTableCount=COUNT(*) 
		FROM [' + @DBName + '].sys.database_files 
		WHERE state > 0'

	EXEC sp_executesql @SQL, N'@intTableCount int OUTPUT', @RC OUTPUT

	IF @RC > 0
	BEGIN
		SET @message =  'Unable to action due to the database state. One of more Filegroups are offline.'
		SET @fail = 1
		GOTO HANDLE_ERROR
	END --------------------
	ELSE
		PRINT 'OK - Database ['+ @DBName +'] is online.'
END --------------------


CHECK_ASM: 

--check if cv_cmdshell exists
IF NOT EXISTS (SELECT 1 FROM [DBServices].[sys].[objects] WHERE type = 'PC' AND name = 'cv_cmdshell')
BEGIN
    SET @message =  '[DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1'
	SET @fail = 1
	GOTO HANDLE_ERROR
END

--------------------------------------------------------------------------------------
-- Additional Subclient Checks then branch

SET @SubclientVerified = 0

IF @ALL = 1 
	GOTO BACKUPALL

-------------------
IF @OnDemand = 1   -- ONDEMAND Subclient
	AND (CHARINDEX(LEFT(@DBName,60), @CVSubClient) = 0) -- Not single
BEGIN 
	IF EXISTS(SELECT 1
		FROM [DBServices].[dbo].[dbsCVSubclients] sc
		WHERE sc.dbsDatabaseUID = @dbsDatabaseUID 
			AND sc.dbsSubclientName = @CVSubClient
			AND sc.dbsDatabaseIsOndemandFlag = 0)
			-- Steve's weird logic dbsDatabaseIsOndemandFlag = 0 means a DB requires the BRAT OnDemand param to be passed!
	BEGIN
		PRINT 'Subclient ' + @CVSubClient + ' identified.'
		SET @SubclientVerified = 1

		GOTO OnDemand_Handler
	END
	ELSE --error
		SET @message = 'OnDemand' 
END -------------------
ELSE 
IF (CHARINDEX(LEFT(@DBName,60), @CVSubClient) > 0)
BEGIN -- SINGLE Subclient
	IF EXISTS(SELECT 1
				FROM [DBServices].[dbo].[dbsCVSubclients] sc
				WHERE sc.dbsDatabaseUID = @dbsDatabaseUID 
					AND sc.dbsSubclientName = @CVSubClient
					AND dbsDatabaseIsOndemandFlag = 1) 
				-- Steve's weird logic - when set to 1 the BRAT OnDemand option NOT required
	BEGIN
		PRINT 'SINGLE Subclient ' + @CVSubClient + ' identified.'
		
		SET @OnDemand = 0
		SET @SubclientVerified = 1
		GOTO NotGroupNotAll_Do
	END
	ELSE --error
		SET @message = 'A SINGLE'
END -------------------
ELSE 
IF @CV_SubclientGroupingType IN (1,2)
	AND (CHARINDEX('GROUP',@CVSubClient) > 0)
BEGIN  -- GROUP Subclient 
	IF EXISTS (SELECT 1
                FROM [DBServices].[dbo].[dbsDatabase] dbsD
				INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
					ON dbsSubDB.[dbsDatabaseUID] = dbsD.[dbsDatabaseUID]
                WHERE dbsD.dbsDatabaseIsActive = 1 
					AND dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]')
	BEGIN    
		PRINT 'GROUP Subclient ' + @CVSubClient + ' identified.'

		SET @OnDemand = 0
		SET @SubclientVerified = 1
		GOTO GROUP_Subclient_Handler
	END
	ELSE --error
		SET @message = 'A GROUP'
END -------------------
ELSE
BEGIN -- NOT OnDemand, SINGLE nor GROUP

	IF EXISTS(SELECT 1
				FROM [DBServices].[dbo].[dbsCVSubclients] sc
				WHERE sc.dbsDatabaseUID = @dbsDatabaseUID 
					AND sc.dbsSubclientName = @CVSubClient) 
	BEGIN
		IF @BackupType <> 3
		BEGIN
			PRINT 'UBSMWE is configured for CommVault Scheduled backups; Please be aware Ad-Hoc type backups are performed at SUBCLIENT LEVEL!' 
			PRINT 'Consequently all DBs within Subclient ' + @CVSubClient + ' including DB ' + @DBName + ' will be backed up'
		END

		SET @SubclientVerified = 1
		GOTO NotGroupNotAll_Do
	END
	ELSE --error
		SET @message = @CVSubClient 
END -------------------

SubClient_Not_Found:
IF @SubclientVerified <> 1 OR @CVSubClient = 'Subclient_not_found'
BEGIN
	SET @message = @message + ' Subclient verification error - a action is not possible.' + @stdmsg
	SET @fail=1
	GOTO HANDLE_ERROR
END

--------------------------------------------------------------------------------------
-- OnDemand handler

OnDemand_Handler:

IF @OnDemand = 1 
BEGIN 
	IF NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
		SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

	SET @rstring=''

	EXEC dbo.usp_Gen_rnd_filename N'_CVBackup', @rstring OUTPUT

	SET @OndemandFile = @dbsInstanceFileLocation + @rstring 

	--write ondemand file to disk for passing the parameter.
	EXEC @RC = [dbo].[usp_Createtxtfile] 
				@FileName = @OndemandFile
				,@Contents = @DBName
    IF @RC <> 0
    BEGIN
		PRINT 'Unable to create OnDemand file ' + @OndemandFile
		SET @fail=1
		GOTO HANDLE_ERROR
    END --------------------
	ELSE
		PRINT 'OnDemand file ' + @OndemandFile + ' created successfully'
END        		
                    
--------------------------------------------------------------------------------------
-- DO Backup

IF @ALL <> 1 
	GOTO NotGroupNotAll_Do

BACKUPALL:

IF @ALL = 1
BEGIN

	IF EXISTS(SELECT TOP 1 1
			FROM [DBServices].[dbo].[dbsCVSubclients] sub
			INNER JOIN [DBServices].[dbo].[dbsDatabase] db
				ON sub.dbsDatabaseUID = db.dbsDatabaseUID
			WHERE db.dbsDatabaseIsActive = 1 
				AND sub.dbsDatabaseIsOndemandFlag = 0
				AND (sub.dbsSubclientName LIKE '%_SQL_TRANSACTIONAL'
					OR sub.dbsSubclientName LIKE '%_SQL_SIMPLE'
					OR sub.dbsSubclientName LIKE '%_SQL_GROUP[0-9]') )
	BEGIN
		PRINT 'OK - Subclient(s): SIMPLE/TRANSACTIONAL/GROUP identified.'
		SET @SubclientVerified = 1
	END --------------------
	ELSE -- Fail
	BEGIN
		SET @message = '=> No databases found within a Subclient of type SIMPLE/TRANSACTIONAL/GROUP; unable to proceed'

		SET @fail=1
		GOTO HANDLE_ERROR
	END

	IF ISNULL(@CVSubClient,'') = ''
	BEGIN
		SELECT TOP 1 @CVSubClient = sub.dbsSubclientName
		FROM [DBServices].[dbo].[dbsCVSubclients] sub
		INNER JOIN [DBServices].[dbo].[dbsDatabase] db
			ON sub.dbsDatabaseUID = db.dbsDatabaseUID
		WHERE db.dbsDatabaseIsActive = 1 
			AND sub.dbsDatabaseIsOndemandFlag = 0
			AND sub.dbsSubclientName LIKE '%_SQL_GROUP[0-9]'
	END

	--Applying the different grouping rules can get a little messy and we want to keep the original logic available so we can flick it on and off easily so
	--Subclient Grouping type 0 is the original. 1 & 2 will be handled in usp_CVGroupedBackup proc which duplicates some of the logic below.

	IF @CV_SubclientGroupingType <> 0 
		AND @CVSubClient IS NOT NULL  
	BEGIN
		SET @OnDemand = 0	-- bugfix: On demand flag requires a value of 0 for GROUP subclients 
		GOTO GROUP_Subclient_Handler
	END --------------------
	ELSE 
	BEGIN
		SET @CV_SubclientGroupingType = 0 -- overrules MWE config in case GROUP subclient is empty

		--This goes here with the old logic because GROUP subclient can have simple mode db's so we do this check differently in the grouped proc
		IF @dbsTranPresent < 1 AND @BackupType IN (1,3)
		BEGIN
			SET @message = 'There are no databases in a TRANSACTIONAL type Subclient - skipping....'
			GOTO END_TIDY
		END --------------------
		ELSE
		IF @dbsTranPresent > 0 AND @BackupType IN (1,3)
			GOTO ALL_TRANSACTIONAL


		--------------------
		--Backup SIMPLE

		--set backup status
		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInFullBackupProcess = 1
		WHERE dbsDatabaseUID IN (
				SELECT DISTINCT dbsDatabaseUID
				FROM DBServices.dbo.dbsCVSubclients
				WHERE dbsSubclientName LIKE '%SQL_SIMPLE')

		--------------------
		-- Compile BRAT cmd

		SET @BRATCmd = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "'
				+ @CVInstance + '" -subclient SIMPLE -shortNames' 

		IF @BackupType IN (0,2)
			SET @BRATCmd = @BRATCmd + ' -level ' + @Type 
		-- else 'auto'
		
		SET @BRATCmd = @BRATCmd + ' -cs "' + @CVFQDNCommCell + '"'

		--Note BRAT 'ALL' option cannot be used as it backups up single subclients as well.
		PRINT @BRATCmd

		EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
						@input = @BRATCmd,
						@response = @response OUTPUT

		PRINT '-----------SIMPLE BACKUP EXIT STATUS------------------'
		PRINT @response 
		PRINT '--------------------------------------------------------------------'

		IF (CHARINDEX('FAIL',UPPER(@response))) <> 0 
			OR (CHARINDEX('CVFATAL',UPPER(@response))) <> 0
			OR (CHARINDEX('Data Management activity on CommServe is disabled',@response)) <> 0
		BEGIN
			SET @message = 'SIMPLE/TRANSACTIONAL Subclient action failed! ' + @response + ' [' + CONVERT(nvarchar,@RC) + ']'
			SET @fail=1

			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 0
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE')

			GOTO HANDLE_ERROR
		END --------------------
		ELSE -- set dbsDBDoFullBackupNow flag = 0 for SIMPLE Subclient DBs
			UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
			SET dbsDBLastFullBackupRun = getdate()
				,dbsDBIsInFullBackupProcess = 0
				,dbsDBDoFullBackupNow = 0
				,dbsDBDoLogBackupNow = 0
				,dbsDBNextFullBackupRun = DATEADD (day, 1,
													(CONVERT(DATETIME,
														(CONVERT(char(4),DATEPART(year,getdate()))
															+ '-'  + CONVERT(char(2), DATEPART(month,getdate()))
															+ '-'  + CONVERT(char(2), DATEPART(day, getdate()))
															+ ' ' + @dbsDatabaseFullBackupStartTime))
													) )
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE')
		        
		--------------------
		ALL_TRANSACTIONAL:              

		--Backup TRANSACTIONAL
		IF @dbsTranPresent > 0
		BEGIN

			--set backup status
			IF @BackupType IN (0,2,20) -- full
				UPDATE [DBServices].[dbo].dbsDatabaseBackup
				SET dbsDBIsInFullBackupProcess = 1
				WHERE dbsDatabaseUID IN (
						SELECT DISTINCT dbsDatabaseUID
						FROM DBServices.dbo.dbsCVSubclients
						WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
			ELSE --------------------
			IF @BackupType IN (1,3)	-- tlog
				UPDATE [DBServices].[dbo].dbsDatabaseBackup
				SET dbsDBIsInLogBackupProcess = 1
				WHERE dbsDatabaseUID IN (
						SELECT DISTINCT dbsDatabaseUID
						FROM DBServices.dbo.dbsCVSubclients
						WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
			
			--------------------
			-- Compile BRAT cmd

			SET @BRATCmd = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "'
				+ @CVInstance + '" -subclient TRANSACTIONAL -shortNames'

			IF @BackupType IN (0,1,2,3)
				SET @BRATCmd = @BRATCmd + ' -level ' + @Type 
			
			SET @BRATCmd = @BRATCmd + ' -cs "' + @CVFQDNCommCell + '"' 

			PRINT @BRATCmd

			EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
							@input = @BRATCmd,
							@response = @response OUTPUT

			PRINT '-----------TRANSACTIONAL BACKUP EXIT STATUS-----------'
			PRINT @response 
			PRINT '------------------------------------------------------'

			IF (CHARINDEX('FAIL',UPPER(@response))) <> 0
				OR (CHARINDEX('CVFATAL',UPPER(@response))) <> 0
				OR (CHARINDEX('Data Management activity on CommServe is disabled',@response)) <> 0
			BEGIN
				SET @message = 'TRANSACTIONAL Subclient action	! ' 
						+ @response + ' [' + CONVERT(nvarchar,@RC) + ']'
				SET @fail=1

				-- Reset backup status flags
				IF @BackupType IN (0,2,20)
					UPDATE [DBServices].[dbo].dbsDatabaseBackup
					SET dbsDBIsInFullBackupProcess = 0
					WHERE dbsDatabaseUID IN (
							SELECT DISTINCT dbsDatabaseUID
							FROM DBServices.dbo.dbsCVSubclients
							WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
				ELSE --------------------
				IF @BackupType IN (1,3)
					UPDATE [DBServices].[dbo].dbsDatabaseBackup
					SET dbsDBIsInLogBackupProcess = 0
					WHERE dbsDatabaseUID IN (
							SELECT DISTINCT dbsDatabaseUID
							FROM DBServices.dbo.dbsCVSubclients
							WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')

				GOTO HANDLE_ERROR
			END --------------------
			ELSE  -- set backup status flags for TRANSACTIONAL Subclient DBs
			BEGIN
				IF @BackupType IN (0,2,20)	-- full
					UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
					SET dbsDBLastFullBackupRun = getdate()
						,dbsDBIsInFullBackupProcess = 0
						,dbsDBDoFullBackupNow = 0
						,dbsDBNextFullBackupRun =DATEADD (day, 1,
															(CONVERT(DATETIME,
																(CONVERT(char(4),DATEPART(year,getdate()))
																	+ '-'  + CONVERT(char(2), DATEPART(month,getdate()))
																	+ '-'  + CONVERT(char(2), DATEPART(day, getdate()))
																	+ ' ' + @dbsDatabaseFullBackupStartTime))
													) )
					WHERE dbsDatabaseUID IN (
							SELECT DISTINCT dbsDatabaseUID
							FROM DBServices.dbo.dbsCVSubclients
							WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
				ELSE --------------------
				IF @BackupType IN (1,3)	-- tlog
					UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
					SET dbsDBLastLogBackupRun = getdate(),
						dbsDBIsInLogBackupProcess = 0,
						dbsDBDoLogBackupNow = 0,
						dbsDBNextLogBackupRun = DATEADD( minute, @dbsDatabaseLogBackupIntervalMinute, getdate())
					WHERE dbsDatabaseUID IN (
							SELECT DISTINCT dbsDatabaseUID
							FROM DBServices.dbo.dbsCVSubclients
							WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
			END

		END --------------------
		ELSE
			SET @message = 'There are no databases in the TRANSACTIONAL type Subclient - skipping.....'

		GOTO END_TIDY
	END

	IF @fail = 0
		GOTO END_TIDY 
	ELSE -- @fail = 1 
		GOTO HANDLE_ERROR

END --BACKUPALL

--------------------------------------------------------------------------------------

GROUP_Subclient_Handler:

IF @CV_SubclientGroupingType IN (1,2) 
	AND @OnDemand = 0
	AND (CHARINDEX('GROUP', @CVSubClient) > 0)
BEGIN
	/*
	CV_SubclientGroupingType:
	0 = Default, no grouping will be performed
	1 = Transactional & simple backups will launch concurrently
	2 = GROUP subclients run with a configured degree of concurrency (default 4). Any transactional & simple subclients run after

	CV_SubclientGroupingNumGroups:
	4 = Default Value can be between 2 & 8 and represents the number of groups that will backup concurrently.
	*/
	-- MWE 5.0.10

	EXEC @RC = [DBServices].[dbo].[usp_CVBackupGrouped]
			 @BackupType = @BackupType
			,@CVFQDNCommCell = @CVFQDNCommCell
			,@CVInstance = @CVInstance
			,@dbsTranPresent = @dbsTranPresent 
			,@fail = @fail OUTPUT 
			,@Type = @Type 
			,@CV_SubclientGroupingType = @CV_SubclientGroupingType
			,@CV_SubclientGroupingNumGroups = @CV_SubclientGroupingNumGroups

	IF @RC = 0 AND @fail = 0
		-- GROUP Backup OK
		GOTO END_TIDY 
	ELSE --------------------
	BEGIN
		SET @message = 'Unhandled exception error in DBServices..usp_CVBackupGrouped'
		GOTO HANDLE_ERROR
	END
END --------------------
ELSE
BEGIN
	SET @message = 'UBSMWE configured for GROUP backups (CV_SubclientGroupingType=' + CAST(@CV_SubclientGroupingType as char(1))
		+ ') - however no GROUP type Subclients containing active databases found - retrying as a normal backup'
	EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1 -- Info

	SET @CV_SubclientGroupingType = 0
	GOTO BACKUPALL
END	

--------------------------------------------------------------------------------------

--Backup Non GROUP AND @ALL <> 0
NotGroupNotAll_Do:

--------------------
-- Compile BRAT cmd

SET @BRATCmd = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "' + @CVInstance

IF @OnDemand = 1
	IF @BackupType <> 0
	BEGIN
		SET @message = 'Only FULL backups (@BackupType=0) can be performed with the parameter @OnDemand=1, unable to proceed'
		GOTO END_IT
	END --------------------
	ELSE -- Single FULL OnDemand backup
		SET @BRATCmd = @BRATCmd + '" -subclient ONDEMAND -ondemandinputfile ' + @OndemandFile 
ELSE --------------------
BEGIN -- Ad-hoc backup

	--set backup status
	IF @BackupType IN (0,2,20) -- full
		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInFullBackupProcess = 1
		WHERE dbsDatabaseUID IN (
				SELECT DISTINCT dbsDatabaseUID
				FROM DBServices.dbo.dbsCVSubclients
				WHERE dbsSubclientName = @CVSubClient)
	ELSE --------------------
	IF @BackupType IN (1,3)	-- tlog
		UPDATE [DBServices].[dbo].dbsDatabaseBackup
		SET dbsDBIsInLogBackupProcess = 1
		WHERE dbsDatabaseUID IN (
				SELECT DISTINCT dbsDatabaseUID
				FROM DBServices.dbo.dbsCVSubclients
				WHERE dbsSubclientName = @CVSubClient)

	-- Backup entire Subclient
	SET @BRATCmd = @BRATCmd + '" -subclient ' + @CVSubClient 

	IF @BackupType IN (0,1,2,3) 
		SET @BRATCmd = @BRATCmd + ' -level ' + @Type 
	-- else auto
END

-- Finally append CommCell: 
SET @BRATCmd = @BRATCmd + ' -cs "' + @CVFQDNCommCell + '"'

PRINT @BRATCmd

EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
	@input = @BRATCmd,
	@response = @response OUTPUT

PRINT '----------------------------------'
PRINT @response 
PRINT '----------------------------------'

IF (CHARINDEX('FAIL',UPPER(@response))) <> 0
	OR (CHARINDEX('CVFATAL',UPPER(@response))) <> 0
	OR (CHARINDEX('Data Management activity on CommServe is disabled',@response)) <> 0
	OR (CHARINDEX('Another backup',@response)) <> 0
BEGIN
                
	IF (CHARINDEX('Another backup',@response)) <> 0
		SET @message = 'Another backup is in progress. Please wait until this operation completes before starting new operations for this database. ' + @response
	ELSE
		SET @message = 'CV Backup has Failed: ' + @response

    SET @fail=1

	IF @OnDemand <> 1 
	BEGIN
		--reset backup status
		IF @BackupType IN (0,2,20) -- full
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 0
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName = @CVSubClient)
		ELSE --------------------
		IF @BackupType IN (1,3)	-- tlog
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInLogBackupProcess = 0
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName = @CVSubClient)
	END

    GOTO HANDLE_ERROR
END --------------------
ELSE
IF @OnDemand <> 1 
BEGIN -- Set backup status flags

	IF @BackupType IN (0,2,20)	-- full
		UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
		SET dbsDBLastFullBackupRun = getdate()
			,dbsDBIsInFullBackupProcess = 0
			,dbsDBDoFullBackupNow = 0
			,dbsDBNextFullBackupRun =DATEADD (day, 1,
												(CONVERT(DATETIME,
													(CONVERT(char(4),DATEPART(year,getdate()))
														+ '-'  + CONVERT(char(2), DATEPART(month,getdate()))
														+ '-'  + CONVERT(char(2), DATEPART(day, getdate()))
														+ ' ' + @dbsDatabaseFullBackupStartTime))
										) )
		WHERE dbsDatabaseUID IN (
				SELECT DISTINCT dbsDatabaseUID
				FROM DBServices.dbo.dbsCVSubclients
				WHERE dbsSubclientName = @CVSubClient)
	ELSE --------------------
	IF @BackupType IN (1,3)	-- tlog
		UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
		SET dbsDBLastLogBackupRun = getdate(),
			dbsDBIsInLogBackupProcess = 0,
			dbsDBDoLogBackupNow = 0,
			dbsDBNextLogBackupRun = DATEADD(minute, @dbsDatabaseLogBackupIntervalMinute, getdate())
		WHERE dbsDatabaseUID IN (
				SELECT DISTINCT dbsDatabaseUID
				FROM DBServices.dbo.dbsCVSubclients
				WHERE dbsSubclientName = @CVSubClient)
END --------------------

--remove any extra characters from JobID string
SET @Pos = 1;
SET @PosPrev = @Pos;
SET @FoundJobID = 0

WHILE 1=1
BEGIN
	SET @Pos = CHARINDEX(' ' , @response, @PosPrev);
	IF @Pos = 0
		BREAK -- exit loop

	SET @tempString = UPPER(
						REPLACE(
							REPLACE(
								SUBSTRING(@response, @PosPrev, @Pos-@PosPrev)
							, CHAR(13),'')
						, CHAR(32),'') )             

	IF @FoundJobID = 1
	BEGIN
		SET @jobID = @tempString
		SET @FoundJobID = 0        
	END
                                  
	IF 'JOB' = UPPER(@tempString)
		SET @FoundJobID = 1
                                
	SET  @PosPrev = @Pos+1;
END

PRINT  'Queued Job: [' + @jobID + ']'

-----------------------------------------------------------

HANDLE_ERROR:

--record backup statistics                        
IF @fail <> 1 
	AND OBJECT_ID('tempdb..#CV_RECORDS') IS NOT NULL 
BEGIN
	INSERT INTO [DBServices].[dbo].[dbsCVbackupStatus] ([dbsCVbackupJobId]
		, [dbsCVBackupSetId]
		, [dbsCVbackupDatabase]
		, [dbsCVbackupType]
		, [dbsCVbackupTotalSize]
		, [dbsCVbackupStartTime]
		, [dbsCVbackupEndTime]
		, [BackupMethod]
		, [dbsCVbackupPolicy]
		, [dbsCVbackupStatus])
	SELECT @jobID
		, backup_set_id
		, DatabaseName
		, BackupType
		, backup_size
		, backup_start_date
		, backup_finish_date
		, BackupMethod
		, @CVStoragePolicy
		, @isJobFailed
	FROM #CV_RECORDS

END
ELSE -- ExitWithNoReport:
BEGIN
	INSERT INTO [DBServices].[dbo].[dbsCVbackupStatus] 
		([dbsCVbackupJobId]
		, [dbsCVBackupSetId]
		, [dbsCVbackupDatabase]
		, [dbsCVbackupType]
		, [dbsCVbackupTotalSize]
		, [dbsCVbackupStartTime]
		, [dbsCVbackupEndTime]
		, [BackupMethod]
		, [dbsCVbackupPolicy]
		, [dbsCVbackupStatus])
	VALUES ( @jobID, '','','','','','','', @CVStoragePolicy, @isJobFailed)
END

GOTO END_TIDY

---------------------
END_IT:

PRINT 'Usage: EXEC [dbo].[usp_CVBackup] (
								@DBName			-- Single DB to backup
								,@CVSubClient	-- Note DBName takes precedence over Subclient
                                ,@BackupType	-- 0 = Full, 1 = TLog, 2 = Incremental, 3 CV Tlog de-stage, 20 Auto
                                ,@ALL			-- 1 = Backup all Subclients for instance 
                                ,@OnDemand)		-- 1 = Single DB OnDemand backup for SIMPLE, TRANSACTIONAL or GROUP Subclients (Full only; @BackupType=0)'
---------------------
END_TIDY:

-- return status

-- Note Log both success and failure

IF @BackupType = 3
	SET @Type = 'Tlog de-stage'

SET @tempString = CHAR(13) + '=> Task: ' + UPPER(@Type)
				+ ' processed in ' + CAST(DATEDIFF(second, @OperationStartTime, GETDATE()) as varchar(20) ) + ' seconds.'
PRINT @tempString

IF ISNULL(@message,'') = ''
	SET @message = CASE @fail
					WHEN 0 THEN 'Successful'
					ELSE 'Unhandled exception'
					END

SET @message = 'UBSMWE: usp_CVBackup: ' + @message

IF @fail = 0 
BEGIN -- Success
	EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1 -- Info

	-- Tidy up temp file
	EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @OndemandFile

	RETURN 0
END ---------------------
ELSE
BEGIN -- Failure
	-- Raise a hard error to force the WF job to fail

	SET @message = @message + ' - For additional details see the log file C:\TEMP\cvbackup.exe' 
					+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

	EXEC [DBServices].[dbo].[usp_LogErrors] 
			@Source = 'UBSMWE',
			@command = 'usp_CVBackup',
			@message = @message,
			@LogEvent = 1,
			@NeedAlertGenerated = 1,
			@Level = 2 -- 1 info, 2 warning, 3 Error

	RETURN 1
END

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVBackupGrouped]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVBackupGrouped] (
		 @BackupType tinyint = NULL
		,@CVFQDNCommCell nvarchar(100)
		,@CVInstance nvarchar(40)
		,@dbsTranPresent smallint
		,@fail int OUTPUT
		,@Type varchar(11) -- legacy - sp resets
		,@CV_SubclientGroupingType tinyint	-- 1 = firing SIMPLE & TRANSACTIONAL concurrently, 2 = firing the GROUP subclient
		,@CV_SubclientGroupingNumGroups tinyint)
AS

/****************************************************************************************
// @File: usp_CVBackupGrouped.SQL
//
// Purpose:
//   Initiates concurrent backups to CommVault
//
// Notes: This stored procedure is called from by UBSMWE usp_CVBackup
//
// History: Date Format dd/mm/yyyy
//
//	 @Date: 05/02/2014 @Author: Andrew Calvett @Version: 5.0.10 @Action: Grouped subclient support to enable multiple backup "streams" 
//		***	Requires BRAT 11.3.3 or above
//	 @Date: 10/02/2014 @Author: Andrew Calvett @Version: 5.0.11 @Action: Stop errors caused by calling transactional full when its empty.
//	 @Date: 02/08/2014 @Author: Chris Basson @Version: 6.0.0.5 @Action: Bugfix
//   @Date: 06/07/2015 @Author: Chris Basson @Version: 6.0.0.35 @Action: Workaround: TRRv2: Incrementals not occuring if > 1 retention period per instance
//   @Date: 24/07/2015 @Author: Chris Basson @Version: 6.0.0.36 @Action: bugfix: GROUP: SIMPLE subclient backups not occuring when CV_SubclientGroupingType = 2
//   @Date: 29/09/2015 @Author: Chris Basson @Version: 6.0.0.38 @Action: Bugfix: reset dbsDatabaseBackup flags 

****************************************************************************************/

BEGIN --Main
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE	@RC int
		,@BRATCmd1 nvarchar(max)
		,@BRATCmd2 nvarchar(max)
		,@response1 nvarchar(max)
		,@response2 nvarchar(max)
		,@dbsTranPresentGrouped smallint
		,@dbsGrpPresent smallint
		,@ErrorMsg nvarchar(383)
		,@debug tinyint
		,@dbsSimplePresent smallint
		,@dbsDatabaseFullBackupStartTime char(5)
		,@dbsDatabaseLogBackupStartTime char(5)
		,@dbsDatabaseLogBackupIntervalMinute tinyint

--------------------------------------

IF ISNULL(@BackupType, 999) NOT IN (0,1,2,20)
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVBackupGrouped: Invalid @BackupType value passed: ' + CAST(ISNULL(@BackupType, 999) as varchar(3))
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

	GOTO HANDLE_ERROR
END

--------------------------------------
-- Init Vars
	
SET @response2 = '' --Ensuring its not null

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupStartTime', @dbsDatabaseLogBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupIntervalMinute', @dbsDatabaseLogBackupIntervalMinute OUTPUT

--Backup Types... 0 = Full, 1 = Log, 2 = Diff, 20 = auto
--SubclientGrouping Types
--1 is for firing SIMPLE & TRANSACTIONAL at the same time.
--2 is for firing the GROUP subclient

--Its possible that someone might configure for group backups but there are no backups in GROUP.
--We need to detect this so we can skip firing the backup otherwise it will fail so we check here if we have any configured 
--AND use it later on.


-- Ignore passed @Type value - legacy
SET @Type = CASE
				WHEN @BackupType = 0 THEN 'full' -- Full Backup
				WHEN @BackupType = 1 THEN 'log' -- Tlog backup
				WHEN @BackupType = 2 THEN 'incremental' -- Differential backup
				ELSE 'auto' -- CV auto detect full or incremental
			END

--------------------------------------

SELECT @dbsSimplePresent = COUNT(dbsD.[dbsDatabaseUID])	   
FROM [DBServices].[dbo].[dbsDatabase] dbsD
INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
	ON dbsSubDB.[dbsDatabaseUID] = dbsD.[dbsDatabaseUID]
WHERE  
	dbsD.dbsDatabaseIsActive = 1 
	AND dbsSubDB.dbsSubclientName LIKE '%SIMPLE' 

SELECT @dbsGrpPresent = COUNT(dbsD.[dbsDatabaseUID])	   
FROM [DBServices].[dbo].[dbsDatabase] dbsD
INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
	ON dbsSubDB.[dbsDatabaseUID] = dbsD.[dbsDatabaseUID]
WHERE  
	dbsD.dbsDatabaseIsActive = 1 
	AND dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]' 

IF @dbsGrpPresent = 0
BEGIN
	SET @ErrorMsg = '*** There are no databases in the GROUP Subclient ***'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 
END

--------------------------------------
--So, we have to check if we have any databases that need transaction log backups in the GROUP
--subclient since we could have simple mode db's in a grouped subclient so grab a count for use in check further down.

IF @BackupType = 1
	AND @CV_SubclientGroupingType = 2
BEGIN	
	SELECT @dbsTranPresentGrouped = COUNT(dbsD.[dbsDatabaseUID])	   
	FROM [DBServices].[dbo].[dbsDatabase] dbsD
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
		ON dbsSubDB.[dbsDatabaseUID] = dbsD.[dbsDatabaseUID]
	WHERE dbsD.dbsDatabaseIsActive = 1 
		AND dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]' 
		AND DATABASEPROPERTYEX(dbsD.dbsDatabaseName,'Recovery') IN ('BULK_LOGGED','FULL')
END

IF @debug > 1
	PRINT 'GROUP Backup Type: ' + @Type

IF @CV_SubclientGroupingType = 1 
BEGIN

	SET @BRATCmd1 = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "' + @CVInstance

	IF @BackupType IN (0,2,20) --Full or Differentials
		SET @BRATCmd1 = @BRATCmd1 + '" -subclient SIMPLE -subclient TRANSACTIONAL -fork 2 -shortNames'
	ELSE		
	IF @dbsTranPresent > 0 AND @BackupType = 1 --Transaction log
		SET @BRATCmd1 = @BRATCmd1 + '" -subclient TRANSACTIONAL -shortNames'
	ELSE
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_CVBackupGrouped: SubclientGroupingType: 1, Type: ' + @Type
						+ ' - Nothing to do'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

		GOTO END_OK
	END

	IF @BackupType IN (0,1,2)
		SET @BRATCmd1 = @BRATCmd1 + ' -level ' + @Type

	SET @BRATCmd1 = @BRATCmd1 + ' -cs "' + @CVFQDNCommCell + '"'

	IF @BRATCmd1 IS NOT NULL
	BEGIN
		IF @BackupType IN (0,2,20)
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 1	-- fulls
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE'
						OR dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
		ELSE --------------------
		IF @BackupType = 1
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInLogBackupProcess = 1		-- tlog
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
	END
END -----------------------
ELSE 
IF @CV_SubclientGroupingType = 2
BEGIN

	IF (@CV_SubclientGroupingNumGroups IS NULL
		OR @CV_SubclientGroupingNumGroups = 0
		OR @CV_SubclientGroupingNumGroups > 8)
	BEGIN	
		SET @ErrorMsg = 'UBSMWE: usp_CVBackupGrouped: Invalid value ' + CAST(ISNULL(@CV_SubclientGroupingNumGroups,'NULL') as nvarchar(4)) 
			+ ' for number of subclient groups - Valid values are 1-8'
			+ 'EXEC DBServices..usp_ConfigureUBSMWE ''CV_SubclientGroupingNumGroups'', <VALUE> to correct this configuration issue'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

		GOTO HANDLE_ERROR
	END -----------------------

	IF @BackupType IN (0,2,20) --Full or Differentials
	BEGIN
		IF @dbsGrpPresent > 0 --Only fire if we have some db's configured.
		BEGIN
			SET @BRATCmd1 = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "' + @CVInstance 
				+ '" -subclient GROUP -fork ' + CAST(@CV_SubclientGroupingNumGroups as nvarchar(2)) 
				+  ' -shortNames' 

			IF @BackupType IN (0,2)
				SET @BRATCmd1 = @BRATCmd1 + ' -level ' + @Type

			SET @BRATCmd1 = @BRATCmd1 + ' -cs "' + @CVFQDNCommCell + '"'

			IF @BRATCmd1 IS NOT NULL
				UPDATE [DBServices].[dbo].dbsDatabaseBackup
				SET dbsDBIsInFullBackupProcess = 1	-- fulls
				WHERE dbsDatabaseUID IN (
						SELECT DISTINCT dbsDatabaseUID
						FROM DBServices.dbo.dbsCVSubclients
						WHERE dbsSubclientName LIKE '%GROUP[0-9]')

		END -----------------------
		ELSE
		BEGIN
			SET @ErrorMsg = 'There are no databases in the GROUP Subclient, skipping....'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 
		END
		
		-----------------------
		-- SIMPLE and TRANSACTIONAL Subclients concurrently if exists
		
		SET @BRATCmd2 = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "' + @CVInstance 

		IF @dbsTranPresent > 0 AND @dbsSimplePresent > 0
			SET @BRATCmd2 = @BRATCmd2 + '" -subclient SIMPLE -subclient TRANSACTIONAL -fork 2 -shortNames'
		ELSE
		IF @dbsSimplePresent > 0 
			SET @BRATCmd2 = @BRATCmd2 + '" -subclient SIMPLE -shortNames'
		ELSE 
		IF @dbsTranPresent > 0
			SET @BRATCmd2 = @BRATCmd2 + '" -subclient TRANSACTIONAL -shortNames' 
		ELSE
			SET @BRATCmd2 = NULL -- SKIP

		IF @BRATCmd2 IS NOT NULL 
		BEGIN
			IF @BackupType IN (0,2)
				SET @BRATCmd2 = @BRATCmd2 + ' -level ' + @Type

			SET @BRATCmd2 = @BRATCmd2 + ' -cs "' + @CVFQDNCommCell + '"'

			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 1	-- fulls
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE'
						OR dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
		END
	END
	ELSE -----------------------
	IF @BackupType = 1 		--hard coded t.logs to 2 as its a contentious point already.
		AND (@dbsTranPresent > 0 OR @dbsTranPresentGrouped > 0) --Transaction logs.
	BEGIN
		SET @BRATCmd1 = N'.\Brat\bin\cvbackup.exe -type mssql -instanceName "' + @CVInstance 

		IF  (@dbsTranPresent > 0 AND @dbsTranPresentGrouped > 0) --Launch both subclients
			SET @BRATCmd1 = @BRATCmd1 + '" -subclient TRANSACTIONAL -subclient GROUP -fork 2 -shortNames'
		ELSE
		IF  (@dbsTranPresent > 0 AND @dbsTranPresentGrouped < 1) --Launch just TRANSACTIONAL
			SET @BRATCmd1 = @BRATCmd1 + '" -subclient TRANSACTIONAL -shortNames'
		ELSE
		IF  (@dbsTranPresent < 1 AND @dbsTranPresentGrouped > 0) --Launch just GROUP
			SET @BRATCmd1 = @BRATCmd1 + '" -subclient GROUP -fork 2 -shortNames'

		SET @BRATCmd1 = @BRATCmd1 + ' -level ' + @Type + ' -cs "' + @CVFQDNCommCell + '"'

		IF @BRATCmd1 IS NOT NULL
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInLogBackupProcess = 1		-- tlog
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL'
						OR dbsSubclientName LIKE '%GROUP[0-9]')
	END

END -----------------------
ELSE
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVBackupGrouped: Invalid value '
		+ CAST(ISNULL(@CV_SubclientGroupingType,'NULL')as nvarchar(4))
		+ ' for grouping type. Only values 0,1,2 are valid'
		+ 'EXEC DBServices..usp_ConfigureUBSMWE ''CV_SubclientGroupingType'', <VALUE> to correct this configuration issue'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 
	
	GOTO HANDLE_ERROR
END

--------------------------------------

IF @BRATCmd1 IS NOT NULL --Would be null if nothing is in GROUP subclient but we are configured for grouping
BEGIN
	PRINT @BRATCmd1

	EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
					@input = @BRATCmd1,
					@response = @response1 OUTPUT
END

IF @CV_SubclientGroupingType = 2 
	AND ISNULL(@BackupType, 0) <> 1 --(Exclude log backups as not relevant for second cmd)
	AND @BRATCmd2 IS NOT NULL
BEGIN
	PRINT @BRATCmd2

	EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
					@input = @BRATCmd2,
					@response = @response2 OUTPUT
END

-----------------------
IF @debug > 1
BEGIN
	PRINT '-----------GROUPED BACKUP EXIT STATUS------------------'
	PRINT @response1 
	PRINT @response2
	PRINT '-------------------------------------------------------'
END

IF (CHARINDEX('FAIL',UPPER(@response1 + @response2))) <> 0 
	OR (CHARINDEX('CVFATAL',UPPER(@response1 + @response2))) <> 0
	OR (CHARINDEX('Data Management activity on CommServe is disabled',@response1 + @response2)) <> 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVBackupGrouped: GROUPED Subclient Backups have Failed! ' 
					+ @response1 + @response2 + ' [' +CONVERT(nvarchar,@RC) + ']'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 
	
	-- reset Backup status flags
	IF @CV_SubclientGroupingType = 1 
	BEGIN
		IF @BackupType IN (0,2,20)
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 0	-- fulls
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE'
						OR dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
		ELSE --------------------
		IF @BackupType = 1
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInLogBackupProcess = 0	-- tlog
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
	END -----------------------
	ELSE 
	IF @CV_SubclientGroupingType = 2 
	BEGIN
		IF @BackupType IN (0,2,20)
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInFullBackupProcess = 0	-- fulls
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE'
						OR dbsSubclientName LIKE '%SQL_TRANSACTIONAL'
						OR dbsSubclientName LIKE '%GROUP[0-9]')
		ELSE --------------------
		IF @BackupType = 1
			UPDATE [DBServices].[dbo].dbsDatabaseBackup
			SET dbsDBIsInLogBackupProcess = 0	-- tlog
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL'
						OR dbsSubclientName LIKE '%GROUP[0-9]')
	END

	GOTO HANDLE_ERROR
END -----------------------
ELSE  -- Set Backup status flags
BEGIN

	IF @CV_SubclientGroupingType = 1 
	BEGIN

		IF @BackupType IN (0,2,20)	-- full
			UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
			SET dbsDBLastFullBackupRun = getdate()
				,dbsDBIsInFullBackupProcess = 0
				,dbsDBDoFullBackupNow = 0
				,dbsDBNextFullBackupRun =DATEADD (day, 1,
													(CONVERT(DATETIME,
														(CONVERT(char(4),DATEPART(year,getdate()))
															+ '-'  + CONVERT(char(2), DATEPART(month,getdate()))
															+ '-'  + CONVERT(char(2), DATEPART(day, getdate()))
															+ ' ' + @dbsDatabaseFullBackupStartTime))
											) )
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE'
						OR dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
		ELSE --------------------
		IF @BackupType = 1	-- tlog
			UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
			SET dbsDBLastLogBackupRun = getdate(),
				dbsDBIsInLogBackupProcess = 0,
				dbsDBDoLogBackupNow = 0,
				dbsDBNextLogBackupRun = DATEADD(minute, @dbsDatabaseLogBackupIntervalMinute, getdate())
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL')
	END -----------------------
	ELSE 
	IF @CV_SubclientGroupingType = 2 
	BEGIN
		IF @BackupType IN (0,2,20)	-- full
			UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
			SET dbsDBLastFullBackupRun = getdate()
				,dbsDBIsInFullBackupProcess = 0
				,dbsDBDoFullBackupNow = 0
				,dbsDBNextFullBackupRun =DATEADD (day, 1,
													(CONVERT(DATETIME,
														(CONVERT(char(4),DATEPART(year,getdate()))
															+ '-'  + CONVERT(char(2), DATEPART(month,getdate()))
															+ '-'  + CONVERT(char(2), DATEPART(day, getdate()))
															+ ' ' + @dbsDatabaseFullBackupStartTime))
											) )
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_SIMPLE'
						OR dbsSubclientName LIKE '%SQL_TRANSACTIONAL'
						OR dbsSubclientName LIKE '%GROUP[0-9]')
		ELSE --------------------
		IF @BackupType = 1	-- tlog
			UPDATE [DBServices].[dbo].[dbsDatabaseBackup]
			SET dbsDBLastLogBackupRun = getdate(),
				dbsDBIsInLogBackupProcess = 0,
				dbsDBDoLogBackupNow = 0,
				dbsDBNextLogBackupRun = DATEADD(minute, @dbsDatabaseLogBackupIntervalMinute, getdate())
			WHERE dbsDatabaseUID IN (
					SELECT DISTINCT dbsDatabaseUID
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName LIKE '%SQL_TRANSACTIONAL'
						OR dbsSubclientName LIKE '%GROUP[0-9]')
	END
END

--------------------------------------
END_OK:

SET @fail = 0
RETURN 0

--------------------------------------
HANDLE_ERROR:

SET @fail = 1
RETURN 1

END --Main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVBRATchk]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVBRATchk] (@dbsBackupProcessor as tinyint, @init as bit = 0, @Quiet as bit = 0)
AS
/****************************************************************************************
// @File: usp_CVBRATchk.SQL
// @Version 6.0.0.31
// 
// Purpose: Verifies the BRAT version for a given @dbsBackupProcessor. 
// Returns @RC = 0 - OK, 1 = incorrect version  
//
// Notes: 
//
// History: Dates are in mm/dd/yyyy format
//
//	 @Date:	21/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.4 @Action: TRRv3 Beta 
//   @Date: 01/04/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.29 @Action: space in service account support, MSSQL 2014 support
//																				WGS3.0 create c:\temp and assign permissions
//   @Date: 29/05/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.30 @Action: minor update - remove c:\temp cacls as not required
//   @Date: 08/06/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.31 @Action: minor update - Added CV client ver lookup for ref
****************************************************************************************/

BEGIN --main
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int
		,@dbsVersion varchar(9)
		,@minMWEver varchar(9)
		,@minBRATver varchar(9)
		,@curBRATver varchar(9)
		,@SvcLogin nvarchar(127)
		,@cmdstr varchar(500)
		,@CVpath varchar(127)
		,@ErrorMsg varchar(255)
		,@astr nvarchar(500)
		,@CVClientver varchar(20)
-----------------------------
-- Init vars

SET @RC = 0

-----------------------------

IF @Quiet = 0
BEGIN
	PRINT '---------------------------------------------------'
	PRINT 'CHECK: BRAT version' 
END

IF @init = 1
BEGIN
	----------------------
	-- WGS3.0 verify c:\temp 

	SET @cmdstr = 'cd c:\temp'
	EXEC @RC = master..xp_cmdshell @cmdstr

	IF @RC <> 0
	BEGIN
		PRINT CHAR(13) + 'CV Brat Pre-requisite c:\temp does not exist - attempting to create'

		SET @cmdstr = 'mkdir c:\temp'
		EXEC @RC = master..xp_cmdshell @cmdstr
	END

	----------------------
	-- Determine CV Client ver

	SET @CVClientver = NULL
	EXEC master..xp_instance_regread
				  @rootkey      = N'HKEY_LOCAL_MACHINE',
				  @key          = N'SOFTWARE\CommVault Systems\Galaxy\Instance001\Base',
				  @value_name   = N'sVERSION',
				  @value        = @CVClientver OUTPUT
 	
	SET @CVClientver = ISNULL(@CVClientver,'Unknown')
	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_Clientver', @CVClientver 

 	----------------------
	-- Verifiy physical files and update dbo.dbsInstanceConfig

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_RootPath', @CVpath OUTPUT

	DECLARE @bratver TABLE (FRtnVer varchar(255))

	SET @cmdstr = 'cd "' + @CVpath + '"'
	EXEC @RC = master..xp_cmdshell @cmdstr

	IF @RC = 0
	BEGIN -- Force grant SQL agent service account permissions

		SET @astr = N'SYSTEM\CurrentControlSet\Services\' 
				+ CASE @@SERVICENAME
					WHEN 'MSSQLSERVER' THEN 'SQLServerAgent'
					ELSE 'SQLAgent$' + @@SERVICENAME
				END
		EXEC master..xp_instance_regread
					  @rootkey      = N'HKEY_LOCAL_MACHINE',
					  @key          = @astr,
					  @value_name   = N'ObjectName',
					  @value        = @SvcLogin OUTPUT

		IF @Quiet = 0
			PRINT CHAR(13) + 'Ensuring the SQL Agent service account has RW access to ' + @CVpath 

		SET @cmdstr= 'cacls "' + @CVpath + '" /t /e /g "' + @SvcLogin + '":f'
		PRINT CHAR(13) + @cmdstr
		EXEC @RC = master..xp_cmdshell @cmdstr

		IF @RC <> 0
			PRINT '=> cacls failed - investigation required'  
 
		----------------------
		SET @astr = N'SYSTEM\CurrentControlSet\Services\' 
				+ CASE @@SERVICENAME
					WHEN 'MSSQLSERVER' THEN 'MSSQLSERVER'
					ELSE 'MSSQL$' + @@SERVICENAME
				END
		EXEC master..xp_instance_regread
					  @rootkey      = N'HKEY_LOCAL_MACHINE',
					  @key          = @astr,
					  @value_name   = N'ObjectName',
					  @value        = @SvcLogin OUTPUT

		IF @Quiet = 0
			PRINT CHAR(13) + 'Ensuring the MSSQL service account has RW access to ' + @CVpath 

		SET @cmdstr= 'cacls "' + @CVpath + '" /t /e /g "' + @SvcLogin + '":f'
		PRINT CHAR(13) + @cmdstr
		EXEC @RC = master..xp_cmdshell @cmdstr

		IF @RC <> 0
			PRINT '=> cacls failed - investigation required'  
	END
	ELSE 
	BEGIN
	    SET @ErrorMsg = 'UBSMWE: usp_CVBRATchk: Simpana CommVault client is either missing or inaccessble - CommVault connectivity will not be possible'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

		SET @RC = 1
		GOTO END_IT
	END
	----------------------

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CVpath OUTPUT

	IF NOT RIGHT(@CVpath, 1) = '\' 
		SET @CVpath = @CVpath + '\'

	SET @cmdstr = '"' + @CVpath + 'cvbackup.exe" -version'
	INSERT INTO @bratver
	EXEC @RC = master..xp_cmdshell @cmdstr

	SET @cmdstr = '"' + @CVpath + 'cvbrowse.exe" -version'
	INSERT INTO @bratver
	EXEC @RC = master..xp_cmdshell @cmdstr

	SET @cmdstr = '"' + @CVpath + 'cvcfglist.exe" -version'
	INSERT INTO @bratver
	EXEC @RC = master..xp_cmdshell @cmdstr

	SET @cmdstr = '"' + @CVpath + 'cvjcontrol.exe" -version'
	INSERT INTO @bratver
	EXEC @RC = master..xp_cmdshell @cmdstr

	SET @cmdstr = '"' + @CVpath + 'cvrestore.exe" -version'
	INSERT INTO @bratver
	EXEC @RC = master..xp_cmdshell @cmdstr

	IF (SELECT DISTINCT COUNT(*)
		FROM @bratver
		WHERE FRtnVer LIKE '%cvbackup %'
			OR FRtnVer LIKE '%cvbrowse %'
			OR FRtnVer LIKE '%cvcfglist %'
			OR FRtnVer LIKE '%cvjconrol %'
			OR FRtnVer LIKE '%cvrestore %') <> 5
	BEGIN
	    SET @ErrorMsg = 'UBSMWE: usp_CVBRATchk: Simpana CommVault client components are either missing or inaccessble - CommVault connectivity will not be possible'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig  'CV_BRATver', '*BAD*' 
		SET @RC = 1
		GOTO END_IT
	END
	ELSE
	BEGIN
		SELECT TOP 1 @curBRATver = SUBSTRING(LTRIM(RTRIM(FRtnVer)),CHARINDEX('cvbackup', FRtnVer) + LEN('cvbackup') + 1,9)
		FROM @bratver
		WHERE FRtnVer LIKE '%cvbackup %'

		IF ISNUMERIC(REPLACE(@curBRATver, '.' , '')) = 1 
			EXEC @RC = [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_BRATver', @curBRATver 
		ELSE
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_CVBRATchk: ERROR - Simpana CommVault client component version could not be identified - CommVault connectivity may not be possible'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

			EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_BRATver', '*BAD*' 
			SET @RC = 1
			GOTO END_IT
		END
	END
END ----------------------
ELSE -- Just get BRATver from dbsInstanceConfig 
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATver', @curBRATver OUTPUT

-------------------------------------------------
-- Verify ver

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsVersion', @dbsVersion OUTPUT

SELECT @minMWEver = minMWEver
		,@minBRATver = minBRATver
FROM [DBServices].[dbo].[dbsCVBRATlookup] lk
WHERE dbsDatabaseBackupProcessorID = @dbsBackupProcessor

IF [DBServices].[dbo].[ufn_CmpVerNum](@dbsVersion
						,@minMWEver
						,3) = 2 -- target has higher version number 
BEGIN
	PRINT 'FAILED: UBSMWE version installed: ' + @dbsVersion 
	PRINT 'Minimum UBSMWE version required for dbsBackupProcessor: ' + CAST(@dbsBackupProcessor as char(1)) 
			+ ', BRAT: ' + @minBRATver + ' is ' + @minMWEver
	SET @RC = 1
	GOTO END_IT
END
ELSE 
IF @Quiet = 0
BEGIN
	PRINT '- UBSMWE version installed: ' + @dbsVersion
	PRINT '- CV Client version: ' + @CVClientver
END
IF [DBServices].[dbo].[ufn_CmpVerNum] (@curBRATver
						,@minBRATver
						,3) = 2 -- target has higher version number 
BEGIN
	PRINT 'FAILED: BRAT version installed: ' + @curBRATver 
	PRINT 'Minimum version required for dbsBackupProcessor: ' + CAST(@dbsBackupProcessor as char(1)) 
			+ ' is ' + @minBRATver +  '.xx'
	SET @RC = 1
	GOTO END_IT
END
ELSE
IF @Quiet = 0 
	PRINT '- BRAT version: ' + @curBRATver

END_IT:

IF @Quiet = 0 
	PRINT '---------------------------------------------------'

RETURN @RC

END --main 

GO
/****** Object:  StoredProcedure [dbo].[usp_CVClient]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVClient] (
		@CVClient nvarchar(128) OUTPUT
		,@CVInstance nvarchar(128) OUTPUT
		) 
AS

/****************************************************************************************
// @File: usp_CVClient.SQL
//
// Purpose: System SP which returns CV Client info 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 18/08/2014 @Author: Chris Basson (from orig code) @Version 6.0.0.3 @Action: TRRv3 Beta - orig MWE v5 code; fail to understand why serverproperty not used
//   @Date: 03/09/2014 @Author: Chris Basson @Version 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 28/09/2015 @Author: Chris Basson @Version 6.0.0.38 @Action: minor update; defaulting output msg 
****************************************************************************************/

BEGIN -- main

DECLARE @RC int
	,@IsClustered bit
	,@ActiveComputerName nvarchar(128)

----------------------------------------------------
-- Init Vars

SET @CVClient = ISNULL(LTRIM(RTRIM(@CVClient)),'')
SET @CVInstance = ISNULL(LTRIM(RTRIM(@CVInstance)),'')
SET @IsClustered = 0

----------------------------------------------------

IF @CVClient <> ''
	AND @CVInstance <> ''
BEGIN
	SET @CVClient = LOWER(@CVClient)
	SET @CVInstance = UPPER(@CVInstance)
	RETURN 0 
END ------------------
ELSE
	PRINT CHAR(13) + '=> Defaulting to local instance' + CHAR(13)

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT
SET @CVClient = LOWER(@ActiveComputerName)	

IF CHARINDEX('\', @CVClient) <> 0 
	SET @CVClient=SUBSTRING(@CVClient, 1, CHARINDEX('\', @CVClient)-1)

SET @CVInstance = UPPER(@ActiveComputerName)

IF CHARINDEX(N'MSSQLSERVER',@@SERVICENAME) = 0	
BEGIN
	IF NOT CHARINDEX('\', @CVInstance) <> 0
		SET @CVInstance = @CVInstance + '\' + UPPER(@@SERVICENAME)
END	

----------------------------------------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsIsInstanceClusteredFlag', @IsClustered OUTPUT

IF @RC = 0 AND @IsClustered = 1
BEGIN
	-- Clustered

	SET @CVClient = LOWER(CONVERT(nvarchar(128), SERVERPROPERTY('ServerName'))) 
	IF CHARINDEX('\', @CVClient) <> 0 
		SET @CVClient=SUBSTRING(@CVClient, 1, CHARINDEX('\', @CVClient)-1)

	SET @CVInstance = UPPER(CONVERT(nvarchar(128), SERVERPROPERTY('ServerName'))) 
	IF CHARINDEX(N'MSSQLSERVER', @@SERVICENAME) = 0	
	BEGIN
		IF NOT CHARINDEX('\', @CVInstance) <> 0 
			SET @CVInstance = UPPER(@CVInstance + '\' + UPPER(@@SERVICENAME))
	END 

	IF CHARINDEX('\', @CVInstance) <> 0 
		SET @CVClient=SUBSTRING(@CVInstance, 1, CHARINDEX('\', @CVInstance)-1)

	IF CHARINDEX('\', @CVClient) <> 0 
		SET @CVClient=SUBSTRING(@CVClient, 1, CHARINDEX('\', @CVClient)-1)

	SET @CVClient = LOWER(@CVClient)
	SET @CVInstance = UPPER(@CVInstance)
END

RETURN @RC

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVFRestore]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVFRestore] (
							 @CVClient nvarchar(128) = ''
							,@CVInstance nvarchar(128) = ''
							,@CVFSBackupSet nvarchar(128) = NULL
							,@alternateHost nvarchar(128) = NULL
							,@pattern nvarchar(128) = NULL
							,@FileList nvarchar(255) = NULL
							,@StartTime varchar(30) = NULL
							,@EndTime varchar(30) = NULL
							,@JobID varchar(30) = NULL
							,@destPath nvarchar(255) = NULL
							,@SaveOutput bit = 0
							,@EnableRestore bit = 0
							,@Showall bit = 0)
AS
/****************************************************************************************
// @File: usp_CVFRestore.SQL
//
// Purpose:
//   Perform object lookup operation on CommCell
//
// Notes: This stored procedure is called FROM main UBSMWE usp_BackupDatabase or via Manual call
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 06/06/2013 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 06/06/2013 @Author: Steve Trogub @Version: 4.1.0 @Action: Perform CommVault browse restore for filesystem
//   @Date: 18/08/2014 @Author: Steve Trogub @Version: 6.0.0.3 @Action: TRRv3 Beta
//   @Date: 29/08/2014 @Author: Steve Trogub @Version: 6.0.0.5 @Action: TRRv3 Beta
//   @Date: 1/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 09/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta
//   @Date: 09/12/2014 @Author: Chris Basson @Version: 6.0.0.19 @Action: TRRv3 time fix
//   @Date: 04/06/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: Simpana 10 client
//   @Date: 09/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Handle BRAT output duplicates
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE
	@ColCount int
	,@column_counter int
	,@ConfigDetected int
	,@counter int
	,@CVFQDNCommCell nvarchar (100)
	,@dbsInstanceFileLocation nvarchar(128)
	,@i_EndTime varchar(20)
	,@i_StartTime varchar(20)
	,@IsClustered int
	,@ErrorMsg nvarchar(255)
	,@OperationStartTime datetime
	,@RC int
	,@response nvarchar(1024)
	,@rstring varchar(128)
	,@searchCmd nvarchar(4000)
	,@SQL varchar(4000)
	,@tempFile nvarchar(255)
	,@tempInt float
	,@tempString nvarchar(255)
	,@tmpbackup_finish_date varchar(32)
	,@tmpBackupSet varchar(128)
	,@tmpfile_size varchar(40)
	,@tmpFileModifiedDate varchar(128)
	,@tmpfilepath varchar(512)
	,@tmpGroupName varchar(128)
	,@tmpjobid varchar(20)
	,@tmpLogicalName varchar(255)
	,@tmpnumber varchar(4)
	,@tmppageSize varchar(128)
	,@tmpPhysicalPath varchar(512)
	,@tmpstr varchar(4000)
	,@tmpTime nvarchar(8)
	,@tmpType varchar(2)
	,@UTCDate datetime
	,@UTCoffset smallint
	,@HostDT datetime
	,@CVOut_delimiter char(1)
	,@CVFile_delimiter char(1)
	,@FoundJobid bit
	,@exists bit
	,@dbsBackupProcessor tinyint
	,@CVFSSubclient nvarchar(128)
	,@CV_BRATPath varchar(128)

-----------------------------------------------------------------------------------
-- Init vars

IF ISNULL(@CVClient,'') = ''
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
												,@CVInstance = @CVInstance OUTPUT 
											
	PRINT 'Please make sure you use the following format to call this stored procedure:' 
	PRINT ''
	PRINT 'EXEC [DBServices].[dbo].[usp_CVFRestore]'
	PRINT '  @CVClient = ' + '''' + @CVClient + '''' + '						--source CV client'
	PRINT ' ,@CVInstance = ' + '''' + @CVInstance + ''' ' + '			--source CV instance'
	PRINT ' ,@CVFSBackupSet = ' + '''' + 'BackupsetName' + '''' + '				--source backupset if not default'
	PRINT ' --,@alternateHost = ' + '''' + 'NLDNXXXXNAP' + '''' + '				--source client'
	PRINT ' --,@FileList = ' + '''' + 'D:\MSSQL\restorelist.txt' + '''' + '		--list of specific files you like to be restored'
	PRINT ' ,@pattern = ' + '''' + '\**\*CV_PART_POC*20130709*' + '''' + '		--Regular expression descriing the filemask to search for'
	PRINT ' --,@JobID = 240947								--File FROM Specific job'
	PRINT ' ,@StartTime  = "YYYY/MM/DD HH:MM:SS			--daterange start for object search'
	PRINT ' ,@EndTime  = "YYYY/MM/DD HH:MM:SS"				--daterange end for object search'
	PRINT ' ,@SaveOutput = 1								--save output only to form a filelist later'
	PRINT ' ,@EnableRestore = 0							--0 to report, 1 to perform restore'
	PRINT ''
	GOTO END_IT
END

SET @IsClustered = CAST(SERVERPROPERTY('IsClustered') as int)
SET @ConfigDetected = 0
SET @CVFile_delimiter = ' '
SET @CVOut_delimiter = ','
SET @FoundJobid = 0

SET @alternateHost = LTRIM(RTRIM(@alternateHost))
					
--identify Locale
SET @UTCDate = GETUTCDATE() -- Steves original code DATEADD(Hour, DATEDIFF(Hour, GETUTCDATE(), GETDATE()), GETDATE()) - WTF?
SET @HostDT = GETDATE()
SET @UTCoffset = CAST(DATEDIFF(Hour, GETUTCDATE(), GETDATE()) as smallint)

PRINT '-------------------------------------------------'
PRINT 'UTCTime:   ' + CAST(@UTCDate as varchar(40))
PRINT 'Localtime: ' + CAST(@HostDT as varchar(40))
PRINT 'UTCoffset: ' + CAST(@UTCoffset as varchar(3))
PRINT '-------------------------------------------------'

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CV_BRATPath OUTPUT

IF NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

SET @rstring = ''
EXEC [DBServices].[dbo].[usp_Gen_rnd_filename] N'_FSreport', @rstring OUTPUT
SET @tempFile = @dbsInstanceFileLocation + @rstring  

PRINT 'TempFile: ' + @tempFile

----------------------------
-- Determine destination path for the restore if @destPath is not passed

SET @destPath = LTRIM(RTRIM(@destPath))
IF @EnableRestore = 1 
	AND (LEN(@destPath) < 3 OR @destPath IS NULL)
BEGIN
	--SET @destPath = @dbsInstanceFileLocation + 'RESTORE' + '\'
	PRINT 'A destination restore path (@destPath) was not specified, please verify the input parameters'

	GOTO END_IT
END

--set filelist to store output data in case restore is enabled
SET  @FileList = LTRIM(RTRIM(@FileList))
IF @FileList IS NULL OR LEN(@FileList) < 4 
BEGIN
	SET @FileList = REPLACE ( @tempFile , '_FSreport', '_FSflist' )

	PRINT 'A File List was not specified, defaulting to: ' + @FileList
END
----------------------------
--load configuration values

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
PRINT 'Client:' + @CVClient
PRINT 'Instance:' + @CVInstance

----------------------------
-- Determine FS BackupSet

IF ISNULL(@CVFSBackupSet, '') = ''
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_CVFSBackupSet] @CVFSBackupSet OUTPUT, @CVFSSubclient OUTPUT

	IF @RC <> 0
	BEGIN
		PRINT 'A CV Filesystem backupset could not be identified - please verify or manually specify @CVFSBackupSet' 
		GOTO END_IT
	END 
END
ELSE
	SET @CVFSBackupSet = LTRIM(RTRIM(@CVFSBackupSet))

-------------------------------------------------------------
--verify correct date range or set default one (past 31 days)
SET @OperationStartTime = @HostDT
SET @StartTime = LTRIM(RTRIM(@StartTime))
SET @EndTime = LTRIM(RTRIM(@EndTime))
SET @JobID = LTRIM(RTRIM(@JobID))

IF ISNULL(@StartTime,'') = ''
BEGIN
	SET @StartTime = DATEADD(day, -31, GETUTCDATE()) -- start time not given; default to 31 days
	PRINT '@StartTime parameter not specified; defaulting to 31 days ago: ' + CAST (@StartTime as nvarchar(40))
END ----------------------------
ELSE 
IF ISDATE(@StartTime) = 0
BEGIN
	PRINT 'An invaild @StartTime date has been specified - please verify your input parameters' 
	GOTO END_IT
END ----------------------------

IF ISNULL(@EndTime,'') = ''
BEGIN
	SET @EndTime = getdate()
	PRINT '@EndTime parameter not specified; defaulting to now: ' + CAST (@EndTime as nvarchar(40))
END ----------------------------
ELSE 
IF ISDATE(@EndTime) = 0
BEGIN
	PRINT 'An invaild @EndTime date has been specified - please verify your input parameters' 
	GOTO END_IT
END ----------------------------

IF CAST(@StartTime as datetime) >= CAST(@EndTime as datetime)
BEGIN
	PRINT '@StartTime must be less than @EndTime - please verify your input parameters' 
	GOTO END_IT
END

-------------------------------------------------------------
--check if cv_cmdshell exists
IF NOT EXISTS (SELECT 1 FROM [DBServices].[sys].[objects] WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: [DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1 '
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END

SET @searchCmd = N'.\Brat\bin\cvrestore.exe -type filesystem -clientName ' + @CVClient
	+ ' -backupSetName ' + @CVFSBackupSet + ' -browse '

-------------------------------------------------------------
--Parse start and end times to CV standard

SET @i_StartTime= DBServices.dbo.ufn_BRATTime(CAST(@StartTime as datetime))
SET @i_EndTime= DBServices.dbo.ufn_BRATTime(CAST(@EndTime as datetime))
 
IF @i_StartTime = 'DTError'
	OR @i_EndTime = 'DTError'
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: CV time parser error: @i_StartTime: '
		+ @i_StartTime + ' ,@i_EndTime: ' + @i_EndTime
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

	GOTO END_IT
END

SET @searchCmd = @searchCmd + ' -fromTimeValue "' + @i_StartTime + '" -toTimeValue "' + @i_EndTime + '"'

IF ISNULL(@pattern,'') <> ''  
	SET @searchCmd = @searchCmd + ' -wildCard -pattern "' + @pattern + '"'

SET @searchCmd = @searchCmd + ' -cs ' + @CVFQDNCommCell + ' > ' + @tempFile 

PRINT CHAR(13) + '-----------------------------------------------------------------------------------'
PRINT 'BRAT Search cmd:'  + CHAR(13)
PRINT 'cd "' + @CV_BRATPath + '"' 
PRINT @searchCmd

-- Exec search cmd
EXEC @RC = [DBServices].[dbo].[cv_cmdshell] @searchCmd, @response = @response OUTPUT

PRINT @response

IF @RC <> 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: ERROR - BRAT Search command failed'
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END

-------------------------------------------------------------
-- Parse BRAT output 

WAITFOR DELAY '00:00:05'

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp
                         
CREATE TABLE #tmp (line nvarchar(4000))

SET @SQL = 'BULK INSERT #tmp
    FROM ''' + @tempFile + '''
    WITH (FirstRow = 2, FieldTerminator = ' 
		+ '''' + @CVFile_delimiter + '''' 
		+ ', RowTerminator = ' + '''' + '\n'+ '''' + ')'
EXEC (@SQL)

IF OBJECT_ID('tempdb..##CV_FSOUT') IS NOT NULL
    DROP TABLE ##CV_FSOUT

CREATE TABLE ##CV_FSOUT (
                        jobid varchar(30)
                        ,BackupSet varchar(128)
                        ,FileModifiedDate varchar(30)
                        ,file_size varchar(40)
                        ,filepath varchar(512) )   
	           
DECLARE procver_cur CURSOR FORWARD_ONLY FOR
SELECT line 
FROM #tmp
OPEN procver_cur
  
FETCH NEXT FROM procver_cur INTO @tmpstr
WHILE (@@fetch_status <> -1)
BEGIN 

	SET @tmpstr= 
		REPLACE(
			REPLACE(
				REPLACE(
					REPLACE(
						REPLACE(
							REPLACE(@tmpstr,'  ',@CVOut_delimiter)
						,' ',@CVOut_delimiter)
					,',','<>')
				,'><','')
			,'<>',@CVOut_delimiter)
		, ', ',@CVOut_delimiter)

	SET @tmpstr=REPLACE(@tmpstr, @CVFSBackupSet + ' ', @CVFSBackupSet + @CVOut_delimiter)

	---collect BACKUP MEDIA INFO
	IF  @tmpstr <> UPPER('JID,TYPE START,FINISH,SIZE,DBNAME') 
	BEGIN
		SELECT @tmpjobid=LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr )
		WHERE RowID = 1
		
		SELECT @tmpBackupSet=LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr )
		WHERE RowID = 2
		
		SELECT @tmpFileModifiedDate = LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) 
		WHERE RowID = 3
		SELECT @tmpFileModifiedDate = @tmpFileModifiedDate + ' ' + LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) 
		WHERE RowID = 4
		
		SELECT @tmpfile_size=LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) 
		WHERE RowID = 5
		
		SELECT @tmpfilepath=LTRIM(RTRIM(Value)) 
		FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) 
		WHERE RowID = 6

		IF @JobID IS NULL OR @JobID = @tmpjobid 
		BEGIN
			IF @JobID = @tmpjobid 
				SET @FoundJobid = 1

 			IF ISNULL(@pattern,'') = '' 
				OR PATINDEX('%'+ REPLACE(REPLACE(@pattern,'**','*'),'*','%'), @tmpfilepath) <> 0
				INSERT INTO ##CV_FSOUT VALUES ( 
							 @tmpjobid 
							,@tmpBackupSet 
							,@tmpFileModifiedDate 
							,@tmpfile_size 
							,@tmpfilepath )				
		END
	END

	FETCH NEXT FROM procver_cur INTO @tmpstr
END
CLOSE procver_cur
DEALLOCATE procver_cur

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL       
	DROP TABLE #tmp

-----------------------------------------------------------------------------------
--DISPLAY RESULTS

PRINT CHAR(13) + '-----------------------------------------------------------------------------------'

-- Output List
SET @tmpstr = 'SELECT DISTINCT * FROM ##CV_FSOUT'

IF @Showall = 0
	SET @tmpstr = @tmpstr + ' WHERE CAST(file_size as bigint) > 0'

EXEC (@tmpstr)

SELECT @counter=COUNT(DISTINCT filepath)
FROM ##CV_FSOUT
WHERE CAST(file_size as bigint) > 0

PRINT 'File Count:' + CAST (@counter as varchar(4))

-------------------------------------------------------------
-- Save Filelist
  
IF @SaveOutput = 1 OR @EnableRestore = 1
BEGIN
	PRINT CHAR(13) + '-----------------------------------------------------------------------------------'

	SET @tmpstr = 'SELECT DISTINCT filepath FROM ##CV_FSOUT'
	IF @Showall = 0
		SET @tmpstr = @tmpstr + ' WHERE CAST(file_size as bigint) > 0'

	PRINT 'Saving Filelist to: ' + @FileList
	SET @SQL = 'bcp "' + @tmpstr + '" queryout '
		 + @FileList + ' -c -T -E -S ' + CONVERT(sysname, SERVERPROPERTY('ServerName')) 
	
	EXEC @RC = master..xp_cmdshell @SQL, NO_OUTPUT
	IF @RC <> 0
	BEGIN
		PRINT 'bcp command: ' + @SQL

		SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: ERROR - Filelist creation error - please verify the input parameters and output destinations'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END
END

PRINT CHAR(13) + '-----------------------------------------------------------------------------------'

-----------------------------------------------------------------------------------
--RESTORE

IF @EnableRestore = 1
BEGIN

	IF @FoundJobid = 1
	BEGIN
		SELECT TOP 1 @i_EndTime = FileModifiedDate
		FROM ##CV_FSOUT 
		WHERE jobid = @JobID
		ORDER BY FileModifiedDate DESC

		IF ISDATE(@i_EndTime) <> 1
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: Unhandled exception: @JobID time parsing error: @i_EndTime: ' + @i_EndTime
				+ ' Please rety excluding @JobID but including Start and End time or alternatively contact Backup Services.' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
			GOTO END_IT
		END
	END

	-- Basic cmd
	SET @searchCmd = N'.\Brat\bin\cvrestore.exe -type filesystem -clientName ' 
					+ @CVClient 
					+ ' -backupSetName ' + @CVFSBackupSet + ' '
					+ ' -toTimeValue "' + @i_EndTime + '" '

	-------------------------------------------------------------
	--Additional restore options:

	IF ISNULL(@alternateHost,'') <> '' 
		SET @searchCmd = @searchCmd + ' -alternateHost ' + @alternateHost

	IF LEN(@FileList) > 2
	BEGIN
		SET @exists = 0
		EXEC [DBServices].[dbo].[usp_FileExists] @FileList, @exists OUTPUT
		
		IF @exists = 1
			SET @searchCmd = @searchCmd + ' -filelist ' + @FileList	
		ELSE
			GOTO BAD_FILELIST
	END ----------------------------
	ELSE
	BEGIN
		BAD_FILELIST:

		SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: Filelist provided for the restore does not exist: ' + @FileList
			+ ' Please verifiy or alternatively contact Backup Services for the restore.' 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END

	IF @destPath IS NOT NULL 
		SET @searchCmd = @searchCmd + ' -destPath ' + @destPath
	                                      
	SET @searchCmd = @searchCmd + ' -cs ' + @CVFQDNCommCell 

	-------------------------------------------------------------
	-- Print details

	PRINT 'BRAT restore cmd:' +  CHAR(13)
	PRINT 'cd "' + @CV_BRATPath + '"'
	PRINT @searchCmd

	PRINT  'BRAT output: ' + @tempFile

	PRINT CHAR(13) + '-----------------------------------------------------------------------------------'

	EXEC @RC = [DBServices].[dbo].[cv_cmdshell] @searchCmd, @response = @response OUTPUT
	IF @RC <> 0
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_CVFRestore: Unhandled Exception - Restore failed; '
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END

	PRINT 'BRAT response:' + CHAR(13)

	PRINT @response

	PRINT CHAR(13) + '-----------------------------------------------------------------------------------'
END

-----------------------------------------------------------------------------------

-- Output time taken
SET @ErrorMsg = ''
SET @tempInt = DATEDIFF(second,@OperationStartTime, GETDATE())
SET @ErrorMsg = @ErrorMsg + ' Protected media search successfully processed in ' + CAST(@tempInt as nvarchar(40) ) + ' seconds.'

PRINT ''
PRINT @ErrorMsg

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL       
	DROP TABLE #tmp

IF OBJECT_ID('tempdb..##CV_FSOUT') IS NOT NULL
    DROP TABLE ##CV_FSOUT

RETURN 0

-----------------------------------------------------------------------------------
END_IT:
IF OBJECT_ID('tempdb..#tmp') IS NOT NULL       
	DROP TABLE #tmp

IF OBJECT_ID('tempdb..##CV_FSOUT') IS NOT NULL
    DROP TABLE ##CV_FSOUT

RETURN 1

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVFSBackupSet]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVFSBackupSet]
			@CVFSBackupSet varchar(128) OUTPUT 
			,@CVFSSubclient varchar(128) OUTPUT
			,@DBName nvarchar(128) = NULL -- If specified, returns @CVFSBackupSet, @CVFSSubclient
			,@Init bit = 0
AS
/****************************************************************************************
// @File: usp_CVFSBackupSet.sql
// @Version: 6.0.0.33
// 
// Purpose:
//   
// Notes: System sp
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 09/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.14 @Action: TRRv3 Beta
//   @Date: 17/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.27 @Action: Brat parser improvement
//   @Date: 04/06/2015 @Author: Chris Basson @Version 6.0.0.30 Simpana 10 client
//   @Date: 22/06/2015 @Author: Chris Basson @Version 6.0.0.33 Improved error handling
****************************************************************************************/

BEGIN  --Begin main()

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
	,@dbsBackupProcessor tinyint
	,@CV_Enabled bit
	,@CVFQDNCommCell nvarchar (100)
	,@dbsInstanceFileLocation nvarchar(128)
	,@dbsDatabaseUID uniqueidentifier 
	,@dbsDatabaseName nvarchar(128)
	,@tempFile nvarchar(255)
	,@response nvarchar(1024)
	,@AStr varchar(1024)
	,@CVClient nvarchar(128)
	,@CVInstance nvarchar(128)
	,@CVInstOnly nvarchar(64)
	,@CVFile_delimiter char(1)
	,@CVOut_delimiter char(1)
	,@tmpBackupSet nvarchar(128)
	,@tmpSubclient nvarchar(128)
	,@tmpDB nvarchar(128)
	,@i smallint
	,@now smalldatetime
	,@CV_BRATPath varchar(128)

-------------------------------------------------------------
-- Init Vars

SET @CVFile_delimiter = ' '
SET @CVOut_delimiter = ','

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 
IF @RC <> 0 
	OR ISNULL(@CV_Enabled, 0) <> 1
BEGIN
	PRINT 'UBSMWE: usp_CVFSBackupSet: CV FS Backups is not enabled (CV_Enabled = 0)'
	PRINT 'Please refer to the UBSMWE Operations Guide: [usp_ConfigureCVbackup] for details' 
	RETURN 1
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CV_BRATPath OUTPUT

SET @CVInstOnly = UPPER(RIGHT(@CVInstance,LEN(@CVInstance) - CHARINDEX('\',@CVInstance)))

-------------------------------------------------------------
-- Determine FS BackupSet

SET @CVFSBackupSet = LTRIM(RTRIM(@CVFSBackupSet))

IF ISNULL(@CVFSBackupSet, '') = ''
BEGIN
	-- Determine UBS default based on dbsBackupProcessor
	IF @dbsBackupProcessor = 5 -- TRRv3
		SET @CVFSBackupSet = 'DBLOGS' -- TRRv3 backupset for LS TLog CV FS backups
	ELSE  -- TRRv2
		SET @CVFSBackupSet = LOWER(@CVInstance) -- TRRv2 BackupSet = lower case CV Instance name
END

-------------------------------------------------------------
-- Determine FS Subclient

SET @now = getdate()

IF @Init = 0
	AND OBJECT_ID('[DBServices].[dbo].[dbsCVFSSubclients]') IS NOT NULL
	SELECT TOP 1 @Init = CASE
							WHEN (dbsLastUpdate < DATEADD(hh, -6, @now)) THEN 1
							ELSE 0
						 END
	FROM [DBServices].[dbo].[dbsCVFSSubclients]
ELSE 
	SET @Init = 1 -- [dbsCVFSSubclients] missing

IF @Init = 1
BEGIN

	Refresh_dbsCVFSSubclients:

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

	IF NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
		SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

	SET @AStr=''
	EXEC DBServices.dbo.usp_Gen_rnd_filename N'_FSSubclnt', @AStr OUTPUT
	SET @tempFile = @dbsInstanceFileLocation + @AStr  

	PRINT 'TempFile: ' + @tempFile

	SET @AStr = N'.\Brat\bin\cvcfglist.exe -type filesystem -subclient -clientName ' + @CVClient
		+ ' -backupSetName ' + @CVFSBackupSet
		+ ' -cs ' + @CVFQDNCommCell
		+ ' > ' + @tempFile

	-- Exec search cmd

	PRINT 'cd "' + @CV_BRATPath + '"'
	PRINT @AStr

	EXEC @RC = [DBServices].[dbo].[cv_cmdshell] @AStr, @response = @response OUTPUT

	----------------------------------
	-- Parse BRAT output 

	WAITFOR DELAY '00:00:05'

	IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
		DROP TABLE #tmp
	                         
	CREATE TABLE #tmp (line nvarchar(4000))

	SET @AStr = 'BULK INSERT #tmp
		FROM ''' + @tempFile + '''
		WITH (FirstRow = 1, FieldTerminator = ' 
			+ '''' + @CVFile_delimiter + '''' 
			+ ', RowTerminator = ' + '''' + '\n' + '''' + ')'
	EXEC (@AStr)

	IF OBJECT_ID('[DBServices].[dbo].[dbsCVFSSubclients]') IS NULL
		CREATE TABLE [DBServices].[dbo].[dbsCVFSSubclients] (
							dbsDatabaseUID uniqueidentifier ROWGUIDCOL NOT NULL
							,dbsFSBackupSet nvarchar(128) NOT NULL
							,dbsFSSubclientName nvarchar(128) NOT NULL
							,dbsLastUpdate smalldatetime NOT NULL
						CONSTRAINT [PK_dbsCVFSSubclients] PRIMARY KEY CLUSTERED 
							([dbsDatabaseUID] ASC,
							[dbsFSBackupSet] ASC)
						WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF
							, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
						) ON [PRIMARY]
	ELSE
		TRUNCATE TABLE [DBServices].[dbo].[dbsCVFSSubclients]

	DECLARE procver_cur CURSOR FOR
	SELECT line 
	FROM #tmp

	OPEN procver_cur
	  
	FETCH NEXT FROM procver_cur
	INTO @AStr
	WHILE (@@fetch_status <> -1)
	BEGIN 
		SET @AStr= 
			REPLACE(
				REPLACE(
					REPLACE(
						REPLACE(
							REPLACE(
								REPLACE(@AStr,'  ',@CVOut_delimiter)
							,' ',@CVOut_delimiter)
						,',','<>')
					,'><','')
				,'<>',@CVOut_delimiter)
			, ', ',@CVOut_delimiter)

		SELECT @tmpBackupSet=LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@AStr )
		WHERE RowID = 1

		SELECT @tmpSubclient=LTRIM(RTRIM(Value))
		FROM dbo.fn_Split(@CVOut_delimiter ,@AStr )
		WHERE RowID = 2
	
		IF (ISNULL(@tmpBackupSet, '') <> '')
			AND (ISNULL(@tmpSubclient, '') <> '')
			AND ( (@dbsBackupProcessor = 5 
					AND UPPER(@tmpBackupSet) = UPPER(@CVFSBackupSet)
					AND @tmpSubclient LIKE '%' + @CVInstOnly + '%'
					) -- TRRv3 standard instance name in Subclient
				OR (@dbsBackupProcessor <> 5
					AND LOWER(@tmpBackupSet) = LOWER(@CVFSBackupSet)
					) -- TRRv2 standard unique BackupSet
				)
		BEGIN
			SET @i = CHARINDEX('-' + @CVInstOnly + '-', @tmpSubclient)
			IF @i > 0
			BEGIN -- TRRv3 DB Specific FS Subclient identified
				SET @tmpDB = UPPER(RIGHT (@tmpSubclient, 
								(LEN(@tmpSubclient) - (@i + LEN(@CVInstOnly) + 1)) 
								))

				SET @tmpDB = REPLACE(@tmpDB, char(13), '')
				SET @tmpDB = REPLACE(@tmpDB, char(10), '')
				SET @tmpDB = REPLACE(@tmpDB, char(9), '')
			END
			ELSE 
				SET @tmpDB = NULL

			DECLARE db_cur CURSOR FOR
			SELECT DISTINCT dbsDatabaseUID, dbsDatabaseName
			FROM [DBServices].[dbo].[dbsDatabase] db
			WHERE db.dbsDatabaseIsActive = 1
			
			OPEN db_cur

			FETCH NEXT FROM db_cur
			INTO @dbsDatabaseUID, @dbsDatabaseName
			WHILE (@@fetch_status <> -1)
			BEGIN			
				IF (@tmpDB IS NULL 
					OR UPPER(LEFT(@dbsDatabaseName, 60)) = LEFT(@tmpDB, 60))
					INSERT INTO [DBServices].[dbo].[dbsCVFSSubclients] VALUES ( 
								@dbsDatabaseUID
								,@tmpBackupSet 
								,@tmpSubclient 
								,@now)
				
				FETCH NEXT FROM db_cur
				INTO @dbsDatabaseUID, @dbsDatabaseName
			END

			CLOSE db_cur
			DEALLOCATE db_cur
		END

		FETCH NEXT FROM procver_cur 
		INTO @AStr
	END

	CLOSE procver_cur
	DEALLOCATE procver_cur

	-- Tidy up temp file
	EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @tempFile

END

IF ISNULL(@DBName, '') = ''
	-- Non Specific FS Subclient
	SELECT TOP 1 @CVFSSubclient = dbsFSSubclientName
	FROM [DBServices].[dbo].[dbsCVFSSubclients]
	WHERE UPPER(dbsFSBackupSet) = UPPER(@CVFSBackupSet)
		AND ( (@dbsBackupProcessor = 5 AND dbsFSSubclientName LIKE '%' + @CVInstOnly)
			OR @dbsBackupProcessor <> 5)
ELSE 
	--TRRv3 DB Specific FS Subclient
	SELECT TOP 1 @CVFSSubclient = dbsFSSubclientName
	FROM [DBServices].[dbo].[dbsCVFSSubclients]
	WHERE UPPER(dbsFSBackupSet) = UPPER(@CVFSBackupSet)
		AND (@dbsBackupProcessor = 5 
				AND dbsFSSubclientName LIKE '%' + @CVInstOnly + '-' + UPPER(LEFT(@DBName,60)) + '%'
			)

IF ISNULL(@CVFSBackupSet, '') = ''
	OR ISNULL(@CVFSSubclient, '') = ''
BEGIN
	PRINT 'UBSMWE: usp_CVFSBackupSet: Unable to determine CV FileSystem Backup details, please verify CV registration with Backup Services' 
	PRINT '@CVFSBackupSet: ' + ISNULL(@CVFSBackupSet, '*NULL*')
	PRINT '@CVFSSubclient: ' + ISNULL(@CVFSSubclient, '*NULL*')

	SET @RC = 1
	GOTO END_IT
END
ELSE
	SET @RC = 0

----------------------------------
END_IT:

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

RETURN @RC

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVJobcontrol]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVJobcontrol] 
		(@CVClient nvarchar(128) = NULL -- lower case
		,@JobID INT = NULL
	    ,@operation nvarchar(18) = 'LIST' -- 'LIST','SUSPEND','RESUME','KILL','CVSCHED_DISABLE','CVSCHED_ENABLE'
		,@CVInstance nvarchar(128) =NULL -- UPPER case
		,@subclientName nvarchar(128)= NULL -- Case sensitive
		,@backupsetName nvarchar(128) = NULL -- used in conjunction with @CVBakType = 'F'
		,@CommCell varchar(128) = NULL --optional, in case another CommCell must be referenced.
		,@CVBakType char(1) = 'S'  -- 'S' for SQL iDA, 'F' for FileSystem iDA CV backup types 
		,@Quiet bit = 0)
AS

/****************************************************************************************
// @File: usp_CVJobcontrol.SQL
//
// Purpose: Perform a job control operations  
//
// Notes: This stored procedure is called by other stored procedures or can be called by user
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 09/26/2012 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 09/26/2012 @Author: Steve Trogub @Version: 5.1.0 @Action: Perform CommVault JobControl Operations
//   @Date: 23/06/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 20/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta
//   @Date: 04/09/2014 @Author: Chris Basson @Version: 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 02/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta
//   @Date: 18/12/2014 @Author: Chris Basson @Version: 6.0.0.18 @Action: TRRv3 TRR-108
//   @Date: 02/06/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: Simpana 10 client support
//   @Date: 12/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Handle BRAT output duplicates
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
****************************************************************************************/

BEGIN  --Begin main()

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE
	@ControlCmd nvarchar(4000)
	,@counter int
	,@CVFQDNCommCell nvarchar(100)
	,@dbsInstanceFileLocation nvarchar(128)
	,@piece varchar(5000)
	,@PosPrev int
	,@RC int
	,@response nvarchar(4000)
	,@rstring nvarchar(128)
	,@SQL nvarchar(4000)
	,@tempFile nvarchar(255)
	,@tempjobID varchar(20)
	,@tempjobReason nvarchar(4000)
	,@tempjobStatus nvarchar(128)
	,@tempjobType nvarchar(128)
	,@tmpstr varchar(8000)
	,@fieldsep char(3) 
	,@recordsep char(3)
	,@dbsBackupProcessor tinyint 
	,@ErrorMsg nvarchar(255)
	,@CVOut_delimiter char(1)
	,@CVFile_delimiter char(1)
	,@CV_BRATPath varchar(128)
	,@debug tinyint
	,@usage varchar(2048)

SET @CVFile_delimiter = ' '
SET @CVOut_delimiter = ','

/*   
-backupSetName [backupSet]         Restrict list to jobs belonging to a backupSetName
-instanceName [instance]           Restrict list to jobs belonging to an instance
-subclientName [subclient]         Restrict list to a subclient (requires instanceName or backupSetName)
*/

SET @usage =  CHAR(13) + '--usage:' + CHAR(13)
SET @usage = @usage + 'EXEC DBServices..usp_CVJobcontrol ' + CHAR(13)
SET @usage = @usage + '			@operation = ''LIST''					-- options: LIST, SUSPEND/RESUME, KILL, CVSCHED_DISABLE/CVSCHED_ENABLE' + CHAR(13)
SET @usage = @usage + '			--,@JobID = <jobid>' + CHAR(13)
SET @usage = @usage + '			--,@CVClient = ''<CVClient>''			--client name /list client wide content, default local' + CHAR(13)
SET @usage = @usage + '			--,@CVInstance = ''<CVInstance>''		--instance name /list instance wide contents, default local' + CHAR(13)
SET @usage = @usage + '			--,@backupsetName = ''<backupset>''	--backupset name /if looking for objects on File System Agent (@CVBakType = F)' + CHAR(13)
SET @usage = @usage + '			--,@subclientName = ''<Subclient>''	--subclient name /list specific subclient contents.' + CHAR(13)
SET @usage = @usage + '			--,@CommCell = ' + '''' + '<commcell>' + '''' + '			--optional if another CommCell must be referenced.' + CHAR(13)
SET @usage = @usage + '			--,@CVBakType char(1) = ''S''			--S= SQL iDA, F= FileSystem iDA CV backup types' + CHAR(13)

-----------------------------------------------------------------------------------
--load configuration values

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT                                                                         		
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CV_BRATPath OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT

IF @CommCell IS NULL
     EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT
ELSE
	SET @CVFQDNCommCell=LTRIM(RTRIM(@CommCell))

SET @operation = UPPER(LTRIM(RTRIM(@operation)))
SET @CVBakType = UPPER(LTRIM(RTRIM(@CVBakType)))

----------------------------------
--check if cv_cmdshell exists

IF NOT EXISTS (SELECT * FROM [DBServices].[sys].[objects] WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @ErrorMsg = 'UBSMWE: usp_CVJobcontrol: [DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1 '
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	RETURN 1
END

----------------------------------
-- Verify input params

IF @operation NOT IN ('LIST','SUSPEND','RESUME','KILL','CVSCHED_DISABLE','CVSCHED_ENABLE')
BEGIN
	PRINT 'UBSMWE: usp_CVJobcontrol: Invalid @operation parameter has been specified; Options: LIST,SUSPEND/RESUME,KILL,CVSCHED_DISABLE/CVSCHED_ENABLE'
	PRINT @usage
	RETURN 1
END

IF @CVBakType NOT IN ('S','F')
BEGIN
	PRINT 'UBSMWE: usp_CVJobcontrol: Invalid @CVBakType parameter has been specified; Options: S= SQL iDA, F= FileSystem iDA'
	PRINT @usage
	RETURN 1
END

IF @CVBakType <> 'F'
	AND ISNULL(@backupsetName,'') <> '' 
BEGIN
	PRINT 'UBSMWE: usp_CVJobcontrol: @backupsetName is only applicable for CV File System backups - ie. @CVBakType = ''F'''
	PRINT @usage
	RETURN 1
END

IF @CVBakType = 'F'
	AND ISNULL(@backupsetName,'') = ''
BEGIN
	IF OBJECT_ID('[DBServices].[dbo].[dbsCVFSSubclients]') IS NOT NULL
		SELECT TOP 1 @backupsetName = [dbsFSBackupSet]
		FROM [DBServices].[dbo].[dbsCVFSSubclients]
		ORDER BY dbsLastUpdate DESC
END

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
IF @Quiet = 0
BEGIN
	PRINT 'Client:' + @CVClient
	PRINT 'InstanceName: ' + @CVInstance
	PRINT 'SubclientName: ' + @subclientName + '   *** Case sensitive ***'
	PRINT 'CVBakType: ' + @CVBakType
	PRINT 'BackupSet: ' + @backupsetName
END

IF @subclientName IS NULL AND (
		((@dbsBackupProcessor <> 5) AND @operation IN ('CVSCHED_DISABLE','CVSCHED_ENABLE'))
		OR (@operation IN ('SUSPEND','RESUME')) )
BEGIN 
	PRINT 'UBSMWE Error: usp_CVJobcontrol: @subclientName must be specified when @operation = ' + @operation
	PRINT @usage
	GOTO handle_error
END

IF (@dbsBackupProcessor = 5) 
	AND NOT EXISTS (SELECT TOP 1 1
					FROM DBServices.sys.objects
					WHERE [name] = 'dbsCVSchedule' AND [type]='U')
BEGIN
	IF @Quiet = 0
		PRINT 'Running usp_CVSchedule_List for the 1st time'

	EXEC DBServices.dbo.usp_CVSchedule_List @CVInstance = @CVInstance -- dependancy - creates dbsCVSchedule table and populates
END

-----------------------------------------------------------------------------------

IF  NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'
SET @rstring=''
EXEC dbo.usp_Gen_rnd_filename N'_CVJobctrl', @rstring OUTPUT
SET @tempFile = @dbsInstanceFileLocation + @rstring 

IF @Quiet = 0
	PRINT 'tempFile File: ' + @tempFile

-----------------------------------------------------------------------------------

-- Compile cvjcontrol BRAT cmd 

SET @ControlCmd = N'.\Brat\bin\cvjcontrol.exe -type ' 
		+ CASE @CVBakType
			WHEN 'S' THEN 'mssql'
			WHEN 'F' THEN 'filesystem'
			END
		+ ' -clientName ' + LOWER(@CVClient) 
	
IF @operation = 'LIST' 
BEGIN
	SET @ControlCmd = @ControlCmd + ' -list '

    IF ISNULL(@CVInstance,'') <> '' 
		SET @ControlCmd = @ControlCmd + ' -instanceName ' + @CVInstance 

    IF ISNULL(@subclientName,'') <> ''
		SET @ControlCmd = @ControlCmd + ' -subclientName ' + @subclientName 

	IF @CVBakType = 'F' 
		AND ISNULL(@backupsetName,'') <> ''
		SET @ControlCmd = @ControlCmd + ' -backupSetName ' + @backupsetName

END ----------------------------------
ELSE
IF @operation IN ('CVSCHED_DISABLE','CVSCHED_ENABLE') 
BEGIN
	IF ISNULL(@CVInstance,'') <> '' 
		SET @ControlCmd = @ControlCmd + ' -instanceName ' + @CVInstance
		
    IF ISNULL(@subclientName,'') <> ''
		SET @ControlCmd = @ControlCmd + ' -subclientName ' + @subclientName
	
	SET @ControlCmd = @ControlCmd
			+ CASE @operation
				WHEN 'CVSCHED_DISABLE' THEN ' disableActivity '
				WHEN 'CVSCHED_ENABLE' THEN ' enableActivity '
				END
END ----------------------------------
ELSE
BEGIN
	IF @JobID IS NOT NULL
    BEGIN
		IF @operation = 'KILL'  
			SET @ControlCmd = @ControlCmd + ' -kill ' + CAST(@JobID as varchar(20))
		IF @operation = 'SUSPEND' 
			SET @ControlCmd = @ControlCmd + ' -suspend ' + CAST(@JobID as varchar(20))
		IF @operation = 'RESUME' 
			SET @ControlCmd = @ControlCmd + ' -resume ' + CAST(@JobID as varchar(20))
    END ----------------------------------
    ELSE
	BEGIN
		PRINT 'UBSMWE: usp_CVJobcontrol: You must specify @JobID when you choose operation types resume or kill.'
		PRINT @usage
		GOTO handle_error
    END
END ----------------------------------

SET @ControlCmd = @ControlCmd + ' -cs ' + @CVFQDNCommCell + ' > ' + @tempFile 

IF @Quiet = 0 OR @debug >= 2
BEGIN
	PRINT 'cd "' + @CV_BRATPath + '"'
	PRINT @ControlCmd
END

-----------------------------------------------------------------------------------

-- EXEC cvjcontrol BRAT cmd

EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
	@ControlCmd,
	@response = @response OUTPUT  

IF @RC <> 0
BEGIN
	SELECT @response 'BRAT response'
		,@RC 'RC'

    SET @ErrorMsg = N'UBSMWE: usp_CVJobcontrol: Could not run job control, possibly due to CommCell load'
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
    GOTO handle_error
END ----------------------------------
ELSE
BEGIN -- Operation successful

	IF @debug >= 2
		SELECT @response 'BRAT response'
			,@RC 'RC'

	IF @Quiet = 0
		PRINT @operation + ' - job control action completed successfully'
	
	-- Set dbsCVSchedule Enabled flag if applicable
	IF @operation IN ('CVSCHED_DISABLE','CVSCHED_ENABLE') 
		UPDATE DBServices.dbo.dbsCVSchedule 
		SET [Enabled] = CASE @operation 
							WHEN 'CVSCHED_DISABLE' THEN 0
							ELSE 1
						END
		WHERE CVSubclient = @subclientName
END ----------------------------------

-----------------------------------------------------------------------------------
-- Parse result output file

WAITFOR DELAY '00:00:05'

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

CREATE TABLE #tmp (line varchar(8000))

SET @recordsep = '\n'
SET @fieldsep  = char(20)

SET @SQL = 'BULK INSERT #tmp
    FROM ''' + @tempFile + '''
    WITH (FirstRow = 2, FieldTerminator = ' 
		+ '''' + @CVFile_delimiter + '''' 
		+ ', RowTerminator = ' + '''' + '\n'+ '''' + ')'
EXEC (@SQL)

IF OBJECT_ID('tempdb..#CV_JOBRECORDS') IS NOT NULL 
	DROP TABLE #CV_JOBRECORDS

CREATE TABLE #CV_JOBRECORDS (
			jobid varchar(20)
			,jobType nvarchar(128)
			,jobStatus nvarchar(128)
			,jobReason nvarchar(4000))         
              
DECLARE procver_cur CURSOR FORWARD_ONLY FOR 
SELECT line
FROM #tmp

OPEN procver_cur
  
FETCH NEXT FROM procver_cur INTO @tmpstr
WHILE (@@fetch_status <> -1)
BEGIN 

	SET @tmpstr= 
		REPLACE(
			REPLACE(
				REPLACE(
					REPLACE(
						REPLACE(
							REPLACE(@tmpstr,'  ',@CVOut_delimiter)
						,' ',@CVOut_delimiter)
					,',','<>')
				,'><','')
			,'<>',@CVOut_delimiter)
		, ', ',@CVOut_delimiter)
     
	---collect BACKUP MEDIA INFO
	IF  @tmpstr <> UPPER('Jobid Type Status Reason') 
	BEGIN
		SELECT @tempjobID=Value FROM dbo.fn_Split(@CVOut_delimiter, @tmpstr) WHERE RowID = 1
		SELECT @tempjobType=Value FROM dbo.fn_Split(@CVOut_delimiter, @tmpstr) WHERE RowID = 2
		SELECT @tempjobStatus=Value FROM dbo.fn_Split(@CVOut_delimiter, @tmpstr) WHERE RowID = 3
		SELECT @tempjobReason=Value FROM dbo.fn_Split(@CVOut_delimiter, @tmpstr) WHERE RowID = 4

		IF @JobID IS NULL
			OR @JobID = @tempjobID 
		BEGIN
			INSERT INTO #CV_JOBRECORDS VALUES ( 
					 @tempjobID 
					,@tempjobType 
					,@tempjobStatus 
					,@tempjobReason 
					)	  				
		END 
	END

	FETCH NEXT FROM procver_cur INTO @tmpstr
END
    
CLOSE procver_cur
DEALLOCATE procver_cur

-----------------------------------------------------------------------------------
--DISPLAY RESULTS

IF @debug >= 2
	SELECT * 
	FROM #tmp

IF @Quiet = 0 OR @debug >= 2
BEGIN
	PRINT CHAR(13)
	PRINT '-----------------------------------------------------------------------------------'
	PRINT CHAR(13)

	SELECT DISTINCT *
	FROM #CV_JOBRECORDS

	SELECT @counter = COUNT(DISTINCT jobid)
	FROM #CV_JOBRECORDS

	PRINT 'Count: ' + CAST(@counter as varchar(3))

	PRINT CHAR(13)
	PRINT '-----------------------------------------------------------------------------------'
END

-----------------------------------------------------------------------------------
--update local table with current job data

IF NOT EXISTS (SELECT TOP 1 1
				FROM DBServices.sys.objects so
				WHERE so.[object_id] = OBJECT_ID(N'[dbo].[dbsCVJobStatus]'))
BEGIN
	CREATE TABLE [DBServices].[dbo].[dbsCVJobStatus](
		jobid varchar(20) NOT NULL
		,subclient nvarchar(128) 
		,jobType nvarchar(128) NOT NULL
		,jobStatus nvarchar(128) NOT NULL
		,jobReason nvarchar(4000)) ON [PRIMARY]
END ----------------------------------
ELSE
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_chktbllock] 'DBServices', 'dbsCVJobStatus'
	IF @RC <> 0
	BEGIN
		SET @ErrorMsg =  N'UBSMWE: usp_CVJobcontrol: Failed to update [DBServices]..[dbsCVJobStatus]'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO handle_error
	END
END

--make sure the instance passed matches local instance, if not we cannot update local tables
IF UPPER(CONVERT(sysname, SERVERPROPERTY('ServerName'))) = UPPER(@CVInstance) 
BEGIN
	TRUNCATE TABLE [DBServices].[dbo].[dbsCVJobStatus]
           
	SET LOCK_TIMEOUT 1000
	
	INSERT INTO [DBServices].[dbo].[dbsCVJobStatus]
		SELECT DISTINCT jobid, @subclientName, jobType, jobStatus, jobReason
		FROM #CV_JOBRECORDS
END ----------------------------------
ELSE
IF @Quiet = 0
	PRINT 'Info: ' + CONVERT(sysname, SERVERPROPERTY('ServerName')) + ' <> ' + @CVInstance + ' - Skipping local table update'

-----------------------------------------------------------------------------------
batch_end:

--Tidyup 
IF OBJECT_ID('tempdb..#CV_JOBRECORDS') IS NOT NULL
	DROP TABLE #CV_JOBRECORDS
IF OBJECT_ID('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

-- Tidy up temp file
EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @tempFile

RETURN 0 -- exit

---------------------------------------
handle_error:

-- clean up after the error
PRINT 'For additional details see the latest log file located in C:\TEMP\cvjcontrol.exe' 
	+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

IF OBJECT_ID('tempdb..#CV_JOBRECORDS') IS NOT NULL
	DROP TABLE #CV_JOBRECORDS
IF OBJECT_ID('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

-- leave output file for investigation

RETURN 1 -- exit

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVKickService]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVKickService] (@action tinyint = 1)
AS 
/****************************************************************************************
// @File: usp_CVKickService.SQL
//
// @Version 6.0.0.31
//
// Purpose:
//   Control CommVault client Services from within MSSQL 
//	Pre-requisite - MSSQL Service account requires local admin rights.
//	@action: 1=Report, 2=Stop, 3=Start, 4=Restart
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 07/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.1 @Action: TRRv3 Beta
//   @Date: 07/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 12/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.15 @Action: TRRv3 - CV timezone workaround 
//   @Date: 01/06/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.30 @Action: Simpana 10 client compatibility
//   @Date: 09/06/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.31 @Action: Request to remove CV timezone workaround check as no longer applicable
****************************************************************************************/

BEGIN -- Main
SET NOCOUNT ON

DECLARE @RC int
	,@ErrorMsg nvarchar(512)
	,@v10client bit
	,@DisableAdv bit

DECLARE @QTable TABLE (Qtxt varchar(500))
--------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DisableAdv', @DisableAdv OUTPUT, @quiet = 1

IF @DisableAdv = 1
BEGIN
	PRINT 'UBSMWE: usp_CVKickService: DisableAdv = 1 - skipping usp_CVKickService call'
	RETURN 0
END

INSERT INTO @QTable
EXEC @RC = master..xp_cmdshell 'SC QUERY "GXHSM Recaller(Instance001)"'

IF EXISTS (SELECT 1
			FROM @QTable
			WHERE Qtxt LIKE '%SERVICE_NAME: GXHSM Recaller(Instance001)%') 
	SET @v10client = 1
ELSE
	SET @v10client = 0

----------------------------------------

IF @action = 1 -- REPORT CV
BEGIN
		PRINT 'CommVault Service status:'

		DELETE FROM @QTable

		INSERT INTO @QTable
		EXEC @RC = master..xp_cmdshell 'SC QUERY GxEvMgrC(Instance001)'
		IF @RC <> 0
			GOTO END_IT

		IF @v10client = 1
		BEGIN
			INSERT INTO @QTable
			EXEC @RC = master..xp_cmdshell 'SC QUERY "GXHSM Recaller(Instance001)"' -- Simpana 10 only
			
			IF @RC <> 0
				GOTO END_IT
		END

		INSERT INTO @QTable
		EXEC @RC = master..xp_cmdshell 'SC QUERY GxCVD(Instance001)'
		IF @RC <> 0
			GOTO END_IT

		-- Verify CV Services are running
		IF (SELECT COUNT(*)
			FROM @QTable
			WHERE Qtxt LIKE '%RUNNING%') <> (CASE @v10client
												WHEN 1 THEN 3
												ELSE 2
											END)
		BEGIN
			PRINT 'UBSMWE: usp_CVKickService: CommVault Client service(s) not running - consequently DB backups will not occur. Investigation required'
				+ ' - run EXEC DBServices..usp_CVKickService @action=1 to view status'
			RETURN 999
		END
		ELSE 
			PRINT 'UBSMWE: usp_CVKickService: OK - CommVault Client services are running'
END --------------------
ELSE 
IF @action = 2 -- STOP CV
BEGIN
		PRINT 'Stopping CommVault Services'
		EXEC @RC = master..xp_cmdshell 'SC STOP GxEvMgrC(Instance001)', no_output
		IF @RC NOT IN (0,1062)
			GOTO END_IT

		IF @v10client = 1
		BEGIN -- Simpana 10 only
			EXEC @RC = master..xp_cmdshell 'SC STOP "GXHSM Recaller(Instance001)"', no_output
			IF @RC NOT IN (0,1062)
				GOTO END_IT
		END

		EXEC @RC = master..xp_cmdshell 'SC STOP GxCVD(Instance001)', no_output
		IF @RC NOT IN (0,1062)
			GOTO END_IT
END --------------------
ELSE 
IF @action = 3 -- START CV
BEGIN	
		PRINT CHAR(13) + 'Starting CommVault Services'

		WAITFOR DELAY '00:00:05'
			
		EXEC @RC = master..xp_cmdshell 'SC START GxCVD(Instance001)', no_output
		IF @RC NOT IN (0,1056)
			GOTO END_IT

		IF @v10client = 1
		BEGIN -- Simpana 10 only
			EXEC @RC = master..xp_cmdshell 'SC START "GXHSM Recaller(Instance001)"', no_output
			IF @RC NOT IN (0,1056)
				GOTO END_IT
		END

		EXEC @RC = master..xp_cmdshell 'SC START GxEvMgrC(Instance001)', no_output
		IF @RC NOT IN (0,1056)
			GOTO END_IT
END --------------------
IF @action = 4 -- RESTART CV Services
BEGIN
	EXEC @RC = DBServices.dbo.usp_CVKickService @action=2 --stop
	IF @RC <> 0
		GOTO END_IT

	WAITFOR DELAY '00:00:30'

	EXEC @RC = DBServices.dbo.usp_CVKickService @action=3 --start
	IF @RC <> 0
		GOTO END_IT

	WAITFOR DELAY '00:00:15'

	EXEC @RC = DBServices.dbo.usp_CVKickService @action=1 --report

	RETURN @RC -- return status
END --------------------
ELSE 
IF @action NOT IN (1,2,3,4)
BEGIN
	PRINT 'UBSMWE: usp_CVKickService: Invalid @action value: ' + CAST(@action as char(1)) + ' - options: 1= Query, 2=Stop, 3=Start, 4=Restart'
	RETURN 1
END

RETURN 0

----------------------------------------
END_IT:

SET  @ErrorMsg = 'UBSMWE: usp_CVKickService: Failed to perform action: '
					+ CASE @action -- 1=Report, 2=Stop, 3=Start, 4=Restart
						WHEN 1 THEN 'REPORT'
						WHEN 2 THEN 'STOP'
						WHEN 3 THEN 'START'
						WHEN 4 THEN 'RESTART'
						ELSE 'WTF?'
					END
				+ ' - run EXEC DBServices..usp_CVKickService @action=1 to view status'
EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning
RETURN 1

END -- Main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVList]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE  PROCEDURE [dbo].[usp_CVList] (
			@CVClient nvarchar(128) = NULL
			,@CVInstance nvarchar(128) = NULL
			,@subclientName nvarchar(128)= NULL
			,@backupsetName nvarchar(128)= NULL
			,@CommCell nvarchar(128) = NULL --if another CommCell must be referenced.
			,@Quiet bit = 0
			,@Force bit = 1)
AS

/****************************************************************************************
// @File: usp_CVList.SQL
//
// Purpose:
//   Perform a listing of objects on CommVault side. This stored procedure also updates
//   dbsCVSubclients table with latest config data.
// Notes: This stored procedure is called by other stored procedures or can be called by user
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 07/10/2013 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 07/10/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.5 @Action: Perform CommVault Subclient Listing Operations
//   @Date: 26/05/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9.3 @Action: Bugfix, Subclient Listing Operations GUID mismatch
//   @Date: 05/06/2014 @Author: Chris Basson / Andrew Calvett @Version 5.0.11 @Action: Update for new GROUP subclient
//   @Date: 13/08/2014 @Author: Chris Basson @Version: 6.0.0.2 @Action: TRRv3 Beta
//   @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta
//   @Date: 21/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta
//   @Date: 02/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.9 @Action: TRRv3 Beta
//   @Date: 02/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta
//   @Date: 06/01/2015 @Author: Chris Basson @Version: 6.0.0.20 @Action: TRR-111
//   @Date: 03/06/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: Simpana 10 client
//   @Date: 09/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Handle BRAT output duplicates
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//   @Date: 06/08/2015 @Author: Chris Basson @Version: 6.0.0.37 @Action: Workaround for TRR-138
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE
	@ControlCmd nvarchar(max)
	,@counter int
	,@CVFQDNCommCell nvarchar(128)
	,@dbsDatabaseIsSystemObjectFlag bit
	,@dbsDatabaseUID uniqueidentifier
	,@dbsInstanceFileLocation nvarchar(128)
	,@dbsRecovery nvarchar(15) 
	,@dbsSubclientName nvarchar(128)
	,@DefaultRetrys int
	,@isSingleSubclient bit
	,@RC int
	,@response nvarchar(max)
	,@rstring nvarchar(128)
	,@SQL nvarchar(max)
	,@tempFile nvarchar(255)
	,@tempString nvarchar(255)
	,@tmpdatabaseName nvarchar(128)
	,@SQLdatabaseName nvarchar(128)
	,@tmpinstanceName nvarchar(128)
	,@tmpstr varchar(8000)
	,@tmpsubclientName nvarchar(128)
	,@ErrorMsg nvarchar(255)
	,@CVOut_delimiter char(1)
	,@CVFile_delimiter char(1)
	,@dbsBackupProcessor tinyint
	,@LocalDataStaleMins tinyint
	,@CV_BRATPath varchar(128)

SET @LocalDataStaleMins = 10
SET @CVFile_delimiter = ' '
SET @CVOut_delimiter = ','

SET @backupsetName = LTRIM(RTRIM(@backupsetName))
SET @subclientName = LTRIM(RTRIM(@subclientName))
SET @CommCell = LTRIM(RTRIM(@CommCell))

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CV_BRATPath OUTPUT

-----------------------------------------------------------------------------------
-- Get client info
EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
IF @Quiet = 0
BEGIN
	PRINT 'Client:' + @CVClient
	PRINT 'InstanceName: ' + @CVInstance
	
	IF ISNULL(@backupsetName, '') <> ''
		PRINT 'BackupSet: ' + @backupsetName

	IF ISNULL(@subclientName, '') <> ''
		PRINT 'SubclientName: ' + @subclientName
END

--------------------------------------
-- Verify inputs

IF ISNULL(@CVInstance,'') = ''
	AND ISNULL(@backupsetName,'') = ''	
BEGIN
	PRINT '--usage:'
	PRINT 'EXEC DBServices..[usp_CVList] '
	PRINT '			@CVClient = ' + '''' + @CVClient + '''' +'			--client name /list client wide content.'
	PRINT '			,@CVInstance =' + '''' + @CVInstance + '''' + '		--instance name /list instance wide contents.'
	PRINT '			,@subclientName =' + '''' + '<Subclient>' + '''' + '			--subclient name /list specific subclient contents.'
	PRINT '			--,@backupsetName =' + '''' + '<backupset>' + '''' + '		--backupset name /if looking for objects on File System Agent.'
	PRINT '			--,@CommCell = ' + '''' + '<commcell>' + '''' + '			--if another CommCell must be referenced.'
	PRINT '			--,@Force=1							--Force execution; by default if a CVList has executed within the last few minutes it will skip to reduce overhead.'

	RETURN 1
END

-- Skip cv_list if it last executed within @LocalDataStaleMins

IF @Force=0
	AND (SELECT DATEDIFF (minute, MAX([dbsSubclientUpdateDate]), getdate())
		FROM [DBServices].[dbo].[dbsCVSubclients]) <= @LocalDataStaleMins
BEGIN
	IF @Quiet = 0
		PRINT 'UBSMWE: usp_CVList: Skipping request as local data is less than ' + CAST(@LocalDataStaleMins as varchar(3))
			+ ' minutes old; if you wish to force execution specify the parameter @Force=1'
	
	RETURN 0
END

--------------------------------------
--check if cv_cmdshell exists

IF NOT EXISTS (SELECT 1 FROM [DBServices].[sys].[objects] WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @ErrorMsg = 'UBSMWE: usp_CVList: [DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1 '
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	GOTO handle_error
END

--------------------------------------
-- check BRAT ver

EXEC @RC = [DBServices].[dbo].[usp_CVBRATchk] @dbsBackupProcessor = @dbsBackupProcessor, @Quiet = 1
IF @RC <> 0 
BEGIN	
	SET @ErrorMsg = 'UBSMWE: usp_CVList: Error - Incorrect BRAT version identified for operation'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	GOTO handle_error
END

--------------------------------------

IF ISNULL(@CommCell,'') = ''
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT
ELSE
	SET @CVFQDNCommCell=@CommCell

--------------------------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

IF NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'
SET @rstring=''
EXEC [DBServices].[dbo].[usp_Gen_rnd_filename] N'_CVList', @rstring OUTPUT
SET @tempFile = @dbsInstanceFileLocation + @rstring  

IF @Quiet = 0
	PRINT 'TempFile: ' + @tempFile

-----------------------------------------------------------------------------------
Jobstatus:

IF ISNULL(@backupsetName, '') = ''
BEGIN
	-- SQL iDA
	
	SET @ControlCmd = N'.\Brat\bin\cvcfglist -type mssql -clientName ' + @CVClient

	IF ISNULL(@CVInstance, '') <> ''
		SET @ControlCmd = @ControlCmd + ' -instanceName ' + @CVInstance
END --------------------------------------
ELSE
BEGIN
	-- FS iDA
	
	SET @ControlCmd = N'.\Brat\bin\cvcfglist -type filesystem -clientName ' + @CVClient
					+ ' -backupSetName ' + @backupsetName
END

IF ISNULL(@subclientName, '') <> '' 
	SET @ControlCmd = @ControlCmd + ' -subclientName ' + @subclientName 

SET @ControlCmd = @ControlCmd +  ' -subclient -content -cs ' + @CVFQDNCommCell + ' > ' + @tempFile

IF @Quiet = 0
BEGIN
	PRINT 'cd "' + @CV_BRATPath + '"'
	PRINT @ControlCmd
END

EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
	@ControlCmd,
	@response = @response OUTPUT
	
IF @RC <> 0
BEGIN
	SET @ErrorMsg = 'Could not run object list, commcell might have been down during this operation, please check. '
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO handle_error
END --------------------------------------
ELSE
IF @Quiet = 0
	PRINT 'CV List completed successfully'

--------------------------------------

WAITFOR DELAY '00:00:05'

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

CREATE TABLE #tmp (
	line varchar(8000))

SET @SQL = 'BULK INSERT #tmp
    FROM ''' + @tempFile + '''
    WITH (FirstRow = 1, FieldTerminator = ' 
		+ '''' + @CVFile_delimiter + '''' 
		+ ', RowTerminator = ' + '''' + '\n'+ '''' + ')'

EXEC (@SQL)

IF OBJECT_ID('tempdb..#CV_OBJECTS') IS NOT NULL 
	DROP TABLE #CV_OBJECTS

CREATE TABLE #CV_OBJECTS (
		instanceName nvarchar(128)
		,subclientName nvarchar(128)
		,databaseName nvarchar(128))

DECLARE procver_cur CURSOR FORWARD_ONLY FOR
SELECT line 
FROM #tmp
OPEN procver_cur

FETCH NEXT FROM procver_cur INTO @tmpstr
WHILE (@@fetch_status <> -1)
BEGIN

	SET @tmpstr= 
		REPLACE(
			REPLACE(
				REPLACE(
					REPLACE(
						REPLACE(
							REPLACE(@tmpstr,'  ',@CVOut_delimiter)
						,' ',@CVOut_delimiter)
					,',','<>')
				,'><','')
			,'<>',@CVOut_delimiter)
		, ', ',@CVOut_delimiter)

	--------------------------------------
	--collect BACKUP MEDIA INFO

    IF  LEN(@tmpstr) > 0
    BEGIN
        SELECT @tmpinstanceName= Value FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) WHERE RowID = 1
        SELECT @tmpsubclientName= Value FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) WHERE RowID = 2
        SELECT @tmpdatabaseName= Value FROM dbo.fn_Split(@CVOut_delimiter ,@tmpstr ) WHERE RowID = 3
		
		INSERT INTO #CV_OBJECTS VALUES (                 
			 @tmpinstanceName
			,@tmpsubclientName
			,@tmpdatabaseName
			)
	END
    FETCH NEXT FROM procver_cur INTO @tmpstr
END

CLOSE procver_cur
DEALLOCATE procver_cur

-----------------------------------------------------------------------------------
--DISPLAY RESULTS

IF @Quiet = 0
BEGIN
	PRINT CHAR(13)
	PRINT '-----------------------------------------------------------------------------------'
	PRINT CHAR(13)

	SELECT DISTINCT *
	FROM #CV_OBJECTS
	
	SELECT @counter = COUNT(DISTINCT databaseName)
	FROM #CV_OBJECTS
	
	PRINT 'Count: ' + CAST(@counter as varchar(3))

	PRINT CHAR(13)
	PRINT '-----------------------------------------------------------------------------------'
END

--------------------------------------
--update local table with current Subclient configuration data

IF ISNULL(@backupsetName, '') = ''
BEGIN
	IF UPPER(CONVERT(sysname, SERVERPROPERTY('ServerName'))) = UPPER(@CVInstance) 
	BEGIN
		-- Local SQL iDA
				
		IF @Quiet = 0
			PRINT '- Updating local tables...'
				
		EXEC @RC = dbo.usp_chktbllock 'DBServices', 'dbsCVSubclients'
		IF @RC <> 0
		BEGIN
			SET @ErrorMsg =  N'UBSMWE: usp_CVList: Failed to update [DBServices]..[dbsCVSubclients]'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
			
			GOTO handle_error
		END
		
		--------------------------------------	
		--update subclient data
		
		DECLARE update_cur CURSOR FORWARD_ONLY FOR 
		SELECT DISTINCT instanceName, subclientName, databaseName
		FROM #CV_OBJECTS
		OPEN update_cur

		FETCH NEXT FROM update_cur 
			INTO @tmpinstanceName, @tmpsubclientName, @tmpdatabaseName
		WHILE (@@fetch_status <> -1)
		BEGIN
			SET @isSingleSubclient = 1
			IF CHARINDEX('_SQL_TRANSACTIONAL',UPPER(@tmpsubclientName)) <> 0 
				OR CHARINDEX('_SQL_SIMPLE',UPPER(@tmpsubclientName)) <> 0 
				OR CHARINDEX('_SQL_GROUP',UPPER(@tmpsubclientName)) <> 0 
				SET @isSingleSubclient = 0

			SET @dbsDatabaseUID = NULL
			
			SELECT TOP 1 @dbsDatabaseUID = db.dbsDatabaseUID         
			FROM [DBServices].[dbo].[dbsDatabase] db
			WHERE (db.dbsDatabaseName = @tmpdatabaseName
					OR db.dbsDatabaseName = @tmpdatabaseName + ' *OFFLINE*')
			ORDER BY db.dbsDatabaseCreateDate DESC

			IF @dbsDatabaseUID IS NULL 
			BEGIN 
				IF @Quiet = 0
				BEGIN
					SET @ErrorMsg =  N'UBSMWE: usp_CVList: Failed to update Subclient data in [DBServices]..[dbsCVSubclients] for ' 
						+ @tmpdatabaseName + ', DBName mismatch in [DBServices]..[dbsDatabase]'

					EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
				END
				GOTO NEXT_DB 
			END

			--------------------------------------				             
			SET @dbsDatabaseIsSystemObjectFlag =0                 
			IF db_id(@tmpdatabaseName) < 5
				SET @dbsDatabaseIsSystemObjectFlag = 1      
			
			IF EXISTS (SELECT TOP 1 1 FROM [DBServices].[dbo].[dbsCVSubclients]
				WHERE dbsDatabaseUID = @dbsDatabaseUID )
			BEGIN 
				-- Existing entry
				SET LOCK_TIMEOUT 3000
				UPDATE [DBServices].[dbo].[dbsCVSubclients]
				SET	[dbsDatabaseName] = @tmpdatabaseName,
					[dbsDatabaseIsSystemObjectFlag] = @dbsDatabaseIsSystemObjectFlag,
					[dbsSubclientUpdateDate] =getdate(),
					[dbsUserAdded] = suser_sname(),
					[dbsSubclientName] = @tmpsubclientName,
					[dbsDatabaseIsOndemandFlag] = @isSingleSubclient
				WHERE dbsDatabaseUID = @dbsDatabaseUID
			END --------------------------------------
			ELSE
			BEGIN 
				-- New entry
				SET LOCK_TIMEOUT 1000
				INSERT INTO [DBServices].[dbo].[dbsCVSubclients]
				VALUES(@dbsDatabaseUID
					,@tmpdatabaseName
					,@dbsDatabaseIsSystemObjectFlag
					,getdate()
					,suser_sname()
					,@tmpsubclientName
					,@isSingleSubclient)
			END  

			NEXT_DB:                  
			FETCH NEXT FROM update_cur
				INTO  @tmpinstanceName, @tmpsubclientName, @tmpdatabaseName
		END
		CLOSE update_cur
		DEALLOCATE update_cur

		--------------------------------------
		-- Workaround for TRR-138

		IF @Quiet = 0
			AND EXISTS (SELECT 1
					FROM [DBServices].[dbo].[dbsDatabase] db
					INNER JOIN sys.sysdatabases sd WITH (NOLOCK)
						ON db.dbsDatabasedbid = sd.dbid
					INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbs
						ON dbs.dbsDatabaseUID = db.dbsDatabaseUID
					WHERE LOWER(sd.name) = LOWER(dbs.dbsDatabaseName)
						AND sd.name <> dbs.dbsDatabaseName COLLATE Latin1_General_CS_AS
						AND db.dbsDatabaseIsActive = 1)
		BEGIN
			PRINT CHAR(13)
			SET @ErrorMsg =  N'UBSMWE: usp_CVList: WARNING - CV DB name mismatch (case sensitive) identified; for more details run: EXEC DBService..usp_HealthChk and contact Backup Services to address the issue'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

			SELECT
				ISNULL(sd.name, '*unidentified*') 'SQL DB Name'
				, CASE db.dbsDatabaseIsActive
						WHEN 0 THEN 'N'
						WHEN 1 THEN 'Y'
						ELSE '?'
					END 'Active'
				,ISNULL(dbs.dbsDatabaseName, '*unidentified*') 'CV Subclient DB name'
			FROM [DBServices].[dbo].[dbsDatabase] db
			INNER JOIN sys.sysdatabases sd WITH (NOLOCK)
				ON db.dbsDatabasedbid = sd.dbid
			INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbs
				ON dbs.dbsDatabaseUID = db.dbsDatabaseUID
			WHERE LOWER(sd.name) = LOWER(dbs.dbsDatabaseName)
				AND sd.name <> dbs.dbsDatabaseName COLLATE Latin1_General_CS_AS 
			ORDER BY db.dbsDatabaseCreateDate DESC
		END

	END --------------------------------------
	ELSE
	IF @Quiet = 0
		PRINT 'Info: ' + CONVERT(sysname, SERVERPROPERTY('ServerName')) + ' <> ' + @CVInstance + ' - Skipping update of local tables'
END
-----------------------------------------------------------------------------------
batch_end:

--Tidyup 
IF object_id('tempdb..#CV_OBJECTS') IS NOT NULL
	DROP TABLE #CV_OBJECTS
IF object_id('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

-- Tidy up temp file
EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @tempFile

RETURN 0

--------------------------------------
handle_error:

-- clean up after the error
PRINT 'For additional details see the latest log file located in C:\TEMP\cvcfglist.exe' 
	+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

--Tidyup 
IF object_id('tempdb..#CV_OBJECTS') IS NOT NULL
	DROP TABLE #CV_OBJECTS
IF object_id('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp
-- Leave output file for investigation

RETURN 1

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVList_local]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVList_local]
AS

/****************************************************************************************
// @File: usp_CVList_local.SQL
//
// @Version 6.0.0.9 
//
// Purpose:
//   Perform a listing of objects on CommVault side for the local host
// Notes: This stored procedure is called by other stored procedures or can be called by user
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 15/08/2014 @Author: Chris Basson @Version 6.0.0.3 TRRv3 Beta
//   @Date: 31/10/2014 @Author: Chris Basson @Version 6.0.0.9 TRRv3 Beta
****************************************************************************************/

BEGIN -- main
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @CVClient nvarchar(128) 
	 ,@CVInstance nvarchar(128) 

EXEC [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
									,@CVInstance = @CVInstance OUTPUT 

EXEC [DBServices].[dbo].[usp_CVList] @CVClient = @CVClient
									,@CVInstance = @CVInstance
									,@Force=1
END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVReport]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVReport] (
							@DBName sysname = NULL
							,@CVClient nvarchar(128) = ''
							,@CVInstance nvarchar(128) = ''
							,@StartTime varchar(30) = NULL
							,@EndTime varchar(30) = NULL
							,@JobID nvarchar(30) = NULL
							,@BackupType char(1) = NULL
							,@details int = 0       --once you identified the backup_Set_id get more details by setitng to 1
							,@ScriptRestore int = 0 --once specific object is chosen allows generation of restore statement.
							,@commcell varchar(128) = NULL
							)
AS

/****************************************************************************************
// @File: usp_CVReport.sql
//
// Purpose:
//   Perform object lookup operation on CommCell
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase or via Manual call
//
// Usage: 
       exec [DBServices].[dbo].[usp_CVReport]' 
		,@DBName = <DBNAME OF BACKED UP DATABASE>			--database name at the time of backup'
		,@CVClient = <CLIENT WHERE OPERATION OCCURED>			--host where backup was taken'
		,@CVInstance = <INSTANCE WHERE BACKUP OCCURED IF ANY>	--if backup wa son a named instance'
		,@StartTime  = "YYYY/MM/DD HH:MM:SS					--daterange start for object search'
		,@EndTime  = "YYYY/MM/DD HH:MM:SS"					--daterange end for object search'
		,@JobID = 1234567									--backup job if know can be used'
		,@details = 1   									--used to get object info'              
		,@ScriptRestore  = 1								--generate a restore script'
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: 4.1.0 @Action: Perform CommVault lookups
//   @Date: 07/03/2014 @Author: Chris Basson @Version: 5.0.9.1 @Action: Report parsing bug fix 
//   @Date: 23/06/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta 
//   @Date: 13/08/2014 @Author: Chris Basson @Version: 6.0.0.2 @Action: TRRv3 Beta 
//   @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta 
//   @Date: 20/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta 
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta 
//   @Date: 12/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 bugfix
//   @Date: 02/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 
//   @Date: 12/12/2014 @Author: Chris Basson @Version: 6.0.0.15 @Action: TRRv3 
//   @Date: 18/12/2014 @Author: Chris Basson @Version: 6.0.0.19 @Action: TRRv3 TRR-109
//   @Date: 02/06/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: Simpana 10 client support
//   @Date: 28/07/2015 @Author: Chris Basson @Version: 6.0.0.36 @Action: Parsing workaround when JobID > 9999999
//   @Date: 06/08/2015 @Author: Chris Basson @Version: 6.0.0.37 @Action: Workaround for TRR-138
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @ColCount int
		,@CRLF char(2)
		,@CVFQDNCommCell varchar (128)
		,@dbsInstanceFileLocation varchar(128)
		,@DeviceCount int
		,@devicelist varchar(max)
		,@i_EndTime char(19)
		,@i_StartTime char(19)
		,@LocatedObjectTime varchar(40)
		,@logicalname varchar(1000)
		,@message nvarchar(255)
		,@OperationStartTime datetime
		,@physicalpath varchar(1000)
		,@RC int
		,@response nvarchar(max)
		,@rstring nvarchar(128)
		,@searchCmd nvarchar(max)
		,@SQL nvarchar(max)
		,@tempFile varchar(255)
		,@tempflt float
		,@tempString nvarchar(255)
		,@tmpbackup_finish_date varchar(20)
		,@tmpbackup_set_id varchar(20)
		,@tmpbackup_size varchar(21)
		,@tmpbackup_start_date varchar(20)
		,@tmpBackupMethod varchar(5)
		,@tmpBackupType char(1)
		,@tmpDatabaseName nvarchar(200)
		,@tmpGroupName nvarchar(128)
		,@tmpjobid varchar(20)
		,@tmpLogicalName nvarchar(128)
		,@tmpnumber varchar(4)
		,@tmppageSize varchar(20)
		,@tmpPhysicalPath varchar(255)
		,@tmpstr varchar(8000)
		,@tmpTime varchar(8)
		,@tmpType varchar(2)
		,@UTCDT datetime
		,@HostDT datetime
		,@UTCoffset smallint
		,@tmpDT datetime
		,@CVFile_delimiter char(1)
		,@CVOut_delimiter char(1)
		,@CV_BRATPath varchar(128)

SET @CVFile_delimiter = ' ' -- space  CHAR(32)
SET @CVOut_delimiter = ' ' -- space  CHAR(32)

--------------------------------------------------------------------------------    
-- Verifiy params
      
SET @BackupType = UPPER(@BackupType)
IF 	(@BackupType IS NOT NULL 
		AND @BackupType NOT IN ('L','I','D','F'))
	PRINT 'Invalid backup type filter specified - options: L(logs), I(incrementals), D(fulls), F(both incrementals and fulls)'

IF (ISNULL(@DBName,'') = ''
	AND ISNULL(@JobID,'') = '')
	OR 
	(@BackupType IS NOT NULL 
		AND @BackupType NOT IN ('L','I','D','F'))
	OR (@ScriptRestore = 1
		AND (ISNULL(@DBName,'') = ''
		OR ISNULL(@JobID,'') = ''))
BEGIN
	PRINT 'Please verifiy your input parameters:' 
	PRINT ''
	PRINT 'EXEC [DBServices].[dbo].[usp_CVReport]' 
	PRINT '	@DBName = <DBNAME OF BACKED UP DATABASE>			--Database to query'
	PRINT '	,@CVClient = <CLIENT WHERE OPERATION OCCURRED>		--Host name where backup was taken'
	PRINT '	,@CVInstance = <INSTANCE WHERE BACKUP OCCURRED>		--If backup was on a named instance'
	PRINT '	,@StartTime  = '+''''+'YYYY/MM/DD HH:MM:SS'+''''+'				--Date range start for object search (default 1 month)'
	PRINT '	,@EndTime  =  '+''''+'YYYY/MM/DD HH:MM:SS'+''''+'					--Date range end for object search'
	PRINT '	,@JobID = 1234567									--Backup JobID if know'
	PRINT '	,@BackupType = <L|I|D|F>							--Backuptype filter to apply on results'
	PRINT '	,@details = 1   									--Detailed object info'              
	PRINT '	,@ScriptRestore = 1									--Generates a restore script, prerequisite: @DBName and @JobID'
	PRINT '	--,@commcell = <commcell>							--Specify a commcell'
	PRINT ''

	RETURN 1
END

SET @StartTime = LTRIM(RTRIM(@StartTime))
SET @EndTime = LTRIM(RTRIM(@EndTime))
SET @JobID = LTRIM(RTRIM(@JobID))
SET @commcell = LTRIM(RTRIM(@commcell))

----------------------------------------
--check if cv_cmdshell exists
IF NOT EXISTS (SELECT * FROM [DBServices].[sys].[objects] WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @message = 'UBSME: usp_CVReport: [DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1'
    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1

	RETURN 1
END

----------------------------------------
                     
--identify Locale
SET @UTCDT = GETUTCDATE() 
SET @HostDT = GETDATE()
SET @UTCoffset = CAST(DATEDIFF(Hour, GETUTCDATE(),@HostDT) as smallint)

PRINT '-------------------------------------------------'
PRINT 'UTCTime:   ' + CAST(@UTCDT as varchar(30))
PRINT 'Localtime: ' + CAST(@HostDT as varchar(30))
PRINT 'UTCoffset: ' + CAST(@UTCoffset as varchar(3))
PRINT '-------------------------------------------------'

SET @CRLF = CHAR(13) + CHAR(10)

IF ISNULL(@commcell,'') <> '' 
	SET @CVFQDNCommCell = @commcell
ELSE
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CV_BRATPath OUTPUT
	

--------------------------------------------------------------------------------
-- Get config

IF RIGHT(@dbsInstanceFileLocation, 1) <> '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

SET @rstring = ''

EXEC dbo.usp_Gen_rnd_filename N'_cvreport', @rstring OUTPUT

SET @tempFile = @dbsInstanceFileLocation + @rstring 
PRINT 'Temp File: ' + @tempFile

--load configuration values
EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
PRINT 'Client: ' + @CVClient 
PRINT 'Instance: ' + @CVInstance

----------------------------------------
-- TRR-138: If local instance and input DB name specified; verify against CV DB name 

IF @CVInstance = CONVERT(sysname, SERVERPROPERTY('ServerName'))
	AND ISNULL(@DBName,'') <> ''
BEGIN
	-- Obtain actual CV DB name from Subclient data (case sensitive)
	SELECT TOP 1 @tmpDatabaseName = dbs.dbsDatabaseName 
	FROM [DBServices].[dbo].[dbsDatabase] db
	INNER JOIN sys.sysdatabases sd WITH (NOLOCK)
		ON db.dbsDatabasedbid = sd.dbid
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbs
		ON dbs.dbsDatabaseUID = db.dbsDatabaseUID
	WHERE LOWER(sd.name) = LOWER(@DBName)
	ORDER BY db.dbsDatabaseCreateDate DESC

	IF @tmpDatabaseName <> @DBName COLLATE Latin1_General_CS_AS 
		PRINT + CHAR(13) + 'UBSMWE: usp_CVReport: WARNING - CV DB name mismatch (case sensitive); input @DBName: "' + @DBName 
			+ '" => CV DB name: "' + ISNULL(@tmpDatabaseName, '*** unidentified or offline ***') + '"'
			+ CHAR(13) + 'Please verify your input parameters as incorrect results may be returned'
			+ 'Contact Backup Services if further investigation is required' + CHAR(13)
END
ELSE
	PRINT CHAR(13) + 'Please be aware CV DB names are case sensitive, if unexpected results are returned please contact Backup Services as there could simply be a case mismatch' + CHAR(13)

----------------------------------------
--verify correct date range or set default one (past 30 days)

IF ISDATE(@StartTime) <> 1
BEGIN
    SET @tmpDT = DATEADD(MONTH, -1, @HostDT)

    SET @StartTime = CONVERT(char(4), DATEPART(yyyy, @tmpDT)) 
		+ '/' + CONVERT(char(2), DATEPART(mm, @tmpDT)) 
		+ '/' + CONVERT(char(2), DATEPART(dd, @tmpDT))
		+ ' 00:00'

	PRINT 'Info: Valid @StartTime was not provided - defaulting: ' + @StartTime 
END

IF ISDATE(@EndTime) <> 1
BEGIN
    SET @tmpDT = DATEADD(DAY, 1, @HostDT)

    SET @EndTime = CONVERT(char(4), DATEPART(yyyy, @tmpDT)) 
		+ '/' + CONVERT(char(2), DATEPART(mm, @tmpDT)) 
		+ '/' + CONVERT(char(2), DATEPART(dd, @tmpDT))
		+ ' 00:00'

	PRINT 'Info: Valid @EndTime was not provided - defaulting: ' + @EndTime 
END

SET @OperationStartTime = @HostDT

--------------------------------------------------------------------------------
--search protected media

SET @searchCmd = N'.\Brat\bin\cvrestore.exe -type mssql -browse -instanceName ' + @CVInstance 
				+ ' -clientName ' + LOWER(@CVClient) 

-- Format time to BRAT dodgy time (char(19))

SET @i_StartTime = DBServices.dbo.ufn_BRATTime(CAST(@StartTime as datetime))
SET @i_EndTime = DBServices.dbo.ufn_BRATTime(CAST(@EndTime as datetime))

IF @i_StartTime = 'DTError'
	OR @i_EndTime = 'DTError'
BEGIN
	PRINT 'UBSMWE: usp_CVReport: Error in parsing Start / End times'
	RETURN 1
END

SET @searchCmd = @searchCmd + ' -fromTimeValue "'
	+ @i_StartTime +  '" -toTimeValue "' + @i_EndTime + '" '

IF ISNULL(@DBName,'') <> ''
	SET @searchCmd = @searchCmd + ' -database ' + @DBName 

SET @searchCmd = @searchCmd + ' -cs ' + @CVFQDNCommCell + ' > ' + @tempFile 

PRINT 'cd "' + @CV_BRATPath + '"'
PRINT @searchCmd

EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
							@searchCmd,
							@response = @response OUTPUT
IF @RC <> 0
BEGIN
    SET @message = 'UBSME: usp_CVReport: Could not run the report, '
					+ 'for additional details see the BRAT log file C:\TEMP\cvrestore.exe' 
					+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1

    GOTO handle_error
END
ELSE
	PRINT @response

--------------------------------------------------------------------------------
-- Parse BRAT output
-- Code is bodged MESS - due to an unprofessional BRAT output file and REFUSAL to use a char delimiter 

WAITFOR DELAY '00:00:05' -- wait for BRAT output file to flush

EXEC [DBServices].[dbo].[usp_FileExists] @FileName = @tempFile, @exists = @RC OUTPUT
IF @RC = 0 
BEGIN
    SET @message = 'UBSME: usp_CVReport: BRAT output file ' + @tempFile + ' was not found;'
					+ ' for additional details see the BRAT log file C:\TEMP\cvrestore.exe' 
					+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1

    GOTO handle_error
END

-- section declarations
IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

CREATE TABLE #tmp (line nvarchar(4000))

SET @SQL = 'BULK INSERT #tmp
    FROM ''' + @tempFile + '''
    WITH (FirstRow = 1, FieldTerminator = ' 
		+ '''' + @CVFile_delimiter + ''''
		+ ', RowTerminator = ' + '''' + '\n'+ '''' +')'
EXEC (@SQL)

IF OBJECT_ID('tempdb..#CV_DEVICES') IS NOT NULL 
	DROP TABLE #CV_DEVICES

CREATE TABLE #CV_DEVICES (
                     jobid varchar(20)
                    ,DatabaseName nvarchar(128)
                    ,GroupName nvarchar(128)
                    ,LogicalName varchar(128)
                    ,PhysicalPath varchar(255)
                    ,number varchar(4)
                    ,pageSize varchar(20)
                    ,BackupType varchar(20) )    

IF OBJECT_ID('tempdb..#CV_RECORDS') IS NOT NULL 
	DROP TABLE #CV_RECORDS

CREATE TABLE #CV_RECORDS (
                    jobid varchar(20)
                    ,DatabaseName nvarchar(128)
                    ,BackupType char(1)
                    ,backup_size varchar(21)
                    ,backup_start_date varchar(20)
                    ,backup_finish_date varchar(20) )

DECLARE
	@bkhistdetected bit
	,@ConfigDetected bit
	,@JIDidx smallint
	,@TYPEidx smallint
	,@STARTidx smallint
	,@FINISHidx smallint
	,@SIZEidx smallint
	,@DBNAMEidx smallint
	,@GRPNAMEidx smallint
	,@LOGICALidx smallint
	,@PAGE_SIZEidx smallint
	,@NUMBERidx smallint
	,@PATHidx smallint
	,@BRATOutputOffset smallint

SET @bkhistdetected = 0
SET @ConfigDetected = 0

----------------------------------------
-- Parse do

DECLARE procver_cur CURSOR FORWARD_ONLY FOR
SELECT line
FROM #tmp
OPEN procver_cur

FETCH NEXT FROM procver_cur INTO @tmpstr
WHILE (@@fetch_status <> -1)
BEGIN 

	SET @tmpstr = RTRIM(LTRIM(@tmpstr))

	IF @bkhistdetected = 0
		AND (CHARINDEX('START' ,@tmpstr) > 1)
		AND (CHARINDEX('FINISH',@tmpstr) > 1)
		AND (CHARINDEX('SIZE',@tmpstr) > 1)
	BEGIN
		-- "JID     TYPE START                        FINISH                       SIZE            DBNAME"

		SET @bkhistdetected = 1
		SET @JIDidx = CHARINDEX('JID', @tmpstr)
		SET @TYPEidx = CHARINDEX('TYPE', @tmpstr)
		SET @STARTidx = CHARINDEX('START', @tmpstr)
		SET @FINISHidx = CHARINDEX('FINISH', @tmpstr)
		SET @SIZEidx = CHARINDEX('SIZE', @tmpstr)
		SET @DBNAMEidx = CHARINDEX('DBNAME', @tmpstr)
	END --------------------
	ELSE
	IF @bkhistdetected = 1
		AND @ConfigDetected = 0
		AND LEN(@tmpstr) > 13 
		AND @tmpstr <> 'CONFIGURATION'
		AND (CHARINDEX ('START' ,@tmpstr) = 0)
		AND (CHARINDEX ('FINISH', @tmpstr) = 0)
		AND (CHARINDEX ('SIZE', @tmpstr) = 0)
		AND (CHARINDEX ('GRPNAME', @tmpstr) = 0)
	BEGIN    ---collect BACKUP MEDIA INFO

		-- example:
		-- "JID     TYPE START                        FINISH                       SIZE            DBNAME"
		-- "29470   I    2015/07/27 20:00:44          2015/07/27 20:00:44          4596736         Stuart_NI_CS_Simple
		-- "2666804 D    2014/03/04 05:05:17          2014/03/04 05:05:18          5505024         master"
		-- "10004219 D    2015/07/26 02:00:11          2015/07/26 02:00:12          11092992        DBServices"

		-- @Version: 6.0.0.36 @Action: Parsing workaround if JobID > 9999999 (due to an unprofessional BRAT output file and REFUSAL to use a char delimiter)
		IF SUBSTRING(@tmpstr,@TYPEidx, 1) NOT IN ('L','I','D')
		BEGIN
			SET @BRATOutputOffset = PATINDEX('%[^' + @CVOut_delimiter + ']%', SUBSTRING(@tmpstr,@TYPEidx, 10) ) -1

			SET @TYPEidx = @TYPEidx + @BRATOutputOffset
			SET @STARTidx = @STARTidx + @BRATOutputOffset
			SET @FINISHidx = @FINISHidx + @BRATOutputOffset
			SET @SIZEidx = @SIZEidx + @BRATOutputOffset
			SET @DBNAMEidx = @DBNAMEidx + @BRATOutputOffset
		END

		SET @tmpjobid=SUBSTRING(@tmpstr, @JIDidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @JIDidx) -@JIDidx)
        SET @tmpBackupType=SUBSTRING(@tmpstr, @TYPEidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @TYPEidx) -@TYPEidx)
        SET @tmpbackup_start_date=SUBSTRING(@tmpstr, @STARTidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @STARTidx+20) -@STARTidx)
        SET @tmpbackup_finish_date=SUBSTRING(@tmpstr, @FINISHidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @FINISHidx+20) -@FINISHidx)
        SET @tmpbackup_size=SUBSTRING(@tmpstr, @SIZEidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @SIZEidx) -@SIZEidx)
        SET @tmpDatabaseName=SUBSTRING(@tmpstr, @DBNAMEidx, LEN(@tmpstr) -@DBNAMEidx+1)

		IF ISNUMERIC(@tmpbackup_size) = 1
			OR (@details = 1 AND @ScriptRestore = 1)
		BEGIN
			INSERT INTO #CV_RECORDS
			VALUES ( 
				@tmpjobid
				,@tmpDatabaseName
				,@tmpBackupType
				,@tmpbackup_size
				,@tmpbackup_start_date
				,@tmpbackup_finish_date
				)
		END --------------------
		ELSE
		BEGIN
			PRINT 'UBSME: usp_CVReport: Parsing problem whilst processing backup info, the following line has been skipped:'
			PRINT @tmpstr
		END
	END --------------------
	ELSE
	IF	@ConfigDetected = 0
		AND @bkhistdetected = 1
		AND LEN(@tmpstr) > 13
		AND (CHARINDEX ('GRPNAME',@tmpstr) > 1)
		AND (CHARINDEX ('LOGICAL',@tmpstr) > 1)
		AND (CHARINDEX ('PAGE SIZE',@tmpstr) > 1)
	BEGIN    ---collect DEVICE INFO
		-- Found header - determining col idx

		-- "JID     TYPE DBNAME                           GRPNAME                          LOGICAL                          PAGE SIZE            NUMBER     PATH"
		SET @ConfigDetected = 1
		SET @JIDidx = CHARINDEX ('JID', @tmpstr)
		SET @TYPEidx = CHARINDEX ('TYPE', @tmpstr)
		SET @DBNAMEidx = CHARINDEX ('DBNAME', @tmpstr)
		SET @GRPNAMEidx = CHARINDEX ('GRPNAME', @tmpstr)
		SET @LOGICALidx = CHARINDEX ('LOGICAL', @tmpstr)
		SET @PAGE_SIZEidx = CHARINDEX ('PAGE SIZE', @tmpstr)
		SET @NUMBERidx = CHARINDEX ('NUMBER', @tmpstr)
		SET @PATHidx = CHARINDEX ('PATH', @tmpstr)
	END	--------------------
	ELSE
    IF @ConfigDetected = 1 
		AND @details = 1
		AND LEN(@tmpstr) > 13 
		AND (CHARINDEX ('GRPNAME',@tmpstr) = 0)
		AND (CHARINDEX ('LOGICAL',@tmpstr) = 0)
		AND (CHARINDEX ('PAGE SIZE',@tmpstr) = 0)
	BEGIN
		-- "JID     TYPE DBNAME                           GRPNAME                          LOGICAL                          PAGE SIZE            NUMBER     PATH"
		-- "2666804 D    master                           PRIMARY                          master                           4194304              1          D:\MSSQL.1\MSSQL\DATA\master.mdf"

		-- @Version: 6.0.0.36 @Action: Parsing workaround if JobID > 9999999 (due to an unprofessional BRAT output file and REFUSAL to use a char delimiter)
		IF SUBSTRING(@tmpstr,@TYPEidx, 1) NOT IN ('L','I','D')
		BEGIN
			SET @BRATOutputOffset = PATINDEX('%[^' + @CVOut_delimiter + ']%', SUBSTRING(@tmpstr,@TYPEidx, 10) ) -1

			SET @TYPEidx = @TYPEidx + @BRATOutputOffset
			SET @DBNAMEidx = @DBNAMEidx + @BRATOutputOffset
			SET @GRPNAMEidx = @GRPNAMEidx + @BRATOutputOffset
			SET @LOGICALidx = @LOGICALidx + @BRATOutputOffset
			SET @PAGE_SIZEidx = @PAGE_SIZEidx + @BRATOutputOffset
			SET @NUMBERidx = @NUMBERidx + @BRATOutputOffset
			SET @PATHidx = @PATHidx + @BRATOutputOffset
		END

		SET @tmpjobid=SUBSTRING(@tmpstr, @JIDidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @JIDidx) -@JIDidx)
		SET @tmpType=SUBSTRING(@tmpstr, @TYPEidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @TYPEidx) -@TYPEidx)
		SET @tmpDatabaseName=SUBSTRING(@tmpstr, @DBNAMEidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @DBNAMEidx) -@DBNAMEidx)
		SET @tmpGroupName=SUBSTRING(@tmpstr, @GRPNAMEidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @GRPNAMEidx) -@GRPNAMEidx)
		SET @tmpLogicalName=SUBSTRING(@tmpstr, @LOGICALidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @LOGICALidx) -@LOGICALidx)
		SET @tmppageSize=SUBSTRING(@tmpstr, @PAGE_SIZEidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @PAGE_SIZEidx) -@PAGE_SIZEidx)
		SET @tmpnumber=SUBSTRING(@tmpstr, @NUMBERidx, CHARINDEX(@CVOut_delimiter, @tmpstr, @NUMBERidx) -@NUMBERidx)
		SET @tmpPhysicalPath=SUBSTRING(@tmpstr, @PATHidx, LEN(@tmpstr) -@PATHidx +1)
        
		INSERT INTO #CV_DEVICES
		VALUES (
			@tmpjobid
            ,@tmpDatabaseName
            ,@tmpGroupName
            ,@tmpLogicalName
            ,@tmpPhysicalPath
            ,@tmpnumber 
            ,@tmppageSize 
            ,@tmpType
			)   
    END --------------------

	FETCH NEXT FROM procver_cur INTO @tmpstr
END

CLOSE procver_cur
DEALLOCATE procver_cur

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL       
	DROP TABLE #tmp

--------------------------------------------------------------------------------
--DISPLAY BACKUP RESULTS

IF ISNULL(@JobID,'') <> ''
BEGIN
	SELECT DISTINCT *
	FROM #CV_RECORDS
	WHERE jobid = @JobID
	ORDER BY backup_start_date 
END --------------------
ELSE
BEGIN
	IF ISNULL(@DBName,'') <> ''
		AND ISNULL(@BackupType,'') <> ''
	BEGIN
		IF @BackupType IN ('L','I','D') -- output specific type
			SET @SQL = 'SELECT DISTINCT *
				FROM #CV_RECORDS
				WHERE DatabaseName = ''' + @DBName
				+ ''' AND BackupType = ''' + @BackupType + '''
				ORDER by backup_start_date'
		ELSE -- Output both incrementals and fulls
			SET @SQL = 'SELECT DISTINCT *
				FROM #CV_RECORDS
				WHERE DatabaseName = ''' + @DBName 
				+ ''' AND BackupType IN (''D'',''I'')
				ORDER by backup_start_date'
		EXEC (@SQL)
	END --------------------
	ELSE
	BEGIN
		IF ISNULL(@DBName,'') <> ''
		BEGIN -- Output for DB
			SELECT DISTINCT *
			FROM #CV_RECORDS
			WHERE DatabaseName = @DBName
			ORDER by backup_start_date  
		END --------------------
		ELSE
		BEGIN -- Output all
			SELECT DISTINCT *
			FROM #CV_RECORDS
			ORDER by backup_start_date  
		END
	END --------------------
END

--------------------------------------------------------------------------------
--SCRIPT OUT RESTORE (if applicable)

IF @ScriptRestore = 1 
	AND ISNULL(@DBName, '') <> ''
	AND ISNULL(@JobID,'') <> ''
BEGIN
	SET @devicelist = ''

	SELECT TOP 1 @LocatedObjectTime = backup_finish_date -- Successful backup
	FROM #CV_RECORDS
	WHERE jobid = @JobID 
		AND DatabaseName = @DBName
	ORDER BY backup_finish_date DESC

	SELECT @DeviceCount = COUNT(DISTINCT LogicalName) -- Note unable to rely on CV device number
	FROM #CV_DEVICES
	WHERE jobid = @JobID
		AND DatabaseName = @DBName

	IF @DeviceCount = 0
		OR @DeviceCount IS NULL
	BEGIN
		PRINT 'UBSME: usp_CVReport: Parsing problem whilst processing device info, unable to create restore script'
		GOTO handle_error
	END

	DECLARE @restore TABLE (parameters nvarchar(MAX))

	IF ISNULL(@LocatedObjectTime,'') <> '' 
	BEGIN
		INSERT @restore SELECT 'EXEC [dbo].[usp_CVRestore] ' + @CRLF
		INSERT @restore SELECT       ' @SourceDB = ' + '''' + @DBName + '''' + @CRLF
		INSERT @restore SELECT         ',' + '@DBName = ' + '''' + @DBName + '''' + @CRLF
		INSERT @restore SELECT         ',' + '@objectTime = ' + '''' + @LocatedObjectTime + '''' + @CRLF
		
		INSERT @restore SELECT         ',' + '@iClient = ' + '''' + @CVClient + ''''+ @CRLF
		INSERT @restore SELECT         ',' + '@iInstance = ' + '''' + @CVInstance + '''' + @CRLF

		INSERT @restore SELECT         ',' + '@oClient = ' + '''' + @CVClient + '''' + @CRLF
		INSERT @restore SELECT         ',' + '@oInstance = ' + '''' + @CVInstance + '''' + @CRLF

		INSERT @restore SELECT         ',' + '@overwrite = ' + '0'  + @CRLF
		INSERT @restore SELECT         ',' + '@recovery = ' + '''' + 'STATE_RECOVER' + '''' + @CRLF

		INSERT @restore SELECT         '--,' + '@recoverylocation = ' + @dbsInstanceFileLocation + @CRLF
		INSERT @restore SELECT         '--,' + '@pit = 1' + @CRLF

		DECLARE deviceCursor CURSOR FAST_FORWARD FOR
		SELECT DISTINCT LogicalName, PhysicalPath
		FROM #CV_DEVICES
		WHERE jobid = @JobID 
			AND DatabaseName = @DBName
		ORDER BY LogicalName ASC
		OPEN deviceCursor

		FETCH NEXT FROM deviceCursor INTO @logicalname, @physicalpath
		WHILE @@FETCH_STATUS = 0
		BEGIN
			SET @devicelist = ',@device' + CAST(@DeviceCount as varchar(2)) + ' = ' 
				+ '''' + 'MOVE ' + @logicalname 
				+ ' TO ' + @physicalpath 
				+ ' FROM ' + @physicalpath + '''' + @CRLF

			INSERT @restore 
				SELECT @devicelist
			
			SET @DeviceCount = @DeviceCount - 1
			FETCH NEXT FROM deviceCursor INTO @logicalname, @physicalpath
		END

		CLOSE deviceCursor
		DEALLOCATE deviceCursor

		-- output to screen
		SELECT *
		FROM @restore

	END --------------------
	ELSE
		PRINT '=> No media was found matching the given parameters or possible parsing problem whilst processing device info, contact Backup Services for investigation'
END

SET @tempflt = DATEDIFF(second,@OperationStartTime, getdate())
SET @message = '=> Protected media search successfully processed in ' + CAST(@tempflt as nvarchar(40) ) + ' seconds.'
PRINT ''
PRINT @message

----------------------------------
-- Tidy up
IF OBJECT_ID('tempdb..#CV_RECORDS') IS NOT NULL
	DROP TABLE #CV_RECORDS
IF OBJECT_ID('tempdb..#CV_DEVICES') IS NOT NULL
	DROP TABLE #CV_DEVICES
IF OBJECT_ID('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @tempFile

RETURN 0

----------------------------------
handle_error:

-- clean up after the error
IF OBJECT_ID('tempdb..#CV_RECORDS') IS NOT NULL
	DROP TABLE #CV_RECORDS
IF OBJECT_ID('tempdb..#CV_DEVICES') IS NOT NULL
	DROP TABLE #CV_DEVICES
IF OBJECT_ID('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

RETURN 1
 
END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVReport_nDays]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVReport_nDays] (
				@DBName as nvarchar(255)
				, @nDays tinyint = 14)
AS

/****************************************************************************************
// @File: usp_CVReport_nDays.SQL
//
// @Version 6.0.0.3
//
// Purpose:
//   Runs a CV Backup report for a given DB on the local host for @nDays (between 1 and 93 days)
//
// Notes: This stored procedure is for users 
// Dependancies: [usp_CVReport]
// History: Date Format dd/mm/yyyy
//
//   @Date: 23/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 13/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.2 @Action: TRRv3 Beta
//   @Date: 18/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.2 @Action: TRRv3 Beta
****************************************************************************************/

BEGIN -- main
SET NOCOUNT ON
SET DATEFORMAT ymd

IF @nDays NOT BETWEEN 1 AND 93
BEGIN
	PRINT 'Unable to proceed; @nDays must be between 1 and 93 as the report places a heavy load on the CommServe'
	RETURN 1
END

DECLARE @CVClient nvarchar(128)
	, @CVInstance nvarchar(128)
	, @STime nchar(19)
	, @ETime nchar(19)
	, @str nvarchar(500)

--load configuration values

EXEC [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
										,@CVInstance = @CVInstance OUTPUT 

SET @STime = REPLACE (CONVERT(nchar(19), DATEADD(day, -@nDays, getdate()),120),'-','/')
SET @ETime = REPLACE (CONVERT(nchar(19), getdate(),120),'-','/')

PRINT 'CVreport for ' + @CVInstance + ' between ' + @STime + ' and ' + @ETime
PRINT getdate()
PRINT ''

SET @str = 'EXEC [DBServices].[dbo].[usp_CVReport] 
				@DBName = ''' + @DBName + '''    
				,@CVClient = ''' + @CVClient + '''                
				,@CVInstance = ''' + @CVInstance + '''        
				,@StartTime  = ''' + @STime + '''  
				,@EndTime  =  ''' + @ETime + ''''

EXEC (@str)

RETURN @@ERROR

END -- end main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVRestore]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVRestore] (
                                          @SourceDB sysname
                                        , @DBName sysname
                                        , @objectTime varchar(30)
                                        , @iClient nvarchar(128)
                                        , @oClient nvarchar(128)
										, @oInstance nvarchar(128)
										, @iInstance nvarchar(128)
                                        , @overwrite bit = 0
                                        , @pit bit = 0
                                        , @logs bit = 0
                                        , @recovery varchar(20) = 'STATE_RECOVER'
                                        , @recoverylocation varchar(256) = NULL
                                        , @device1 varchar(1024) = NULL  --optional for WITH MOVE functionlaity
                                        , @device2 varchar(1024) = NULL
                                        , @device3 varchar(1024) = NULL
                                        , @device4 varchar(1024) = NULL
                                        , @device5 varchar(1024) = NULL
                                        , @device6 varchar(1024) = NULL
                                        , @device7 varchar(1024) = NULL
                                        , @device8 varchar(1024) = NULL
                                        , @device9 varchar(1024) = NULL
                                        , @device10 varchar(1024) = NULL
                                        , @device11 varchar(1024) = NULL
                                        , @device12 varchar(1024) = NULL
                                        , @device13 varchar(1024) = NULL
                                        , @device14 varchar(1024) = NULL
                                        , @device15 varchar(1024) = NULL
                                        , @device16 varchar(1024) = NULL
                                        , @device17 varchar(1024) = NULL
                                        , @device18 varchar(1024) = NULL
                                        , @device19 varchar(1024) = NULL
                                        , @device20 varchar(1024) = NULL
                                        , @device21 varchar(1024) = NULL
                                        , @device22 varchar(1024) = NULL
                                        , @device23 varchar(1024) = NULL
                                        , @device24 varchar(1024) = NULL
                                        , @device25 varchar(1024) = NULL
                                        , @device26 varchar(1024) = NULL
                                        , @device27 varchar(1024) = NULL
                                        , @device28 varchar(1024) = NULL
                                        , @device29 varchar(1024) = NULL
                                        , @device30 varchar(1024) = NULL
                                        , @device31 varchar(1024) = NULL
                                        , @device32 varchar(1024) = NULL
                                        , @device33 varchar(1024) = NULL
                                        , @device34 varchar(1024) = NULL
                                        , @device35 varchar(1024) = NULL
                                        , @device36 varchar(1024) = NULL
                                        , @device37 varchar(1024) = NULL
                                        , @device38 varchar(1024) = NULL
                                        , @device39 varchar(1024) = NULL
                                        , @device40 varchar(1024) = NULL
                                        , @device41 varchar(1024) = NULL
                                        , @device42 varchar(1024) = NULL
                                        , @device43 varchar(1024) = NULL
                                        , @device44 varchar(1024) = NULL
                                        , @device45 varchar(1024) = NULL
                                        , @device46 varchar(1024) = NULL
                                        , @device47 varchar(1024) = NULL
                                        , @device48 varchar(1024) = NULL
                                        , @device49 varchar(1024) = NULL
                                        , @device50 varchar(1024) = NULL
                                        , @device51 varchar(1024) = NULL
                                        , @device52 varchar(1024) = NULL
                                        , @device53 varchar(1024) = NULL
                                        , @device54 varchar(1024) = NULL
                                        , @device55 varchar(1024) = NULL
                                        , @device56 varchar(1024) = NULL
                                        , @device57 varchar(1024) = NULL
                                        , @device58 varchar(1024) = NULL
                                        , @device59 varchar(1024) = NULL
                                        , @device60 varchar(1024) = NULL
                                        , @device61 varchar(1024) = NULL
                                        , @device62 varchar(1024) = NULL
                                        , @device63 varchar(1024) = NULL
                                        , @device64 varchar(1024) = NULL
                                        , @offset int = 1
                                        )
AS

/****************************************************************************************
// @File: usp_CVRestore.SQL
//
// @Version 6.0.0.19
//
// Purpose:
//   Perform Restore of Database from CommVault
//
// Notes: This stored procedure is meant to be called manually
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 06/25/2012 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 06/25/2012 @Author: Steve Trogub @Version: UBSMWE 5.0 @Action: Perform CommVault restores
//   @Date: 09/25/2012 @Author: Steve Trogub @Version: UBSMWE 5.0 @Action: Added named instance support
//   @Date: 01/14/2013 @Author: Steve Trogub @Version: UBSMWE 5.2 @Action: added @offset parameter with default value of 1 seconds per CommVault recommendation
//   @Date: 13/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.2 @Action: TRRv3 Beta 
//   @Date: 18/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.3 @Action: TRRv3 Beta 
//   @Date: 03/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.7 @Action: TRRv3 Beta 
//   @Date: 15/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta 
//   @Date: 04/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 Beta 
//   @Date: 14/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.11 @Action: TRRv3 Beta - TRR-78 feature request
//   @Date: 11/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.15 @Action: TRRv3 TRR-104
//   @Date: 15/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.16 @Action: Device parser - bug fix
//   @Date: 18/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.19 @Action: @objectTime check

****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET QUOTED_IDENTIFIER ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE
	@count int 
	,@counter int
	,@CV_BPBackup_ExecutableLocation varchar(255)
	,@CVFQDNCommCell varchar (255)
	,@dbsInstanceFileLocation varchar(255)
	,@DefaultWaitDelay char(8)
	,@device XML
	,@jobID nvarchar(30)
	,@MAPFile varchar(255)
	,@message nvarchar(255)
	,@OperationStartTime datetime
	,@RC int
	,@response nvarchar(max)
	,@rstring nvarchar(128)
	,@restoreCmd nvarchar(max)
	,@sql nvarchar(max)
	,@sql2005devices nvarchar(max)
	,@stroverwrite nvarchar(12)
	,@strpit nvarchar(6)
	,@strlogs nvarchar(7)
	,@tempInt float
	,@DeviceCount tinyint
	,@CVClient nvarchar(128) 
	,@CVInstance nvarchar(128)

--------------------------------------
-- Init vars
                         
--set defaults
SET @DefaultWaitDelay = '00:00:05'
SET @count  = 0
SET @stroverwrite = ''                                                 
                                                        
DECLARE @devices TABLE ([Name] varchar(10), [Value] varchar(1024))

----Identify which devices are being used
INSERT INTO @devices VALUES ('@device1', LTRIM(RTRIM(@device1 )))
INSERT INTO @devices VALUES ('@device2', LTRIM(RTRIM(@device2 )))
INSERT INTO @devices VALUES ('@device3', LTRIM(RTRIM(@device3 )))
INSERT INTO @devices VALUES ('@device4', LTRIM(RTRIM(@device4 )))
INSERT INTO @devices VALUES ('@device5', LTRIM(RTRIM(@device5 )))
INSERT INTO @devices VALUES ('@device6', LTRIM(RTRIM(@device6 )))
INSERT INTO @devices VALUES ('@device7', LTRIM(RTRIM(@device7 )))
INSERT INTO @devices VALUES ('@device8', LTRIM(RTRIM(@device8 )))
INSERT INTO @devices VALUES ('@device9', LTRIM(RTRIM(@device9 )))
INSERT INTO @devices VALUES ('@device10',LTRIM(RTRIM(@device10)))
INSERT INTO @devices VALUES ('@device11',LTRIM(RTRIM(@device11)))
INSERT INTO @devices VALUES ('@device12',LTRIM(RTRIM(@device12)))
INSERT INTO @devices VALUES ('@device13',LTRIM(RTRIM(@device13)))
INSERT INTO @devices VALUES ('@device14',LTRIM(RTRIM(@device14)))
INSERT INTO @devices VALUES ('@device15',LTRIM(RTRIM(@device15)))
INSERT INTO @devices VALUES ('@device16',LTRIM(RTRIM(@device16)))
INSERT INTO @devices VALUES ('@device17',LTRIM(RTRIM(@device17)))
INSERT INTO @devices VALUES ('@device18',LTRIM(RTRIM(@device18)))
INSERT INTO @devices VALUES ('@device19',LTRIM(RTRIM(@device19)))
INSERT INTO @devices VALUES ('@device20',LTRIM(RTRIM(@device20)))
INSERT INTO @devices VALUES ('@device21',LTRIM(RTRIM(@device21)))
INSERT INTO @devices VALUES ('@device22',LTRIM(RTRIM(@device22)))
INSERT INTO @devices VALUES ('@device23',LTRIM(RTRIM(@device23)))
INSERT INTO @devices VALUES ('@device24',LTRIM(RTRIM(@device24)))
INSERT INTO @devices VALUES ('@device25',LTRIM(RTRIM(@device25)))
INSERT INTO @devices VALUES ('@device26',LTRIM(RTRIM(@device26)))
INSERT INTO @devices VALUES ('@device27',LTRIM(RTRIM(@device27)))
INSERT INTO @devices VALUES ('@device28',LTRIM(RTRIM(@device28)))
INSERT INTO @devices VALUES ('@device29',LTRIM(RTRIM(@device29)))
INSERT INTO @devices VALUES ('@device30',LTRIM(RTRIM(@device30)))
INSERT INTO @devices VALUES ('@device31',LTRIM(RTRIM(@device31)))
INSERT INTO @devices VALUES ('@device32',LTRIM(RTRIM(@device32)))
INSERT INTO @devices VALUES ('@device33',LTRIM(RTRIM(@device33)))
INSERT INTO @devices VALUES ('@device34',LTRIM(RTRIM(@device34)))
INSERT INTO @devices VALUES ('@device35',LTRIM(RTRIM(@device35)))
INSERT INTO @devices VALUES ('@device36',LTRIM(RTRIM(@device36)))
INSERT INTO @devices VALUES ('@device37',LTRIM(RTRIM(@device37)))
INSERT INTO @devices VALUES ('@device38',LTRIM(RTRIM(@device38)))
INSERT INTO @devices VALUES ('@device39',LTRIM(RTRIM(@device39)))
INSERT INTO @devices VALUES ('@device40',LTRIM(RTRIM(@device40)))
INSERT INTO @devices VALUES ('@device41',LTRIM(RTRIM(@device41)))
INSERT INTO @devices VALUES ('@device42',LTRIM(RTRIM(@device42)))
INSERT INTO @devices VALUES ('@device43',LTRIM(RTRIM(@device43)))
INSERT INTO @devices VALUES ('@device44',LTRIM(RTRIM(@device44)))
INSERT INTO @devices VALUES ('@device45',LTRIM(RTRIM(@device45)))
INSERT INTO @devices VALUES ('@device46',LTRIM(RTRIM(@device46)))
INSERT INTO @devices VALUES ('@device47',LTRIM(RTRIM(@device47)))
INSERT INTO @devices VALUES ('@device48',LTRIM(RTRIM(@device48)))
INSERT INTO @devices VALUES ('@device49',LTRIM(RTRIM(@device49)))
INSERT INTO @devices VALUES ('@device50',LTRIM(RTRIM(@device50)))
INSERT INTO @devices VALUES ('@device51',LTRIM(RTRIM(@device51)))
INSERT INTO @devices VALUES ('@device52',LTRIM(RTRIM(@device52)))
INSERT INTO @devices VALUES ('@device53',LTRIM(RTRIM(@device53)))
INSERT INTO @devices VALUES ('@device54',LTRIM(RTRIM(@device54)))
INSERT INTO @devices VALUES ('@device55',LTRIM(RTRIM(@device55)))
INSERT INTO @devices VALUES ('@device56',LTRIM(RTRIM(@device56)))
INSERT INTO @devices VALUES ('@device57',LTRIM(RTRIM(@device57)))
INSERT INTO @devices VALUES ('@device58',LTRIM(RTRIM(@device58)))
INSERT INTO @devices VALUES ('@device59',LTRIM(RTRIM(@device59)))
INSERT INTO @devices VALUES ('@device60',LTRIM(RTRIM(@device60)))
INSERT INTO @devices VALUES ('@device61',LTRIM(RTRIM(@device61)))
INSERT INTO @devices VALUES ('@device62',LTRIM(RTRIM(@device62)))
INSERT INTO @devices VALUES ('@device63',LTRIM(RTRIM(@device63)))
INSERT INTO @devices VALUES ('@device64',LTRIM(RTRIM(@device64)))

 --load configuration values
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

SET @objectTime = LTRIM(RTRIM(@objectTime))

SET @iClient = LOWER(LTRIM(RTRIM(@iClient)))
SET @oClient = LOWER(LTRIM(RTRIM(@oClient)))

SET @iInstance = UPPER(LTRIM(RTRIM(@iInstance)))
SET @oInstance = UPPER(LTRIM(RTRIM(@oInstance)))
SET @recovery = UPPER(LTRIM(RTRIM(@recovery)))

PRINT '-------------------------------------------------'
PRINT 'UTCTime:   ' + CAST(GETUTCDATE() as varchar(40))
PRINT 'Localtime: ' + CAST(GETDATE() as varchar(40))
PRINT 'UTCoffset: ' + CAST(CAST(DATEDIFF(Hour, GETUTCDATE(),GETDATE()) as smallint) as varchar(3))
PRINT '-------------------------------------------------'

IF @pit = 1
BEGIN
	SET @objectTime = DBServices.dbo.ufn_BRATTime(@objectTime)

	IF @objectTime = 'DTError'
	BEGIN
		PRINT 'Please specify a valid time value for @objectTime for point in time recovery'
		PRINT 'e.g. ' + DBServices.dbo.ufn_BRATTime(getdate())
		RETURN 1 
	END
END

--set recovery mode for the restore if user failed to enter a valid state
IF @recovery IN ('STATE_STANDBY', 'STATE_RECOVER', 'STATE_NORECOVER')
	PRINT 'RECOVERY:' + @recovery
ELSE
BEGIN
    SET @message = 'UBSMWE: usp_CVRestore: @recovery option incorrectly specified - options: STATE_RECOVER, STATE_NORECOVER, STATE_STANDBY'
    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1
	GOTO handle_error                    
END

IF @recovery = 'STATE_STANDBY'
	AND ISNULL(@recoverylocation,'') = ''
BEGIN 
    SET @message = 'UBSMWE: usp_CVRestore: STATE_STANDBY was specified with no @recoverylocation entered. Please specify location for the undo file (e.g. D:\MSSQL\)'
    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1
	GOTO handle_error                    
END

-------------------------------------------------------------------------------------
-- If destination = local instance - verifiy 

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 

IF @oClient = @CVClient
	AND @oInstance = @CVInstance
BEGIN
	SET @RC = 0
	PRINT 'Restore request to the local instance; verify destination...' 
	-- Request to restore on same instance - verify

	IF @overwrite <> 1
		AND EXISTS (SELECT 1
		FROM sys.databases sd WITH (NOLOCK)
		WHERE sd.[name] = @DBName)
	BEGIN
		SET @message = 'UBSMWE: usp_CVRestore: Destination DB: ' + @DBName 
			+ ' already exists; to overwrite please specify @overwrite = 1 - unable to restore'
	    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1

		SET @RC = 1
	END

	-- Verify open connections
	IF EXISTS (	SELECT 1
		FROM sys.sysprocesses sp WITH (NOLOCK)
		INNER JOIN sys.databases sd WITH (NOLOCK)
			ON sp.dbid = sd.database_id
		WHERE sd.[name] = @DBName)
	BEGIN
		SET @message = 'UBSMWE: usp_CVRestore: Destination DB: ' + @DBName 
			+ ' has open connections - unable to restore'
	    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1

		SELECT spid
			,blocked
			,login_time
			,last_batch
			,open_tran
			,[status]
			,[hostname]
			,[program_name]
			,nt_domain
			,nt_username
			,loginame   
		FROM sys.sysprocesses sp WITH (NOLOCK)
		INNER JOIN sys.databases sd WITH (NOLOCK)
			ON sp.dbid = sd.database_id
		WHERE sd.[name] = @DBName

		SET @RC = 1
	END
	
	IF @RC = 1
		RETURN 1 -- Failure
END
ELSE
IF @overwrite = 1
	PRINT CHAR(13) + '=> Please ensure the external destination DB has no open connections otherwise the restore with overwrite will fail!'
 
-------------------------------------------------------------------------------------
--//TO be removed once XML can be passed to qoperation directly
--//without using files. This is expected in Simpana 10.0

IF  NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

SET @rstring=''

EXEC [DBServices].[dbo].[usp_Gen_rnd_filename] N'_CVRest', @rstring OUTPUT

SET @MAPFile = @dbsInstanceFileLocation + @rstring 
PRINT '@MAPFile File: ' + @MAPFile

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT

SET @OperationStartTime = getdate()

--check if cv_cmdshell exists
IF NOT EXISTS (SELECT 1 FROM [DBServices].[sys].[objects] WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @message = 'UBSMWE: usp_CVRestore: [DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1 '
    EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1
	GOTO handle_error
END

-------------------------------------------------------------------------------------
HandleDevices:
--Handle devices

SELECT @DeviceCount = COUNT(*) 
FROM @devices 
WHERE [Value] IS NOT NULL

IF @DeviceCount IS NULL 
	SET @DeviceCount = 0

IF @DBName <> @SourceDB AND @DeviceCount = 0
BEGIN
	SET @message = 'UBSMWE: usp_CVRestore: Please specify device names - a restore with the current syntax is not possible'
	EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1
	GOTO handle_error
END

-----------------------------------
-- Parse input strings into BRAT format

SET @sql2005devices = ''
IF @DeviceCount > 0
BEGIN
	        
	DECLARE deviceCursor CURSOR FAST_FORWARD
	FOR SELECT [Value]
	FROM @devices
	WHERE [Value] IS NOT NULL
	OPEN deviceCursor

	FETCH NEXT FROM deviceCursor INTO @sql
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Parse @devices into BRAT format: device_name,new_location,orig_location

		SET @sql = REPLACE(@sql COLLATE Latin1_General_CS_AS, 'MOVE ', '')
		SET @sql = REPLACE(@sql COLLATE Latin1_General_CS_AS, ' TO ', ',')
		SET @sql = REPLACE(@sql COLLATE Latin1_General_CS_AS, ' FROM ', ',')
		SET @sql = LTRIM(RTRIM(@sql))

		WHILE (CHARINDEX (', ', @sql) > 0)
				OR (CHARINDEX (' ,', @sql) > 0)
		BEGIN -- Strip spaces around comma's  
			SET @sql = REPLACE(@sql, ', ', ',') 
			SET @sql = REPLACE(@sql, ' ,', ',')
		END
		--SET @sql = '"' + REPLACE(@sql, ',', '","') + '"' -- TBD whether to automatically set quotes as risk of doubles if BRAT / user does the same

		SET @device = @SourceDB + ',' + @DBName + ',' + @sql
		SET @sql2005devices = @sql2005devices + CONVERT(nvarchar(max),@device)+ CHAR(13) + CHAR(10)

		FETCH NEXT FROM deviceCursor INTO @sql
	END

	CLOSE deviceCursor
	DEALLOCATE deviceCursor

	--write @MAPFile file to disk for passing parameters to BRAT.
	EXEC @RC = [dbo].[usp_Createtxtfile] 
				@FileName = @MAPFile
				,@Contents = @sql2005devices
    IF @RC <> 0
    BEGIN
		SET @message = 'UBSMWE: usp_CVRestore: Unable to create map file ' + @MAPFile + ' restore failed'
		EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1
		GOTO handle_error
    END
	ELSE
		PRINT 'Restore map file ' + @MAPFile + ' generated successfully'
END

/*
----------This is backup method for SYSTEMS WITH ole AUTOMATION DISABLED
EXECUTE ('CREATE TABLE [DBServices].[dbo].[' + @rstring + '] (col1 XML)')
CREATE TABLE #TEMP (col1 XML)
INSERT INTO #TEMP VALUES (@RestoreXML)
EXECUTE  ('INSERT INTO [DBServices].[dbo].[' + @rstring + '] (col1) SELECT col1 FROM #TEMP')
  DECLARE @SQLCmd   VARCHAR(500)
  -- in this command, we are making sure there is only one ROOT node
  SELECT  @SQLCmd = 'bcp ' +  '"SELECT col1 FROM [DBServices].[dbo].[' + @rstring + '] "' +  ' queryout '  +  @XMLConfigFile + '.xml -w -r \r -T -S' + @@SERVERNAME
  -- display command, for visual check
  SELECT @SQLCmd AS 'Command to execute'
  -- create the XML file
  EXECUTE @RC =  master..xp_cmdshell @SQLCmd
EXECUTE ('DROP TABLE [DBServices].[dbo].[' + @rstring + ']')

DECLARE @CRLF varchar(4)
SET @CRLF = char(13) + char(10)

*/

-------------------------------------------------------------------------------------
-- Action Restore

--STANDBY
IF CHARINDEX(N'STATE_STANDBY',@recovery) <> 0 
BEGIN
	IF  NOT RIGHT(@recoverylocation, 1) = '\'
		SET @recoverylocation = @recoverylocation + '\'

	PRINT '[' + @recoverylocation + ']'
END

--Point in Time restore
IF CHARINDEX(N'STATE_NORECOVER',@recovery) <> 0 
	PRINT 'PointInTime [' + @objectTime + ']'

-----------------------------------
Initiate_restore:

IF @overwrite = 1 
	SET @stroverwrite = ' -overwrite '

IF @pit = 1 
	SET @strpit = ' -pit '
ELSE
	SET @strpit = ''

IF @logs = 1 
	SET @strlogs = ' -logs '
ELSE
	SET @strlogs = ''

SET @restoreCmd = N'.\Brat\bin\cvrestore.exe -type mssql  -instanceName ' + @iInstance  
	+ ' -clientName ' + @iClient

IF @oClient <> @iClient 
	OR @oInstance <> @iInstance 
	SET @restoreCmd = @restoreCmd + ' -alternateHost ' + @oClient
		+ ' -destInstance '+ @oInstance 

SET @restoreCmd = @restoreCmd + ' -cs ' + @CVFQDNCommCell + ' -database ' + @SourceDB
	+ @stroverwrite + @strpit + @strlogs + ' -toTimeValue "' + @objectTime  +'"'

--Out of Place Restore
IF @DeviceCount > 0 
	SET @restoreCmd = @restoreCmd + ' -alternateLayout ' +  @MAPFile

--STANDBY
IF CHARINDEX(N'STATE_STANDBY',@recovery) <> 0
	AND @recoverylocation IS NOT NULL 
	SET @restoreCmd = @restoreCmd + ' -standby -undoFile ' +  @recoverylocation

IF CHARINDEX(N'STATE_NORECOVER',@recovery) <> 0 
	SET @restoreCmd = @restoreCmd + ' -offline'

PRINT @restoreCmd

EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
        @input = @restoreCmd,
        @response = @response OUTPUT

PRINT '-------------------------------------------------------------------------------------' + CHAR(13)
PRINT @response

IF (SELECT CHARINDEX('Another restore in progress',@response)) <> 0
BEGIN
	SET @message = 'UBSMWE: usp_CVRestore: Another restore is in progress. Please wait until this operation completes before starting new operations for this database.' + @response
	EXEC [DBServices].[dbo].[usp_LogEvent] @message, 1
    GOTO handle_error
END

-------------------------------------------------------------------------------------
-- BRAT Response handler
 
IF (SELECT CHARINDEX('FAIL',UPPER(@response))) <> 0 
	OR (SELECT CHARINDEX('CVFATAL',UPPER(@response))) <> 0
BEGIN
	SET @message = 'UBSMWE: usp_CVRestore: Error - Restore Failed! ' + @response + ' [' + CONVERT(nvarchar,@RC) + ']'
	EXEC [DBServices].[dbo].[usp_LogEvent] @message, 3

	PRINT 'For additional details see the log file located in C:\TEMP\cvrestore.exe' 
					+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

    GOTO handle_error
END

--remove any extra characters from JobID string
IF (SELECT CHARINDEX('-val',UPPER(@response))) <> 0 
BEGIN     
	SET @response = SUBSTRING(@response, CHARINDEX('-val', @response),CHARINDEX('},', @response)- CHARINDEX('-val', @response))
	SET @jobID = REPLACE(REPLACE(RTRIM(LTRIM(@response)), '''',''),' ','')
	SET @jobID = REPLACE(@jobID,'-val=>','')
END
ELSE
BEGIN
	SET @jobID = SUBSTRING(@response, CHARINDEX('Restore job', @response),CHARINDEX('completed successfully', @response)- CHARINDEX('Restore job', @response))
	SET @jobID = REPLACE(REPLACE(@jobID, 'Restore job',''), ' ','')
END

SET @jobID = REPLACE(@jobID, CHAR(117),'')
SET @jobID = REPLACE(@jobID, CHAR(10),'')
SET @jobID = REPLACE(@jobID, CHAR(13),'')
                
SET @response = 'Backup Job Queued: [' + @jobID + ']'

RAISERROR ( @response, 0, 1 ) WITH NOWAIT

-----------------------------------        
-- Output result

IF @DeviceCount > 0
	-- Tidy up temp file
	EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @MAPFile

SET @tempInt = DATEDIFF(second, @OperationStartTime, getdate())
SET @message = '=> Protected media restore successfully processed in ' 
				+ CAST(@tempInt as nvarchar(40) ) + ' seconds.'

PRINT ''
PRINT @message

SET QUOTED_IDENTIFIER OFF
RETURN 0 

------------------------------------------
handle_error:

SET QUOTED_IDENTIFIER OFF
RETURN 1

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVSchedule_List]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVSchedule_List] (
	@CVClient nvarchar(128) = NULL -- lower case
	,@CVInstance nvarchar(128) =NULL -- UPPER case
	,@subclientName nvarchar(128)= NULL	-- Case sensitive
	,@backupsetName nvarchar(128) = NULL
	,@CommCell nvarchar(128) = NULL --if another CommCell must be referenced.
	,@CVBakType char(1) = 'S' -- 'S' for SQL iDA, 'F' for FileSystem iDA CV backup types 
	,@StateOnly bit = 0 -- 1 if to update CV Schedule state only
	,@Quiet bit = 0) -- if 1 then update system tables only - no visible output
AS

/****************************************************************************************
// @File: usp_CVSchedule_List.SQL
//
// Purpose: List CommVault Subclients and associated Schedules (TRRv3)
//
// Notes: This stored procedure is called by other stored procedures 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 04/08/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 20/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta
//   @Date: 21/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta
//   @Date: 03/09/2014 @Author: Chris Basson @Version: 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 02/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 06/01/2015 @Author: Chris Basson @Version: 6.0.0.20 @Action: TRR-111
//   @Date: 04/05/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: TRR-136
//   @Date: 03/06/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: Simpana 10 client support
//   @Date: 09/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Handle BRAT output duplicates
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
****************************************************************************************/

BEGIN  --Begin main()

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE
	@RC int
	,@ControlCmd nvarchar(max)
	,@CVFQDNCommCell nvarchar(100)
	,@dbsInstanceFileLocation varchar(128)
	,@CV_BRATPath varchar(128)
	,@dbsSubclientName nvarchar(128)
	,@response nvarchar(max)
	,@rstring nvarchar(128)
	,@SQL nvarchar(max)
	,@tempFile nvarchar(255)
	,@tmpSchedulePolicy nvarchar(64)
	,@tmpinstanceName varchar(128)
	,@tmpstr varchar(max)
	,@tmpsubclientName nvarchar(128)
	,@tmpRType nvarchar(50)
	,@CVOut_delimiter char(1)
	,@CVFile_delimiter char(1)
	,@ErrorMsg nvarchar(255)
	,@dbsBackupProcessor tinyint
	,@CV_Enabled bit
	,@i tinyint

SET @CVFile_delimiter = ' ' 
SET @CVOut_delimiter = ',' --CHAR(9); TAB - ideally

SET @backupsetName = LTRIM(RTRIM(@backupsetName))
SET @subclientName = LTRIM(RTRIM(@subclientName))
SET @CommCell = LTRIM(RTRIM(@CommCell))

-----------------------------------------------------------------------------------
-- Get client info

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
IF @Quiet = 0
BEGIN
	PRINT 'Client: ' + @CVClient
	PRINT 'InstanceName: ' + @CVInstance

	IF ISNULL(@backupsetName, '') <> ''
		PRINT 'BackupSet: ' + @backupsetName

	IF ISNULL(@subclientName, '') <> ''
		PRINT 'SubclientName: ' + @subclientName
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT

-------------------
-- Verify inputs

IF @dbsBackupProcessor <> 5
	AND UPPER(CONVERT(sysname, SERVERPROPERTY('ServerName'))) = UPPER(@CVInstance)  
BEGIN
	PRINT '[usp_CVSchedule_List] is only applicable for CV Scheduled hosts i.e @dbsBackupProcessor = 5'
	RETURN 1 
END

IF @CVBakType = 'F' 
	AND ISNULL(@backupsetName,'') = ''
BEGIN
	IF OBJECT_ID('[DBServices].[dbo].[dbsCVFSSubclients]') IS NULL
		EXEC [DBServices].[dbo].[usp_CVFSBackupSet] @rstring, @rstring, @Init = 1	-- initialise FS backupset
	
	SELECT TOP 1 @backupsetName = dbsFSBackupSet
	FROM DBServices.dbo.dbsDatabase db
	INNER JOIN DBServices.dbo.dbsCVFSSubclients dbfs
		ON db.dbsDatabaseUID = dbfs.dbsDatabaseUID
	WHERE db.dbsDatabaseIsActive = 1
	
	IF ISNULL(@backupsetName,'') <> ''
		PRINT '@backupsetName was not specified - defaulting to ' + @backupsetName
	ELSE
		PRINT '@backupsetName was not specified and unable to identifiy a default backupset - please verify the hosts configuration'
		-- note condition below will fail and display usage to user
END

IF (@CVBakType = 'S' AND ISNULL(@CVInstance,'') = '')
	OR (@CVBakType = 'F' AND ISNULL(@backupsetName,'') = '')
BEGIN
	PRINT '--usage:'
	PRINT 'EXEC [DBServices].[dbo].[usp_CVSchedule_List] '
	PRINT '			@CVClient = '+'''' + @CVClient + '''' +'			--client name /list client wide content.'
	PRINT '			,@CVInstance ='+'''' + @CVInstance +''''	+ '		--instance name (@CVBakType = S only)'
	PRINT '			--,@subclientName ='+'''' + DBServices.dbo.ufn_CV_SubclientforDB(DB_NAME()) + ''''	+ '			--subclient name /list specific subclient contents.'
	PRINT '			--,@backupsetName ='+''''+'<backupset>'+'''' + '		--backupset name (@CVBakType = F only)'
	PRINT '			--,@CommCell = '+''''+'<commcell>'+'''' + ' 		--if another CommCell must be referenced.'
	PRINT '			--,@CVBakType nchar(1) = ''S'' -- ''S'' for SQL iDA, ''F'' for FileSystem iDA CV backup types'
	PRINT '			--,@StateOnly -- if =1 only returns and updates whether the schedule enabled state'
	
	RETURN 1
END

-------------------
-- Verify BRAT version
EXEC @RC = [DBServices].[dbo].[usp_CVBRATchk] @dbsBackupProcessor = @dbsBackupProcessor, @Quiet = 1

IF @RC <> 0 
BEGIN	
	SET @ErrorMsg = 'UBSMWE: usp_CVSchedule_List: Error - Incorrect BRAT version identified for operation'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	GOTO END_IT
END

-------------------
--load configuration values

IF ISNULL(@CommCell,'') = ''
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT
ELSE
	SET @CVFQDNCommCell = @CommCell

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATPath', @CV_BRATPath OUTPUT

IF NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

SET @rstring = ''
EXEC DBServices.dbo.usp_Gen_rnd_filename N'_CVSched', @rstring OUTPUT

SET @tempFile = @dbsInstanceFileLocation + @rstring 
IF @Quiet = 0
	PRINT 'Temp File: ' + @tempFile

--check if cv_cmdshell exists
IF NOT EXISTS (SELECT 1 FROM [DBServices].[sys].[objects] WITH (NOLOCK) WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
    SET @ErrorMsg = 'UBSMWE: usp_CVSchedule_List: [DBServices].[dbo].[cv_cmdshell] was not found. To register use: usp_RegisterCVcmdshell 1'
    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END

-----------------------------------------------------------------------------------
Jobstatus:
--query status of job in progress

-- cvcfglist.pl -type mssql -subclient -clientName [name] -instanceName [instance] -schedule

IF @CVBakType = 'S'
BEGIN -- SQL iDA
	SET @backupsetName = @CVInstance
	SET @ControlCmd = N'.\Brat\bin\cvcfglist -type mssql -clientName ' + @CVClient

	IF ISNULL(@CVInstance, '') <> '' 
		SET @ControlCmd = @ControlCmd + ' -instanceName ' + @CVInstance
END ---------------------------
ELSE
BEGIN -- FS iDA
	SET @ControlCmd = N'.\Brat\bin\cvcfglist -type filesystem -clientName ' + @CVClient 

	IF ISNULL(@backupsetName, '') <> ''
		SET @ControlCmd = @ControlCmd + ' -backupSetName ' + @backupsetName
END

IF ISNULL(@subclientName, '') <> '' 
	SET @ControlCmd = @ControlCmd + ' -subclientName ' + @subclientName 

IF @StateOnly = 0 
	 SET @ControlCmd = @ControlCmd + ' -subclient -schedule -state' -- Update CV Schedule and state
ELSE 
	 SET @ControlCmd = @ControlCmd + ' -subclient -state' -- Update CV Schedule state only

SET @ControlCmd = @ControlCmd + ' -cs ' + @CVFQDNCommCell + ' > ' + @tempFile

IF @Quiet = 0
BEGIN
	PRINT 'cd "' + @CV_BRATPath + '"'
	PRINT @ControlCmd
END

---------------
-- Do

SET @RC = -1
SET @i = 1

WHILE @RC <> 0 AND @i <= 2
BEGIN
	EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
					@ControlCmd,
					@response = @response OUTPUT

	IF @RC <> 0 AND @i < 2
	BEGIN
		-- retry
		WAITFOR DELAY '00:01'
		SET @i = @i + 1
	END
END

IF @RC <> 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVSchedule_List: Unhandled exception - Investigation required'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	GOTO END_IT
END
ELSE
IF @Quiet = 0
	PRINT 'List Job completed successfully'

-----------------------------------------------------------------------------------
-- Parse BRAT Output

WAITFOR DELAY '00:00:05'

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

CREATE TABLE #tmp (
		line varchar(max))

SET @SQL = 'BULK INSERT #tmp
    FROM ''' + @tempFile + '''
    WITH (FirstRow = 1, FieldTerminator = ' 
		+ '''' + @CVFile_delimiter + '''' 
		+ ', RowTerminator = ' 
		+ '''' + '\n' + '''' + ')'
EXEC(@SQL)

IF OBJECT_ID('tempdb..#CV_OBJECTS') IS NOT NULL 
	DROP TABLE #CV_OBJECTS

CREATE TABLE #CV_OBJECTS (
		instanceName nvarchar(128)
		,subclientName nvarchar(128)
		,RType nvarchar(128)
		,SchedulePolicy nvarchar(64))

DECLARE procver_cur CURSOR FORWARD_ONLY FOR
SELECT line 
FROM #tmp
OPEN procver_cur

FETCH NEXT FROM procver_cur INTO @tmpstr
WHILE (@@fetch_status <> -1)
BEGIN

	SET @tmpstr= 
		REPLACE(
			REPLACE(
				REPLACE(
					REPLACE(
						REPLACE(
							REPLACE(@tmpstr,'  ',@CVOut_delimiter)
						,' ',@CVOut_delimiter)
					,',','<>')
				,'><','')
			,'<>',@CVOut_delimiter)
		, ', ',@CVOut_delimiter)

	---collect BACKUP MEDIA INFO
    IF  LEN(@tmpstr) > 0
    BEGIN
        SELECT @tmpinstanceName=Value FROM DBServices.dbo.fn_Split(@CVOut_delimiter, @tmpstr) WHERE RowID = 1
        SELECT @tmpsubclientName=Value FROM DBServices.dbo.fn_Split(@CVOut_delimiter, @tmpstr)  WHERE RowID = 2
        SELECT @tmpRType=Value FROM DBServices.dbo.fn_Split(@CVOut_delimiter, @tmpstr)  WHERE RowID = 3 -- RowID 3 either = 'schedulePolicy' or 'enableState'
        SELECT @tmpSchedulePolicy=Value FROM DBServices.dbo.fn_Split(@CVOut_delimiter, @tmpstr) WHERE RowID = 4

		IF @tmpSchedulePolicy = 'schedulePolicy'
			SET  @tmpSchedulePolicy = 'NONE'
			
		INSERT INTO #CV_OBJECTS VALUES (                 
			 LTRIM(RTRIM(@tmpinstanceName))
			,LTRIM(RTRIM(@tmpsubclientName))
			,LOWER(LTRIM(RTRIM(@tmpRType)))
			,LTRIM(RTRIM(@tmpSchedulePolicy))
			)
	END
    FETCH NEXT FROM procver_cur INTO @tmpstr
END

CLOSE procver_cur
DEALLOCATE procver_cur

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

-----------------------------------------------------------------------------------
--DISPLAY RESULTS

IF @Quiet = 0
BEGIN
	PRINT CHAR(13)
	PRINT '-----------------------------------------------------------------------------------'
	PRINT CHAR(13)

	SELECT DISTINCT * 
	FROM #CV_OBJECTS

	PRINT CHAR(13)
	PRINT '-----------------------------------------------------------------------------------'
END

--------------------------------------------------------------------------------------------
--Update local table with current schedule data
--make sure the instance passed matches local instance, if not we cannot update local tables

IF @CVBakType = 'S'
BEGIN

	IF UPPER(CONVERT(sysname, SERVERPROPERTY('ServerName'))) = UPPER(@CVInstance) 
	BEGIN

		IF NOT EXISTS (SELECT TOP 1 1 FROM DBServices.sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[dbsCVSchedule]'))
		BEGIN
			CREATE TABLE [DBServices].[dbo].[dbsCVSchedule](
				[CVSubclient] nvarchar(128) NOT NULL
				,[CVSchedulePolicy] nvarchar(64) NOT NULL
				,[LastUpdate] datetime NOT NULL
				,[Enabled] bit) ON [PRIMARY]

			/*	CVSchedulePolicy:

				SPEC UPDATE: 02.09.2014:

				Format:
					[COMMSERVE]_SCHP_[STATUS]_[APP]_[FREQ]_[FULLDAY]-[HH:MM]-[HH:MM]-[HH:MM]

				The Schedule Name standard will be adjusted to IBUSALL_SCHP_PRD_SQL-WLOGS_YYY_MON-22:00-16:00-16:00 where 
				the first time is for MON-FRI, the second time is SAT and the third SUN.
				Where a backup will be skipped, a xx:xx will be used e.g. IBUSALL_SCHP_PRD_SQL-WLOGS_YYY_MON-22:00-16:00-xx:xx

				Where APP is FILE, SQL, SYB or ORA
						 FREQ is YYY XYY XXY for daily, weekly and monthly
						 HH:MM is the earliest start time; xx:xx to skip a backup
							Position:
								1) Day Week schedule
								2) Saturday only schedule
								3) Sunday only schedule
			*/
		END
		ELSE
		BEGIN
			EXEC @RC = [DBServices].[dbo].usp_chktbllock 'DBServices', 'dbsCVSchedule'
			IF @RC <> 0
			BEGIN
				SET @ErrorMsg =  N'UBSMWE: usp_CVSchedule_List: Failed to update CVSchedule data in DBServices..dbsCVSchedule'
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

				GOTO END_IT
			END
		END
		
		---------------------------
		---Update subclient data DO
		
		DECLARE update_cur CURSOR FORWARD_ONLY FOR
		SELECT DISTINCT 
				subclientName
				,SchedulePolicy
				,RType
		FROM #CV_OBJECTS

		OPEN update_cur

		FETCH NEXT FROM update_cur 
			INTO @tmpsubclientName, @tmpSchedulePolicy, @tmpRType
		WHILE (@@fetch_status <> -1)
		BEGIN
			IF EXISTS (SELECT TOP 1 1 
				FROM [DBServices].[dbo].[dbsCVSchedule]
				WHERE [CVSubclient] = @tmpsubclientName )
			BEGIN
				-- existing record
				SET LOCK_TIMEOUT 3000

				IF @StateOnly = 0 
					AND @tmpRType = 'schedulepolicy'
				BEGIN
					UPDATE [DBServices].[dbo].[dbsCVSchedule]
					SET	[CVSubclient] = @tmpsubclientName
						,[CVSchedulePolicy] = @tmpSchedulePolicy
						,[LastUpdate] =getdate()
					WHERE [CVSubclient] = @tmpsubclientName
				END
				ELSE
				IF @tmpRType = 'enablestate'
				BEGIN 
					UPDATE [DBServices].[dbo].[dbsCVSchedule]
					SET	[CVSubclient] = @tmpsubclientName
						,[Enabled] = CASE LOWER(@tmpSchedulePolicy)
										WHEN 'true' THEN 1
										ELSE 0
									 END
						,[LastUpdate] =getdate()
					WHERE [CVSubclient] = @tmpsubclientName
				END
			END ---------------------------
			ELSE
			BEGIN -- new record
				SET LOCK_TIMEOUT 1000
				
				IF @StateOnly = 0 
					AND @tmpRType = 'schedulepolicy'
				BEGIN
					INSERT INTO  [DBServices].[dbo].[dbsCVSchedule]
					VALUES (@tmpsubclientName
						,@tmpSchedulePolicy
						,getdate()
						,1) -- Enabled flag - assume new CV Schedule policy is enabled
				END
				ELSE
				IF @tmpRType = 'enablestate'
				BEGIN
					INSERT INTO  [DBServices].[dbo].[dbsCVSchedule]
					VALUES (@tmpsubclientName
						,'NOT_DETERMINED'
						,getdate()
						,0) 
				END
			END 

			FETCH NEXT FROM update_cur
				INTO  @tmpsubclientName, @tmpSchedulePolicy, @tmpRType
		END
		CLOSE update_cur
		DEALLOCATE update_cur

		---------------------------
		-- Tidy up only valid SQL iDA Subclients

		DELETE FROM [DBServices].[dbo].[dbsCVSchedule]
		WHERE CVSubclient NOT IN ( 
			-- SQL iDA
			SELECT DISTINCT dbsSubclientName
			FROM DBServices.dbo.dbsDatabase db
			INNER JOIN DBServices.dbo.dbsCVSubclients dbs
				ON db.dbsDatabaseUID = dbs.dbsDatabaseUID
			WHERE db.dbsDatabaseIsActive = 1)
	END
	ELSE
		PRINT 'Info: ' + CONVERT(sysname, SERVERPROPERTY('ServerName')) + ' <> ' + @CVInstance + ' - Skipping local table update'
END

-----------------------------------------------------------------------------------
END_OK:

--Tidyup 
IF object_id('tempdb..#CV_OBJECTS') IS NOT NULL
	DROP TABLE #CV_OBJECTS
IF object_id('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

-- Tidy up temp file
EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @tempFile

RETURN (0)

-----------------------------------------------------------------------------------
END_IT:

-- clean up after the error
PRINT 'For additional details see the latest log file located in C:\TEMP\cvcfglist.exe' 
	+ REPLACE ('-' + CONVERT(nvarchar(8), getdate(), 10),'-0','-')

IF object_id('tempdb..#CV_OBJECTS') IS NOT NULL
	DROP TABLE #CV_OBJECTS
IF object_id('tempdb..#tmp') IS NOT NULL
	DROP TABLE #tmp

-- Note left output file for investigation

RETURN (1)

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_CVSchedulePolicyDecode]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVSchedulePolicyDecode] (
	@CVSchedulePolicy varchar(64)
	, @TodaysScheduleOut smalldatetime OUTPUT)
AS
/****************************************************************************************
// @File: usp_CVSchedulePolicyDecode.sql
// 
// @Version 6.0.0.13
//
// Purpose:
// TRRv3 only: Decodes a given CV Scheduled policy and returns the time the next FULL SQL iDA
// backup time or a return code of -1 if not applicable
//
// Notes: Called by System
//
//
// History: Dates are in dd/mm/yyyy format
//
//    @Date:10/11/2014 @Author: Chris Basson @Version: 6.0.0.10 TRRv3 Beta 
//    @Date:01/12/2014 @Author: Chris Basson @Version: 6.0.0.13 TRRv3 Beta 
****************************************************************************************/

BEGIN -- main

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@RC int
	, @Alert bit
	, @WeekDayStartTime char(5)
	, @SatStartTime  char(5) 
	, @SunStartTime  char(5) 
	, @FullDay char(3) 
	, @Freq char(3) 
	, @TodaysSchedule char(5) 
	, @ISO_DTStr char(23)

-------------------------------------------
SET @Alert = 0
SET @TodaysScheduleOut = NULL

-- Decode CVSchedulePolicy

/*	CVSchedulePolicy:

	SPEC UPDATE: 02.09.2014:

	Format:
		[COMMSERVE]_SCHP_[STATUS]_[APP]_[FREQ]_[FULLDAY]-[HH:MM]-[HH:MM]-[HH:MM]

	The Schedule Name standard will be adjusted to IBUSALL_SCHP_PRD_SQL-WLOGS_YYY_MON-22:00-16:00-16:00 where 
	the first time is for MON-FRI, the second time is SAT and the third SUN.
	Where a backup will be skipped, a xx:xx will be used e.g. IBUSALL_SCHP_PRD_SQL-WLOGS_YYY_MON-22:00-16:00-xx:xx

	Where APP is FILE, SQL, SYB or ORA
			 FREQ is YYY XYY XXY for daily, weekly and monthly
			 HH:MM is the earliest start time; xx:xx to skip a backup
				Position:
					1) Day Week schedule
					2) Saturday only schedule
					3) Sunday only schedule
*/
SET @CVSchedulePolicy = LTRIM(RTRIM(@CVSchedulePolicy))

SET @WeekDayStartTime = SUBSTRING(@CVSchedulePolicy, LEN(@CVSchedulePolicy) - 16, 5)-- Time 'HH:MM' -- len ('22:00-16:00-xx:xx') - 1
SET @SatStartTime = SUBSTRING(@CVSchedulePolicy, LEN(@CVSchedulePolicy) - 10, 5)	-- Time 'HH:MM' -- len ('16:00-xx:xx') - 1
SET @SunStartTime = SUBSTRING(@CVSchedulePolicy, LEN(@CVSchedulePolicy) - 4, 5)		-- Time 'HH:MM' -- len ('xx:xx') - 1

SET @FullDay = UPPER(SUBSTRING(@CVSchedulePolicy, LEN(@CVSchedulePolicy) - 20, 3))	-- Full backup day -- len('MON-22:00-16:00-xx:xx') - 1
SET @Freq = UPPER(SUBSTRING(@CVSchedulePolicy, LEN(@CVSchedulePolicy) - 24, 3))		-- FREQ is YYY XYY XXY : daily, weekly and monthly -- len('YYY_MON-22:00-16:00-xx:xx') - 1

PRINT 'CVScheduled backup FULL day: ' + @FullDay 
	+ ', Frequency: ' + @Freq 
	+ ', Weekday start time: ' + @WeekDayStartTime
	+ ', Sat start time: ' + @SatStartTime
	+ ', Sun start time: ' + @SunStartTime

-------------------------------------------
-- Validate 

-- Check @CVSchedulePolicy
SET @Alert = CASE 
				WHEN (ISDATE(@WeekDayStartTime) = 0) AND (LOWER(@WeekDayStartTime) <> 'xx:xx') THEN 1 
				WHEN (ISDATE(@SatStartTime) = 0) AND (LOWER(@SatStartTime) <> 'xx:xx') THEN 1 
				WHEN (ISDATE(@SunStartTime) = 0) AND (LOWER(@SunStartTime) <> 'xx:xx') THEN 1 
				WHEN UPPER(@FullDay) NOT IN ('MON','TUE','WED','THU','FRI','SAT','SUN') THEN 1
				WHEN UPPER(@Freq) NOT IN ('YYY','XYY','XXY') THEN 1
				ELSE 0
			 END

IF @Alert = 1
BEGIN
	PRINT 'UBSMWE: usp_CVSchedulePolicyDecode: ERROR: Unable to decode policy ' + @CVSchedulePolicy
	RETURN 1
END  --------------
ELSE
BEGIN -- @CVSchedulePolicy Checks Successfull - Verifying schedule status 

	IF (DATEPART (dw,getdate()) BETWEEN 2 AND 6 AND LOWER(@WeekDayStartTime) = 'xx:xx') -- Today is a weekday
		OR (DATEPART (dw,getdate()) = 7 AND LOWER(@SatStartTime) = 'xx:xx') -- Today is Saturday
		OR (DATEPART (dw,getdate()) = 1 AND LOWER(@SunStartTime) = 'xx:xx') -- Today is Sunday
	BEGIN
		SET @TodaysScheduleOut = NULL
		RETURN -1 -- Not applicable
	END
	ELSE --------------
		SET @TodaysSchedule = CASE
			WHEN (DATEPART (dw,getdate()) BETWEEN 2 AND 6) THEN @WeekDayStartTime -- Today is a weekday
			WHEN (DATEPART (dw,getdate()) = 7) THEN @SatStartTime -- Today is Saturday
			WHEN (DATEPART (dw,getdate()) = 1) THEN @SunStartTime -- Today is Sunday
			ELSE 'ERROR'
		END 
END --------------

SET @ISO_DTStr = CONVERT (char(10), getdate(),126 ) + 'T' + @TodaysSchedule + ':00.000'

IF ISDATE (@ISO_DTStr) = 1
BEGIN
	SET @TodaysScheduleOut = CONVERT (smalldatetime,@ISO_DTStr,126)
	RETURN 0 
END --------------
ELSE
BEGIN
	PRINT 'UBSMWE: usp_CVSchedulePolicyDecode: Parsing error for schedule ' + @CVSchedulePolicy
	RETURN 1 -- Failure
END

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVSchedulePolicyLastToday]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVSchedulePolicyLastToday] (@LastScheduleTime char(5) OUTPUT)
AS
/****************************************************************************************
// @File: usp_CVSchedulePolicyLastToday.sql
// 
// @Version 6.0.0.10
// Purpose: Returns the last CV Schedule time for the day
//
// Notes: System stored procedure, applicable for TRRv3 (dbsBackupProcessor=5) only
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 11/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 beta
//
****************************************************************************************/

BEGIN --Main

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@RC int
	,@CVSchedulePolicy nvarchar(64)
	,@TodaysScheduleOut smalldatetime
	,@TodaysScheduleOutTStr char(5)
	,@MaxScheduleOutStr char(5)

SET @MaxScheduleOutStr = '00:00'

-----------------------
-- Determine last CV Schedule time for the day

DECLARE SP_cur CURSOR READ_ONLY FOR
SELECT DISTINCT CVSchedulePolicy 
FROM DBServices.dbo.dbsCVSchedule

OPEN SP_cur

FETCH NEXT FROM SP_cur 
	INTO @CVSchedulePolicy

WHILE (@@FETCH_STATUS = 0)
BEGIN 

	EXEC @RC = [DBServices].[dbo].[usp_CVSchedulePolicyDecode] 
		@CVSchedulePolicy = @CVSchedulePolicy
		,@TodaysScheduleOut = @TodaysScheduleOut OUTPUT

	IF @RC <> 0
		BREAK
 
	SET @TodaysScheduleOutTStr = CONVERT (char(5), @TodaysScheduleOut, 8) -- format hh:mm

	IF @TodaysScheduleOutTStr > @MaxScheduleOutStr
		SET @MaxScheduleOutStr = @TodaysScheduleOutTStr

	FETCH NEXT FROM SP_cur 
		INTO @CVSchedulePolicy
END
CLOSE SP_cur
DEALLOCATE SP_cur

IF ISDATE(@MaxScheduleOutStr) = 1
BEGIN
	PRINT 'UBSMWE: usp_CVSchedulePolicyLastToday: @LastScheduleTime = ' + @MaxScheduleOutStr
	SET @LastScheduleTime = @MaxScheduleOutStr
	RETURN 0
END
ELSE
BEGIN
	PRINT 'UBSMWE: usp_CVSchedulePolicyLastToday: ERROR: Unable to detemine @LastScheduleTime'
	SET @LastScheduleTime = NULL
	RETURN 1
END

END  -- Main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVScheduleTlogDeStage]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVScheduleTlogDeStage]
AS

BEGIN -- main

/****************************************************************************************
// @File: usp_CVScheduleTlogDeStage.SQL
// 
// @Version 6.0.0.12
// Purpose: TRRv3 ONLY (dbsBackupProcessor=5)
//	Force initiate an Ad-Hoc 'de-staging' of CV SQL iDA transaction log DB backups...
//	In a wonderful 'CV hack' - BRAT CVBackup command does not actually initiate a tlog backup for CV Scheduled dumps.
//	Instead this process will force the SQL iDA to purge any CV scheduled transaction log dumps which are known 
//	to have been archived and initiate a file system iDA backup of any remaining dump files with high priority.
//
// Notes: Compatible with SQL 2005 and above
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 20/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.12 @Action: TRRv3 beta
****************************************************************************************/

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int 
	, @FinalRC int
	, @SubClient nvarchar(255)
	, @dbsBackupProcessor tinyint
	
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
SET @FinalRC = 0

IF @dbsBackupProcessor <> 5
BEGIN
	PRINT 'usp_CVScheduleTlogDeStage is only applicable for CV Scheduled backups (i.e. dbsBackupProcessor=5)'
	PRINT 'This instance is configured with dbsBackupProcessor = ' + CAST(@dbsBackupProcessor as char(1)) + ' thus unable to proceed'
	RETURN 1
END

DECLARE sbcur CURSOR LOCAL FAST_FORWARD FOR
SELECT DISTINCT dbsSubDB.dbsSubclientName
FROM [DBServices].[dbo].[dbsDatabase] dbsD
INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
	ON dbsSubDB.dbsDatabaseUID = dbsD.dbsDatabaseUID
INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbb
	ON dbb.dbsDatabaseUID = dbsD.dbsDatabaseUID
WHERE dbsD.dbsDatabaseIsActive = 1
	AND dbsD.dbsDatabaseIsSystemObjectFlag = 0 -- User DBs only
	AND dbb.dbsDBExternalBackupFlag = 1
	AND dbb.dbsDBBackupType IN ('FULL','BULK_LOGGED') -- excludes logshipped
	AND UPPER(dbsSubDB.dbsSubclientName) NOT LIKE '%_SQL_SIMPLE' 
ORDER BY dbsSubDB.dbsSubclientName ASC -- GROUP before TRANSACTIONAL as likely to be priority

OPEN sbcur 

FETCH NEXT FROM sbcur INTO @SubClient
WHILE @@FETCH_STATUS=0 
BEGIN
	PRINT 'UBSMWE: usp_CVScheduleTlogDeStage: Forcing an CV AdHoc TLog de-stage for Subclient ' + @SubClient

	EXEC @RC = [DBServices].[dbo].[usp_CVBackup] @CVSubClient = @SubClient, @BackupType = 3 

	IF @RC <> 0
		SET @FinalRC = 1
		
	FETCH NEXT FROM sbcur INTO @SubClient
END

CLOSE sbcur
DEALLOCATE sbcur 

RETURN @FinalRC

END -- end of main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVSubclientScheduleControl]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVSubclientScheduleControl] (
	@DBName  as nvarchar(128) = ''
	, @CVSubclient as nvarchar(128) = NULL	-- Case sensitive
	, @operation as nvarchar(20) = 'LIST'	-- 'LIST','CVSCHED_DISABLE','CVSCHED_ENABLE'
	, @PollTime as tinyint = 1				-- Between 1 and 59 minutes
	, @Retrymax as tinyint = 1				-- Number of retry attempts if request fails
	, @CVScheduleStaleHrs as tinyint = 12	-- Local schedule table - number of hours the data is deemed stale
	)
AS

/****************************************************************************************
// @File: usp_CVSubclientScheduleControl.sql
// 
// @Version 6.0.0.27
//
// Purpose:
//  Allows a CV Scheduled backup to be placed in a queued state at Subclient level
//	inorder to accommodate pre/post application processes.
//	
// Notes: Called by User 
//
//Dependancies:
//	usp_CVSchedule_List, usp_CVWaitforBak, ufn_CV_SubclientforDB, usp_LogEvent
//
// History: Dates are in dd/mm/yyyy format
//
//    @Date: 04/08/2014 @Author: Chris Basson @Version: 6.0.0 TRRv3 Beta
//    @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 TRRv3 Beta
//    @Date: 21/08/2014 @Author: Chris Basson @Version: 6.0.0.4 TRRv3 Beta
//    @Date: 05/09/2014 @Author: Chris Basson @Version: 6.0.0.6 TRRv3 Beta - spec change
//    @Date: 28/10/2014 @Author: Chris Basson @Version: 6.0.0.8 TRRv3 Beta - spec change
//    @Date: 25/02/2015 @Author: Chris Basson @Version: 6.0.0.25 Bugfix: TRR-124
//    @Date: 10/03/2015 @Author: Chris Basson @Version: 6.0.0.27 Bugfix: TRR-127
//
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@CVSchedulePolicy nvarchar(64)
	,@LastUpdate datetime
	,@CVClient nvarchar(128) 
	,@CVInstance nvarchar(128)
	,@RC int
	,@ErrorMsg nvarchar(255)
	,@Alert bit
	,@RetryCnt tinyint
	,@PollTimeDO char(5)
	,@dbsBackupProcessor tinyint 
	,@CVSchedulePolicyEnabled bit

-------------------------------------------	
-- Init

SET @Alert = 0
SET @operation = UPPER(LTRIM(RTRIM(@operation)))
-- SET @DBName  = LTRIM(RTRIM(@DBName)) -- Bugfix do not trim DBName
SET @CVSubclient = LTRIM(@CVSubclient)
SET @ErrorMsg = 'UBSMWE: usp_CVSubclientScheduleControl: '

SET @DBName = ISNULL(@DBName, '')

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT

-- Ensure cmd log table exists
IF  NOT EXISTS (SELECT 1 FROM [DBServices].sys.objects 
					WHERE object_id = OBJECT_ID(N'[dbo].[dbsCVScheduleCmdLog]') AND [type] IN (N'U'))
	CREATE TABLE [DBServices].[dbo].[dbsCVScheduleCmdLog](
		[CmdDateTime] [datetime] NOT NULL,
		[CVSchedulePolicy] [nvarchar](64) NOT NULL,
		[CmdIssued] [nvarchar](20) NOT NULL,
		[CmdSuccess] [bit] NOT NULL
	) ON [PRIMARY]

IF @dbsBackupProcessor <> 5
BEGIN
	SET @ErrorMsg = @ErrorMsg + 'UBSMWE is not configured for CommVault Scheduled backups, unable to proceed' 
	PRINT @ErrorMsg
	GOTO END_IT
END

-------------------------------------------
-- Verify BRAT version

EXEC @RC = [DBServices].[dbo].[usp_CVBRATchk] @dbsBackupProcessor = @dbsBackupProcessor, @Quiet=1

IF @RC <> 0 
BEGIN	
	SET @ErrorMsg = @ErrorMsg + ' ERROR - Incorrect BRAT version identified for the operation'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	GOTO END_IT
END
-------------------------------------------

IF NOT EXISTS (SELECT 1 
		FROM DBServices.sys.sysobjects
		WHERE [name] = 'dbsCVSchedule')
BEGIN
	PRINT 'Running usp_CVSchedule_List for the 1st time => go and have a nice cup of tea...'
	EXEC @RC=DBServices.dbo.usp_CVList_local
	EXEC @RC=DBServices.dbo.usp_CVSchedule_List @CVInstance = @CVInstance, @Quiet = 1

	IF @RC <> 0
	BEGIN
		SET @ErrorMsg = @ErrorMsg + 'ERROR - problem in executing dependancy usp_CVSchedule_List,'
				+ 'there may be an issue with the CommCell or host registration - Unable to proceed' 

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END
END

IF @DBName <> ''
BEGIN
	IF NOT EXISTS (SELECT 1 FROM [DBServices].[dbo].[dbsDatabase] 
					WHERE dbsDatabaseName = @DBName AND dbsDatabaseIsActive = 1)
	BEGIN 
		SET @ErrorMsg = @ErrorMsg + 'ERROR - Unable to identify an active DB with the name: ['
			+ @DBName  + '] - please verify your input parameters'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END
	
	SET @CVSubclient = [DBServices].[dbo].[ufn_CV_SubclientforDB] (@DBName) -- database name takes precendence over subclient
	IF ISNULL(@CVSubclient, '') = '' 
	BEGIN
		SET @ErrorMsg = @ErrorMsg + 'ERROR - Unable to identify a Subclient for ['
			+ @DBName  + '] - may need to run [usp_CVList_local] to refresh local tables'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END		
END
ELSE
IF ISNULL(@CVSubclient, '') = ''
BEGIN
	SET @ErrorMsg = @ErrorMsg + 'ERROR - A valid @CVSubclient or @DBName  parameter is required (case sensitive)'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END	
ELSE
IF NOT EXISTS (SELECT 1 
		FROM DBServices.dbo.dbsCVSubclients
		WHERE dbsSubclientName = @CVSubclient)
BEGIN
	SET @ErrorMsg = @ErrorMsg + 'ERROR - A valid @CVSubclient or @DBName  parameter is required (case sensitive)'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END

IF @PollTime BETWEEN 1 AND 59
	SET @PollTimeDO = '00:' + REPLACE(STR(CAST (@PollTime as char(2)), 2, 0), ' ', '0')
ELSE 
BEGIN
	SET @ErrorMsg = @ErrorMsg + 'ERROR - correct @PollTime parameter required; between 1 and 59 minutes'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END
	
IF @operation NOT IN ('LIST','CVSCHED_DISABLE','CVSCHED_ENABLE')
BEGIN 
	SET @ErrorMsg = @ErrorMsg + 'ERROR - correct @operation parameter required; LIST,CVSCHED_DISABLE/CVSCHED_ENABLE'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
	GOTO END_IT
END


-------------------------------------------
-- Determine CV Schedule for Subclient

IF NOT EXISTS(SELECT 1
		FROM DBServices.dbo.dbsDatabase db
		INNER JOIN DBServices.dbo.dbsCVSubclients dbs
			ON dbs.dbsDatabaseUID = db.dbsDatabaseUID
		WHERE db.dbsDatabaseIsActive = 1
			AND dbs.dbsSubclientName = @CVSubclient
			AND db.dbsDatabaseUID NOT IN (
				SELECT DISTINCT dbsDatabaseUID
				FROM DBServices.dbo.dbsDatabaseException dbe
				WHERE dbe.dbsDatabaseExceptionType = 'backup'
					AND dbe.dbsDatabaseExceptionSubType = 'no_full'
					AND dbe.dbsExceptionActive = 1)
		)
BEGIN
	PRINT @ErrorMsg
		+ 'Subclient ' + @CVSubclient 
		+ ' - identified as either empty, DBs offline or no_full exclusion(s) exist'

	GOTO END_OK
END ---------------------
ELSE
SELECT TOP 1
	 @CVSchedulePolicy = CVSchedulePolicy
	,@LastUpdate = LastUpdate
	,@CVSchedulePolicyEnabled = [Enabled]
FROM [DBServices].[dbo].dbsCVSchedule
WHERE CVSubclient = @CVSubclient


IF (@LastUpdate <= DATEADD(hh, -@CVScheduleStaleHrs, GETDATE ()))
	OR (@LastUpdate IS NULL)
BEGIN 	-- Update the local schedule table if the data is older than CVScheduleStaleHrs hrs or Subclient not present

	EXEC @RC = [DBServices].[dbo].[usp_CVSchedule_List]	
			@CVClient = @CVClient		--client name /list client wide content.
			,@CVInstance = @CVInstance	--instance name /list instance wide contents.
			,@StateOnly = 1
			,@Quiet = 1

	IF @RC = 0 -- OK
	BEGIN
		SELECT DISTINCT
			@CVSchedulePolicy = CVSchedulePolicy
			,@LastUpdate = LastUpdate
			,@CVSchedulePolicyEnabled = [Enabled]
		FROM [DBServices].[dbo].dbsCVSchedule
		WHERE CVSubclient = @CVSubclient

		IF @LastUpdate IS NULL
			SET @Alert = 1
	END --------------
	ELSE -- Failed
		SET @Alert = 1
END

-------------------------------------------
-- Action @operation

IF @operation = 'LIST' 
BEGIN
	IF (@LastUpdate IS NOT NULL)
		AND @Alert = 0
	BEGIN
		PRINT '[' + @DBName  + ']: The schedule policy for Subclient ' + @CVSubclient 
				+ ' is ' + @CVSchedulePolicy 
				+ ', status: ' + CASE @CVSchedulePolicyEnabled
									WHEN 0 THEN '*** DISABLED ***'
									WHEN 1 THEN 'Enabled'
								 END
		GOTO END_OK
	END --------------
	ELSE
	BEGIN
		SET @ErrorMsg = @ErrorMsg + 'ERROR - CVSchedule List failed, local data may be incorrect for Subclient ' + @CVSubclient

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT
	END
END -------------------------------------------
ELSE 
IF @operation = 'CVSCHED_DISABLE'
BEGIN

	IF @CVSchedulePolicyEnabled = 0
		AND @Alert = 0
	BEGIN
		PRINT CHAR(13) + 'CommVault Scheduled backups for Subclient: ' + @CVSubclient 
			+ ' are already disabled'

		GOTO END_OK
	END

	-------------------------------------------
	-- Decode CVSchedulePolicy

	DECLARE @TodaysScheduleOut smalldatetime

	EXEC @RC = [DBServices].[dbo].usp_CVSchedulePolicyDecode 
			@CVSchedulePolicy = @CVSchedulePolicy
			, @TodaysScheduleOut = @TodaysScheduleOut OUTPUT
	
	IF @Alert = 1 
		OR @RC > 0
	BEGIN
		SET @ErrorMsg =  @ErrorMsg + 'WARNING: [' + @DBName 
			+ '] - Unable to verify CV Backup Schedule for ' + @CVSubclient 
			+ '; however will attempt to continue with action ' + @operation

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- Warning
	END --------------
	ELSE
	IF @RC = -1 
		AND @TodaysScheduleOut IS NULL
	BEGIN -- @CVSchedulePolicy Checks Successfull - Verifying schedule status (Note SUN = day 1 of week)
		SET @ErrorMsg =  @ErrorMsg + 'INFO: [' + @DBName 
				+ '] - CV Scheduled backup policy for Subclient ' + @CVSubclient 
				+ ' is configured to skip today (' + CONVERT (nvarchar(5),getdate(),8)
				+ '); will attempt to continue with action ' + @operation

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- Info
	END --------------
	ELSE 
	IF @RC = 0 
		AND getdate() BETWEEN @TodaysScheduleOut AND DATEADD(hour, 2, @TodaysScheduleOut)
	BEGIN
		SET @ErrorMsg =  @ErrorMsg + 'WARNING: [' + @DBName 
			+ '] - The CV Scheduled backup window for ' + @CVSubclient 
			+ ' may have already started (' + CONVERT (nvarchar(5),getdate(),8)
			+ '); however will attempt to continue with action ' + @operation

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- Warning
	END --------------
	-- ELSE OK schedule clear 

	-------------------------------------------
	-- Disable CV Schedule DO	

	SET @RC = 1
	SET @RetryCnt = 0
	WHILE (@RC <> 0) 
		AND (@RetryCnt < @Retrymax)
		AND @CVSchedulePolicyEnabled = 1
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_CVJobcontrol]
				@CVInstance = @CVInstance
				,@subclientName = @CVSubclient
				,@operation = 'CVSCHED_DISABLE'
				,@CVBakType = 'S'
				,@Quiet=1

		IF @RC = 0
		BEGIN
			PRINT CHAR(13) + 'CommVault Scheduled backups for Subclient: ' + @CVSubclient 
				+ ' successfully disabled'
			SET @CVSchedulePolicyEnabled = 0
			BREAK
		END --------------
		ELSE
			PRINT @operation + ' for ' + @CVSubclient 
				+ ' retrying: ' + CAST(@RetryCnt as nvarchar(3))

		WAITFOR DELAY '00:01' 
		SET @RetryCnt = @RetryCnt + 1
	END  --------------

	IF @CVSchedulePolicyEnabled = 0 
		-- Successfully disabled - Wait for Subclient backup to complete if applicable
		EXEC @RC = [DBServices].[dbo].[usp_CVWaitforBak] @CVSubclient, @PollTime, @Retrymax
	ELSE
		SET @RC = 1 -- failed to id disabled state

	GOTO END_STATUS
END -------------------------------------------

ELSE 
IF @operation = 'CVSCHED_ENABLE'
BEGIN

	IF @CVSchedulePolicyEnabled = 1
		AND @Alert = 0
	BEGIN
		PRINT CHAR(13) + 'CommVault Scheduled backups for Subclient: ' + @CVSubclient 
			+ ' are already enabled'

		GOTO END_OK
	END

	SET @RC = 1
	SET @RetryCnt = 0
	WHILE (@RC <> 0) 
		AND (@RetryCnt < @Retrymax)
		AND @CVSchedulePolicyEnabled = 0
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_CVJobcontrol]
				@CVInstance = @CVInstance
				,@subclientName = @CVSubclient
				,@operation = 'CVSCHED_ENABLE'
				,@CVBakType = 'S'
				,@Quiet=1

		IF @RC = 0
		BEGIN
			PRINT CHAR(13) + 'CommVault Scheduled backups for Subclient: ' + @CVSubclient 
					+ ' successfully enabled'

			SET @CVSchedulePolicyEnabled = 1

			EXEC [DBServices].[dbo].usp_CVSubclientScheduleControl 
					@DBName  = @DBName 
					, @CVSubclient = @CVSubclient
					, @operation = 'LIST'	
					, @PollTime = @PollTime	
					, @Retrymax = @Retrymax		
					, @CVScheduleStaleHrs = @CVScheduleStaleHrs  
			BREAK
		END --------------
		ELSE
			PRINT @operation + ' for ' + @CVSubclient 
				+ ' retrying: ' + CAST(@RetryCnt as nvarchar(3))

		WAITFOR DELAY '00:01' 
		SET @RetryCnt = @RetryCnt + 1
	END  --------------

	IF @CVSchedulePolicyEnabled = 0
		GOTO END_STATUS -- op failed
END 

-------------------------------------------
END_STATUS:

IF (@RC <> 0) 
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVSubclientScheduleControl: DB [' + @DBName 
		+ '] - unable to complete or validate ' + @operation 
		+ ' for Subclient ' + @CVSubclient 
		+ ' after ' + CAST(@RetryCnt as varchar(3)) + ' retry attempts'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2

	GOTO END_IT
END
ELSE 
	GOTO END_OK

-------------------------------------------
END_IT:

-- Log request failure
IF @CVSchedulePolicy IS NOT NULL
	INSERT INTO [DBServices].[dbo].[dbsCVScheduleCmdLog]
	VALUES (getdate(),@CVSchedulePolicy,@operation,0)

RETURN 1

-------------------------------------------
END_OK:

-- Log request success
IF @CVSchedulePolicy IS NOT NULL
	INSERT INTO [DBServices].[dbo].[dbsCVScheduleCmdLog]
	VALUES (getdate(),@CVSchedulePolicy,@operation,1)

RETURN 0

-------------------------------------------
END

GO
/****** Object:  StoredProcedure [dbo].[usp_CVSubclientScheduleControl_Local]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVSubclientScheduleControl_Local] (
		@operation as nvarchar(20) = 'LIST'	-- 'CVSCHED_DISABLE','CVSCHED_ENABLE', 'LIST'
		,@Retrymax as tinyint = 5	-- retry upto n times (default 5)		
		,@PollTime as tinyint = 1	-- default 1 min
		,@CVScheduleStaleHrs as tinyint = 1 -- Used with CVSCHED_DISABLE/ENABLE: Default 1hr; 0= Force a CVSchedule_List
		)
AS 

/****************************************************************************************
// @File: usp_CVSubclientScheduleControl_Local.sql
//
// Purpose:
//  Place all CV Scheduled backups to a queued state 
//	
// Notes: called by [usp_UBSMWE_WF_RunWorkflow] 
//
//Dependancies:
//	usp_CVSubclientScheduleControl
//
// History: Dates are in dd/mm/yyyy format
//
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.10 TRRv3 Beta
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//
****************************************************************************************/

BEGIN -- main
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@RC int
	,@CVSchedulePolicy nvarchar(64)
	,@LastUpdate datetime
	,@Enabled bit
	,@RCFinal int
	,@dbsBackupProcessor tinyint 
	,@CVSubclient as nvarchar(128)
	,@ErrorMsg as varchar(256)
	,@astr varchar(256)

--------------------------------
-- Init
SET @operation = UPPER(LTRIM(RTRIM(@operation)))
SET @RC = 0

IF @operation NOT IN ('LIST','CVSCHED_DISABLE','CVSCHED_ENABLE')
BEGIN 
	SET @ErrorMsg = 'UBSMWE: usp_CVSubclientScheduleControl_Local: '
		+ 'ERROR - correct @operation parameter required; LIST,CVSCHED_DISABLE/CVSCHED_ENABLE'

	PRINT @ErrorMsg
	RETURN 1
END

IF  @PollTime NOT BETWEEN 1 AND 59
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVSubclientScheduleControl_Local: '
		+ 'ERROR - correct @PollTime parameter required; between 1 and 59 minutes'

	PRINT @ErrorMsg
	RETURN 1
END
--------------------------------
-- DO

IF @operation = 'LIST'
BEGIN
	SET @astr = CONVERT(sysname, SERVERPROPERTY('ServerName'))
	EXEC @RCFinal = [DBServices].[dbo].[usp_CVSchedule_List] @CVInstance = @astr
	GOTO FINAL_STATUS
END
-- ELSE =>

--------------------------------
-- Schedule enable / disable

DECLARE subclicur CURSOR LOCAL FAST_FORWARD 
FOR SELECT DISTINCT
	 LTRIM(RTRIM(CVSubclient))
	 ,LTRIM(RTRIM(CVSchedulePolicy))
	 ,LastUpdate
	 ,[Enabled] 
FROM [DBServices].[dbo].dbsCVSchedule
OPEN subclicur

FETCH NEXT FROM subclicur
INTO @CVSubclient, @CVSchedulePolicy, @LastUpdate, @Enabled

WHILE @@FETCH_STATUS=0 
BEGIN

	PRINT '------------------------------------------------'

	EXEC @RC = [DBServices].[dbo].[usp_CVSubclientScheduleControl] 
			@CVSubclient = @CVSubclient
			, @operation = @operation
			, @Retrymax = @Retrymax
			, @PollTime = @PollTime
			, @CVScheduleStaleHrs = @CVScheduleStaleHrs
	
	IF @RC <> 0
		SET @RCFinal = @RC

	FETCH NEXT FROM subclicur
	INTO @CVSubclient, @CVSchedulePolicy, @LastUpdate, @Enabled
END
CLOSE subclicur
DEALLOCATE subclicur 

--------------------------------
FINAL_STATUS:

IF @RCFinal <> 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_CVSubclientScheduleControl_Local: An error occured when attempting to '
					+ CASE @operation
							WHEN 'CVSCHED_DISABLE' THEN 'disable CVScheduled backups for '
							WHEN 'CVSCHED_ENABLE' THEN 'enable CVScheduled backups for ' 
							WHEN 'LIST' THEN 'list CV backup schedules for '
						END
					+ CONVERT(sysname, SERVERPROPERTY('ServerName'))

	PRINT @ErrorMsg

	-- EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	 -- Warning only
	RETURN (1)
END	----------------
ELSE
	RETURN (0)

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVTLogBakStagingStatus]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVTLogBakStagingStatus] (
			@CV_SqlLogBackupStageFolder nvarchar(255) OUTPUT
			,@CV_bTLBackupToFS int OUTPUT
			,@CV_backupFromFSForLog int OUTPUT
			,@CV_SqlLogBackupInterval int OUTPUT)
AS
BEGIN --main

/****************************************************************************************
// @File: usp_CVTLogBakStagingStatus.SQL
//
// Notes: Compatible with SQL 2005 and above
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 21/07/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 beta
//   @Date: 09/09/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 beta
//   @Date: 23/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 beta
//   @Date: 11/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 beta
//	 @Date: 13/02/2015 @Author: Chris Basson @Version: 6.0.0.25 @Action: Backup monitor feature request
//	 @Date: 04/09/2015 @Author: Chris Basson @Version: 6.0.0.38 @Action: Minor bugfix: skip if not TRRv3
****************************************************************************************/

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int 
	, @CV_SqlLogBackupStageFolder_tmp nvarchar(255)
	, @CV_bTLBackupToFS_tmp int
	, @CV_backupFromFSForLog_tmp int
	, @nSQLLogBackupInterval_tmp int
	, @CV_Enabled bit
	, @CVClient nvarchar(128)
	, @CVInstance nvarchar(128) 
	, @i tinyint
	, @msg_body nvarchar(255)
	, @str nvarchar(500)
	, @permdef nvarchar(255)
	, @debug tinyint
	, @isclustered as bit
	, @dbsBackupProcessor as tinyint

SET @RC = 0
SET @isclustered = CAST(SERVERPROPERTY('IsClustered') as bit)

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT, @quiet = 1
IF @dbsBackupProcessor <> 5
	RETURN 0 -- exit as not applicable

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT, @quiet = 1
EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT, @quiet = 1

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 

SELECT @CV_bTLBackupToFS_tmp = 999
	, @CV_backupFromFSForLog_tmp = 999
	, @CV_SqlLogBackupStageFolder_tmp = NULL
	, @nSQLLogBackupInterval_tmp = NULL

-----------------------------
-- Get CV reg key values

--bTLBackupToFS

BEGIN TRY
	EXEC master.dbo.xp_regread
		   N'HKEY_LOCAL_MACHINE',
		   N'SOFTWARE\\CommVault Systems\\Galaxy\\Instance001\\Cvd',
		   N'bTLBackupToFS', 
		   @CV_bTLBackupToFS_tmp OUTPUT, 'no_output'
END TRY	
BEGIN CATCH
	PRINT 'bTLBackupToFS reg key missing'
	SET @CV_bTLBackupToFS_tmp = 999
END CATCH

------------------
--backupFromFSForLog

BEGIN TRY
	EXEC master.dbo.xp_regread
		   N'HKEY_LOCAL_MACHINE',
		   N'SOFTWARE\\CommVault Systems\\Galaxy\\Instance001\\MSSQLAgent',
		   N'backupFromFSForLog', 
		   @CV_backupFromFSForLog_tmp OUTPUT, 'no_output'
END TRY	
BEGIN CATCH
	PRINT 'backupFromFSForLog reg key missing'
	SET @CV_backupFromFSForLog_tmp = 999
END CATCH

------------------
--SqlLogBackupStageFolder

IF @isclustered = 1
BEGIN -- Cluster
	SET @str = 'EXEC master.dbo.xp_regread
		   N''HKEY_LOCAL_MACHINE'',
		   N''SOFTWARE\\CommVault Systems\\Galaxy\\Instance001\\MSSQLAgent'',
		   N''' + @CVClient + N'StageFolder'', 
		   @CV_SqlLogBackupStageFolder_OUT OUTPUT , ''no_output'''

	SET @permdef = N'@CV_SqlLogBackupStageFolder_OUT nvarchar(255) OUTPUT'

	BEGIN TRY
		EXEC sp_executesql @str, @permdef, @CV_SqlLogBackupStageFolder_OUT = @CV_SqlLogBackupStageFolder_tmp OUTPUT
	END TRY	
	BEGIN CATCH
		PRINT 'CV Cluster Instance Staging folder reg key missing'
		SET @CV_SqlLogBackupStageFolder_tmp = ''
	END CATCH
END ------------------
ELSE
BEGIN -- Standalone host
	BEGIN TRY
		EXEC master.dbo.xp_regread
			   N'HKEY_LOCAL_MACHINE',
			   N'SOFTWARE\\CommVault Systems\\Galaxy\\Instance001\\MSSQLAgent',
			   N'SqlLogBackupStageFolder', 
			   @CV_SqlLogBackupStageFolder_tmp OUTPUT, 'no_output'
	END TRY	
	BEGIN CATCH
		PRINT 'CV Standalone host Staging folder reg key missing'
		SET @CV_SqlLogBackupStageFolder_tmp = ''
	END CATCH
END

------------------
--nSQLLogBackupInterval

BEGIN TRY
	EXEC master.dbo.xp_regread
		   N'HKEY_LOCAL_MACHINE',
		   N'SOFTWARE\\CommVault Systems\\Galaxy\\Instance001\\Cvd',
		   N'nSQLLogBackupInterval', 
		   @nSQLLogBackupInterval_tmp OUTPUT, 'no_output'
END TRY	
BEGIN CATCH
	PRINT 'nSQLLogBackupInterval reg key missing'
	SET @nSQLLogBackupInterval_tmp = NULL
END CATCH

-----------------------------
-- Verify

IF (@CV_bTLBackupToFS_tmp <> 1)
BEGIN
	SET @msg_body = 'UBSMWE: usp_CVTLogBakStagingStatus: Commvault Scheduled backups - local TLog staging is not enabled! - Please contact Backup Services'
	EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 3
	SET @RC = 1
END

IF (@CV_backupFromFSForLog_tmp <> 1) AND (@CV_Enabled = 1)
BEGIN
	SET @msg_body = 'UBSMWE: usp_CVTLogBakStagingStatus: Commvault Scheduled backups - offsite backups of the local TLog staging folder is not enabled! - Please contact Backup Services'
	EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 3
	SET @RC = 1
END

SET @i = CHARINDEX (':\', @CV_SqlLogBackupStageFolder_tmp, 1)
IF @i=0
BEGIN 
	SET @msg_body = 'UBSMWE: usp_CVTLogBakStagingStatus: Commvault Scheduled backups - TLog Staging path not found! - Please contact Backup Services'
	EXEC [DBServices].[dbo].[usp_LogEvent] @msg_body, 3
	SET @RC = 1
END

IF @debug >= 2
BEGIN
	PRINT 'CV_bTLBackupToFS = ' + CAST(@CV_bTLBackupToFS_tmp as char(1))
	PRINT 'CV_backupFromFSForLog = ' + CAST(@CV_backupFromFSForLog_tmp as char(1))
	PRINT 'CV_SqlLogBackupStageFolder = ' + @CV_SqlLogBackupStageFolder_tmp
	PRINT 'CV_nSQLLogBackupInterval = ' + CAST(@nSQLLogBackupInterval_tmp as varchar(5))
END

SET @CV_bTLBackupToFS = @CV_bTLBackupToFS_tmp
SET @CV_backupFromFSForLog = @CV_backupFromFSForLog_tmp
SET @CV_SqlLogBackupStageFolder = @CV_SqlLogBackupStageFolder_tmp
SET @CV_SqlLogBackupInterval = @nSQLLogBackupInterval_tmp

RETURN (@RC)

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_CVWaitforBak]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_CVWaitforBak] (
	@CVSubclient as nvarchar(128) = NULL -- Case sensitive
	,@JobID int = NULL 
	,@PollTime as tinyint = 1
	,@Retrymax as tinyint = 3
	)

AS

/****************************************************************************************
// @File: usp_CVWaitforBak.sql 
// @Version 6.0.0.27
//
// Purpose:
//  Waits without returning focus for a given CV backup job to complete 
//	via either a CV Subclient or jobid 
//	Accommodates pre/post application processes.
//	
// Notes: Called by usp_CVSubclientScheduleControl 
//
// History: Dates are in dd/mm/yyyy format
//
//    @Date: 2/07/2014 @Author: Chris Basson @Version: 6.0.0 TRRv3 Beta
//    @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 TRRv3 Beta
//    @Date: 04/09/2014 @Author: Chris Basson @Version: 6.0.0.6 TRRv3 Beta
//    @Date: 10/03/2015 @Author: Chris Basson @Version: 6.0.0.27 TRR-127
****************************************************************************************/

BEGIN -- main
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @RC int
	,@Message nvarchar(255)
	,@RetryCnt tinyint
	,@PollTimeDO nchar(5)
	,@CVClient nvarchar(128)
	,@CVInstance nvarchar(128)
	,@tmpJobID varchar(20)

--------------------------
-- Init

IF @JobID IS NULL 
	AND NOT EXISTS (SELECT 1 
					FROM DBServices.dbo.dbsCVSubclients
					WHERE dbsSubclientName = @CVSubclient)
BEGIN
	SET @Message = 'UBSMWE Error: usp_CVWaitforBak: '
		+ 'A valid @CVSubclient or @DatabaseName parameter is required (case sensitive)'
	PRINT @Message
	GOTO END_IT
END

IF @PollTime BETWEEN 1 AND 59
	SET @PollTimeDO = '00:' + REPLACE(STR(CAST(@PollTime as char(2)), 2, 0), ' ', '0')
ELSE 
BEGIN
	SET @Message = 'UBSMWE Error: usp_CVWaitforBak: '
		+ 'correct @PollTime parameter required; between 1 and 59 minutes'
	PRINT @Message
	GOTO END_IT
END

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT

--------------------------
-- Determine wait

SET @RC = 1
SET @RetryCnt = 0

WHILE (@RC <> 0) 
		AND (@RetryCnt < @Retrymax)
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_CVJobcontrol]
			@CVInstance = @CVInstance
			,@subclientName = @CVSubclient
			,@operation = 'LIST'
			,@CVBakType = 'S'
			,@Quiet=1
	
	IF @RC = 0 -- result returned
	BEGIN

		SELECT TOP 1 @tmpJobID = jobid
		FROM DBServices.dbo.dbsCVJobStatus js
		WHERE (js.subclient = @CVSubclient 
					OR jobid = CAST(@JobID as varchar(20)) )
				AND (js.jobType = 'Backup'
					AND js.jobStatus IN ('Running') )

		IF ISNULL(@tmpJobID, '') = ''
			BREAK -- good to continue
		ELSE 
		BEGIN -- Wait for @PollTime mins

			SET @Message = 'UBSMWE Info: usp_CVWaitforBak: '
						+ 'Backup currently in progress for Subclient ' + @CVSubclient 
						+ ', JobID: ' + @tmpJobID 
						+ ' - Waiting ' + CAST(@PollTime as varchar(2)) 
						+ 'mins... (' + CAST(@RetryCnt as varchar(3)) 
						+ '/' + CAST(@Retrymax as varchar(3)) + ')'

			EXEC [DBServices].[dbo].[usp_LogEvent] @Message, 1 --info event

			SET @RC = 1 -- reset
			WAITFOR DELAY @PollTimeDO 
		END
	END

	SET @RetryCnt = @RetryCnt + 1
END

IF ISNULL(@tmpJobID, '') = ''
	RETURN 0
ELSE
BEGIN
	SET @Message = 'UBSMWE: usp_CVWaitforBak: Timed out for'
			+ 'Subclient ' + @CVSubclient 
			+ ', JobID: ' + @tmpJobID 
			+ ' - CV backup still running after ' + CAST(@PollTime * @RetryCnt as varchar(5)) 
			+ 'mins'

	EXEC [DBServices].[dbo].[usp_LogEvent] @Message, 2 -- Warning event
END
--------------------------

END_IT:
RETURN 1

END -- end main

GO
/****** Object:  StoredProcedure [dbo].[usp_DBBackupChk]    Script Date: 9/14/2016 5:15:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_DBBackupChk] 
AS
/********************************************
// @File: usp_DBBackupChk.sql
// 
// Purpose:
//   Workaround for CV not being able to raise its own alerts
//
// Notes: This sp is intended for system use
//
// History: Dates are in mm/dd/yyyy format
//
//	 @Date: 11/02/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.24 @Action: id CV feature request
//	 @Date: 25/02/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.25 @Action: Minor fix
//	 @Date: 28/05/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.30 @Action: bugfix - Bulk-logged recovery, AO AG
//   
********************************************/

BEGIN --main

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
	, @dbsBakFullConcernHrs varchar(5)
	, @dbsBakDiffConcernHrs varchar(5)
	, @dbsBakTlogConcernMins varchar(5)
	, @IncludeReadOnlyBackups char(1)
	, @Qstr varchar(4000)
	, @Qstr2 varchar(4000)
	, @Qstr3 varchar(4000)
	, @Qstr4 varchar(4000)
	, @Qstr5 varchar(4000)
	, @Qstr6 varchar(4000)
	, @Qstr7 varchar(4000)
	, @AOnode bit

IF OBJECT_ID('tempdb..#TblOutput') IS NOT NULL 
	DROP TABLE #TblOutput

CREATE TABLE #TblOutput (
	DBName varchar(128)
	,[Status] varchar(40)
	,TestOutput varchar(255))

---------------------------------
-- Andrews DB Backup check

EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'dbsBakFullConcernHrs', @dbsBakFullConcernHrs OUTPUT, @quiet=1
EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'dbsBakDiffConcernHrs', @dbsBakDiffConcernHrs OUTPUT, @quiet=1
EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'dbsBakTlogConcernMins', @dbsBakTlogConcernMins OUTPUT, @quiet=1
EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'IncludeReadOnlyBackups', @IncludeReadOnlyBackups OUTPUT, @quiet=1

IF @dbsBakFullConcernHrs IS NULL
	SET @dbsBakFullConcernHrs = '180'

IF @dbsBakDiffConcernHrs IS NULL
	SET @dbsBakDiffConcernHrs = '36'

IF @dbsBakTlogConcernMins IS NULL
	SET @dbsBakTlogConcernMins = '30'

IF @IncludeReadOnlyBackups IS NULL
	SET @IncludeReadOnlyBackups = '1'

IF [DBServices].[dbo].[ufn_InstanceMajorVersion] () >= 11
	SET @AOnode = CAST(SERVERPROPERTY ('IsHadrEnabled') as bit)
ELSE
	SET @AOnode = 0

SET @Qstr = '
DECLARE @TAB char(1)
SET @TAB = char(9)

INSERT INTO #TblOutput
SELECT 
	Finishes.name
	,CASE 
		WHEN EXISTS(SELECT 1
			FROM DBServices.dbo.dbsDatabase dbs
			INNER JOIN DBServices.dbo.dbsDatabaseException dbe
				ON dbe.dbsDatabaseUID = dbs.dbsDatabaseUID
			WHERE dbs.dbsDatabaseName = Finishes.name
				AND dbs.dbsDatabaseIsActive = 1
				AND dbe.dbsExceptionActive = 1
				AND LOWER(LTRIM(RTRIM(dbe.dbsDatabaseExceptionType))) = ''backup''
				AND LOWER(LTRIM(RTRIM(dbe.dbsDatabaseExceptionSubType))) = ''no_full'')
			THEN ''exclusion'' '
		+ CASE @AOnode
					WHEN 1 THEN ' WHEN (sys.fn_hadr_backup_is_preferred_replica(Finishes.name) = 0) THEN ''AO replica'' '
					ELSE ''
				END + '
		WHEN ( (Finishes.recovery_model_desc IN (''FULL'', ''BULK_LOGGED''))  
			AND ((DATEDIFF(minute, Finishes.[Last Tlog Backup END], getdate()) > ' + @dbsBakTlogConcernMins + ')
				OR (Finishes.[Last Tlog Backup END] IS NULL)) )
			THEN ''*CHECK Tlog*''

		WHEN ((DATEDIFF(hour, Finishes.[Last Diff Backup END], getdate()) > ' + @dbsBakDiffConcernHrs + ')
			AND (DATEDIFF(hour, Finishes.[Last Full Backup END], getdate()) > ' + @dbsBakDiffConcernHrs + ')
			AND EXISTS(SELECT 1
				FROM DBServices.dbo.dbsDatabase dbs
				INNER JOIN DBServices.dbo.dbsCVSubclients cvs
					ON cvs.dbsDatabaseUID = dbs.dbsDatabaseUID
				WHERE dbs.dbsDatabaseName = Finishes.name
					AND dbs.dbsDatabaseIsActive = 1
					AND cvs.dbsDatabaseIsOndemandFlag = 0) -- NOT SINGLE Subclient
			)
			THEN ''*CHECK Diff*''

		WHEN ((DATEDIFF(hour, Finishes.[Last Full Backup END], getdate()) > ' + @dbsBakFullConcernHrs + ')
				OR (Finishes.[Last Full Backup END] IS NULL))
				THEN ''*CHECK Full*''

		ELSE ''OK''
	END'

SET @Qstr2 = '
	, Finishes.recovery_model_desc 
	 + @TAB + ''LastFullBk:''
		+ CASE (SELECT TOP 1 1 
					FROM msdb.dbo.backupset bs WITH (NOLOCK)
					WHERE bs.type = ''D''
					AND bs.name = ''CommVault Galaxy Backup''
					AND bs.backup_start_date = Starts.[Last Full Backup START]
					AND bs.backup_finish_date = Finishes.[Last Full Backup END]
				)
				WHEN 1 THEN ''(CV)''
				ELSE ''''
			END	
		+ ISNULL(CAST(Finishes.[Last Full Backup END] as varchar(19))
				,''--'')
	 + @TAB + ''FullDur(Mins):'' 
		+ ISNULL(
				CAST(
					DATEDIFF(minute,Starts.[Last Full Backup START], Finishes.[Last Full Backup END])
					as varchar(6)) 
				,''--'')
	 + @TAB + ''DaysLastFull:''
		+ ISNULL(
				CAST(
					DATEDIFF(dd,Finishes.[Last Full Backup END],getdate()) as varchar(4))
				,''--'')'
SET @Qstr3 = '
		+ @TAB + CASE 
		WHEN EXISTS(SELECT 1
			FROM DBServices.dbo.dbsDatabase dbs
			INNER JOIN DBServices.dbo.dbsCVSubclients cvs
				ON cvs.dbsDatabaseUID = dbs.dbsDatabaseUID
			WHERE dbs.dbsDatabaseName = Finishes.name
				AND dbs.dbsDatabaseIsActive = 1
				AND cvs.dbsDatabaseIsOndemandFlag = 0) -- NOT SINGLE Subclient
		THEN ''LastDiffBk:''
			+ CASE (SELECT TOP 1 1 
						FROM msdb.dbo.backupset bs WITH (NOLOCK)
						WHERE bs.type = ''I''
						AND bs.name = ''CommVault Galaxy Backup''
						AND bs.backup_start_date = Starts.[Last Diff Backup START]
						AND bs.backup_finish_date = Finishes.[Last Diff Backup END]
					)
					WHEN 1 THEN ''(CV)''
					ELSE ''''
				END	
			+ ISNULL(
					CAST(
						Finishes.[Last Diff Backup END]	as varchar(19))
				, ''--'')
			+ @TAB + ''DaysLastDiff:'' 
				+ ISNULL(
					CAST(
						DATEDIFF(dd,Finishes.[Last Diff Backup END],getdate())
					as varchar(4))
				,''--'')
			+ @TAB + ''DiffDur(Mins):''
				+ ISNULL(
					CAST(
						DATEDIFF(minute, Starts.[Last Diff Backup START], Finishes.[Last Diff Backup END])
					as varchar(6))
				,''--'')
		ELSE
			''LastDiffBk:--''
			+ @TAB + ''DaysLastDiff:--'' 
			+ @TAB + ''DiffDur(Mins):--''
		END'

SET @Qstr4 = '		
		+ @TAB + CASE
		WHEN NOT EXISTS(SELECT 1 
			FROM DBServices.dbo.dbsDatabase dbs
			INNER JOIN DBServices.dbo.dbsCVSubclients cvs
				ON cvs.dbsDatabaseUID = dbs.dbsDatabaseUID
			INNER JOIN DBServices.dbo.dbsDatabaseBackup dbsb
				ON dbsb.dbsDatabaseUID = dbs.dbsDatabaseUID
			WHERE dbs.dbsDatabaseName = Finishes.name
				AND dbs.dbsDatabaseIsActive = 1
				AND cvs.dbsSubclientName LIKE ''%SIMPLE%''
				AND dbsb.dbsDBBackupType <> ''LS_Primary'') -- NOT SIMPLE Subclient

		THEN ''LastTlogBk:''
			+ CASE (SELECT TOP 1 1 
						FROM msdb.dbo.backupset bs WITH (NOLOCK)
						WHERE bs.type = ''L''
						AND bs.name = ''CommVault Galaxy Backup''
						AND bs.backup_start_date = Starts.[Last Tlog Backup START]
						AND bs.backup_finish_date = Finishes.[Last Tlog Backup END]
					)
					WHEN 1 THEN ''(CV)''
					ELSE ''''
				END	 
			+ ISNULL(
				CAST(Finishes.[Last Tlog Backup END] as varchar(19))
				,''--'')
			+ @TAB + ''TLogDur(Mins):'' 
				+ ISNULL(
					CAST(
						DATEDIFF(minute,Starts.[Last Tlog Backup START], Finishes.[Last Tlog Backup END])
					as varchar(4))
				,''--'')
			+ @TAB + ''LastTlog(Mins):''
				+ ISNULL(
					CAST(	
						DATEDIFF(minute, Finishes.[Last Tlog Backup END],getdate())
					as varchar(6))
				,''--'')
		ELSE 
			''LastTlogBk:--'' 
			+ @TAB + ''TLogDur(Mins):--'' 
			+ @TAB + ''LastTlog(Mins):--'' 
		END'

SET @Qstr5 = '
FROM (SELECT name
		,recovery_model_desc
		,D as ''Last Full Backup END''
		,I as ''Last Diff Backup END''
		,L as ''Last Tlog Backup END'' 
	FROM (SELECT db.name
				,db.recovery_model_desc
				,type
				,backup_finish_date
			FROM master.sys.databases db
			LEFT OUTER JOIN msdb.dbo.backupset a 
				ON a.database_name = db.name
			WHERE db.state = 0
				AND db.[name] <> ''tempdb''
				AND db.is_in_standby = 0
				AND (CASE db.is_read_only 
						WHEN 1 THEN ' + @IncludeReadOnlyBackups + '
						ELSE 1
					END = 1)
	)as Sourcetable   

PIVOT (MAX (backup_finish_date) FOR type IN (D,I,L)) as MostRecentBackup
	) as Finishes'

SET @Qstr6 = '
INNER JOIN (SELECT name
			,recovery_model_desc
			,D as ''Last Full Backup START''
			,I as ''Last Diff Backup START''
			,L as ''Last Tlog Backup START''
			FROM 
				(SELECT db.name
					,db.recovery_model_desc
					,type
					,backup_start_date
				FROM master.sys.databases db
				LEFT OUTER JOIN msdb.dbo.backupset a
					ON a.database_name = db.name
				WHERE db.state = 0
					AND db.[name] <> ''tempdb''
					AND db.is_in_standby = 0
				AND (CASE db.is_read_only 
						WHEN 1 THEN ' + @IncludeReadOnlyBackups + '
						ELSE 1
					END = 1)
			) as Sourcetable'

SET @Qstr7 = '
PIVOT (MAX (backup_start_date) FOR type IN (D,I,L)) as MostRecentBackup
	) as Starts
	ON Starts.name = Finishes.name
OPTION (MAXDOP 1)'

EXEC (@Qstr + @Qstr2 + @Qstr3 + @Qstr4 + @Qstr5 + @Qstr6 + @Qstr7)

SET @RC = @@ERROR
IF @RC <> 0
	 INSERT INTO #TblOutput VALUES ('--', 'Err', 'UBSMWE: usp_DBBackupChk: Runtime Error')

---------------------------------
-- Display results

SELECT DBName
		,[Status]
		,TestOutput
FROM #TblOutput
ORDER BY [Status], DBName

-- Determing result
SELECT @RC = COUNT(*) 
FROM #TblOutput
WHERE [Status] NOT IN ('OK', 'exclusion', 'AO replica')

RETURN @RC

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_dbUpdateStats]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_dbUpdateStats] (
		@DBName nvarchar(128)
		,@MaxRetryMins smallint = 0
		,@resample bit = 0)
AS
/****************************************************************************************
// @File: usp_dbUpdateStats.sql
// 
// Purpose:
// Executes an sp_updatestats post a DB Full or Diff Backup
//
// Notes: Called by System
//
// History: Dates are in dd/mm/yyyy format
//
//    @Date:10/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta 
//    @Date:09/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 RC3 
//    @Date:03/03/2015 @Author: Chris Basson @Version: 6.0.0.26 @Action: TRR-125
//    @Date:30/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: TRR-131
//    @Date:07/10/2015 @Author: Chris Basson @Version: 6.0.0.39 @Action: Bugfix; TRRv3 case polling issue if a wait overruns to the next day 
****************************************************************************************/

BEGIN --Main
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE 
	@RC int
	,@backup_finish_date datetime
	,@CVSchedulePolicy nvarchar(64)
	,@dbsBackupProcessor tinyint
	,@SQLStr nvarchar(255)
	,@TodaysScheduleOut smalldatetime
	,@StartTime smalldatetime
	,@RetryCnt smallint
	,@ErrorMsg varchar(255)
	,@CVSchedEnabled bit
	,@ExceptionTime char(5)
	,@dbsUpdateStatsASAP bit
	,@dbsDFGEntryTime datetime

--------------------------------------------------------
-- Init vars

SET @RetryCnt = 0
SET @StartTime = getdate()

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsUpdateStatsASAP', @dbsUpdateStatsASAP OUTPUT, @quiet=1

--------------------------------------------------------

PRINT 'Start time: ' + CAST (@StartTime as nvarchar(20)) 

IF @dbsUpdateStatsASAP = 1		-- User override 
	GOTO UPDATESTATS -- run immediately 

----------------------------
-- Determine if an updatestats override time exception exists for the DB

SELECT TOP 1 @ExceptionTime = RIGHT(dbsDatabaseExceptionSubType,5) 
FROM DBServices.dbo.dbsDatabase db 
INNER JOIN DBServices.dbo.dbsDatabaseException dbe 
	ON dbe.dbsDatabaseUID = db.dbsDatabaseUID
WHERE db.dbsDatabaseName = @DBName
	AND db.dbsDatabaseIsActive = 1
	AND dbe.dbsDatabaseExceptionSubType LIKE 'updatestats@__:__' -- Messy but saves schema change
	AND dbsExceptionActive = 1
ORDER BY dbe.dbsExceptionDate DESC

IF @ExceptionTime IS NOT NULL
	AND ISDATE (@ExceptionTime) = 1
BEGIN
	PRINT '=> updatestats execution time exception identified for ' + @DBName 
		+ '; waiting until: ' + @ExceptionTime

	WAITFOR TIME @ExceptionTime
	GOTO UPDATESTATS
END

----------------------------
-- If not TRRv3 - skip backup checks

IF @dbsBackupProcessor <> 5
	GOTO UPDATESTATS -- Just exec as MWE runs in sequence

----------------------------
-- ELSE @dbsBackupProcessor = 5 - continue...

IF @MaxRetryMins NOT BETWEEN 1 AND 1380
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsUpdateStatsMaxRetryMins', @MaxRetryMins OUTPUT 
	IF @RC <> 0
		SET @MaxRetryMins = 300 -- Default to 300 mins
END

--------------------------------------------------------
-- Verifiy last DB Full or Diff backup ran

GET_BACKUP_DATA:

SELECT TOP 1 @backup_finish_date = bs.backup_finish_date
	, @CVSchedulePolicy = scs.CVSchedulePolicy
	, @CVSchedEnabled = scs.[Enabled]

FROM DBServices.dbo.dbsDatabase db 
INNER JOIN DBServices.dbo.dbsCVSubclients sc
	ON sc.dbsDatabaseUID = db.dbsDatabaseUID
INNER JOIN DBServices.dbo.dbsCVSchedule scs 
	ON scs.CVSubclient = sc.dbsSubclientName
LEFT OUTER JOIN msdb.dbo.backupset bs WITH (NOLOCK)
	ON bs.database_name = db.dbsDatabaseName

WHERE db.dbsDatabaseName = @DBName
	AND db.dbsDatabaseIsActive = 1
	AND bs.[type] IN ('D','I')
GROUP BY db.dbsDatabaseName, bs.backup_finish_date, scs.CVSchedulePolicy, scs.[Enabled]
ORDER BY bs.backup_finish_date DESC

----------------------------
-- Get CV Schedule details

IF @CVSchedEnabled = 0
BEGIN
	PRINT 'INFO: CV Schedule policy ' + @CVSchedulePolicy 
		+ ' is disabled - executing updatestats; however results may not be optimal'
	GOTO UPDATESTATS
END

EXEC @RC = [DBServices].[dbo].[usp_CVSchedulePolicyDecode] 
		@CVSchedulePolicy = @CVSchedulePolicy
		,@TodaysScheduleOut = @TodaysScheduleOut OUTPUT

----------------

IF @RC <> 0
	OR @backup_finish_date IS NULL
	OR @TodaysScheduleOut IS NULL
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_dbUpdateStats: ERROR: Unable to determine CVSchedulePolicy or backup_finish_date for ' + @DBName
					+ ' - executing updatestats; however results may not be optimal'
	GOTO UPDATESTATS
END

----------------
-- Determine if DB reindex initiated immediate run

SELECT TOP 1 @dbsDFGEntryTime = dbsDFGEntryTime -- DB Reindex time
FROM DBServices.dbo.dbsIndexDFRG id
WHERE dbsDatabaseName = @DBName
ORDER BY dbsDFGEntryTime DESC

IF (@dbsDFGEntryTime IS NULL OR DATEDIFF(hour, @dbsDFGEntryTime, getdate()) < 23)
	AND ( (getdate() < @TodaysScheduleOut) --days backup not yet occured
			OR (@backup_finish_date > @TodaysScheduleOut) -- days backup already occured		
		)
	GOTO UPDATESTATS -- run immediately 

----------------
SELECT
	@DBName as 'DBName'
	,@CVSchedulePolicy as 'CVSchedulePolicy'
	,@TodaysScheduleOut as 'TodaysScheduleOut'
	,@backup_finish_date as 'backup_finish_date'

PRINT '=> updatestats will execute once the days DB backups have been completed or dbsUpdateStatsMaxRetryMins: '
		 + CAST(@MaxRetryMins as varchar(5)) + 'mins is reached'

----------------
-- Wait for CV Schedule backups to complete

WHILE @CVSchedEnabled = 1
	AND (@TodaysScheduleOut >= getdate() -- Scheduled backup has not started yet
		OR @backup_finish_date < @TodaysScheduleOut) -- Scheduled backup not completed
	AND @RetryCnt <= @MaxRetryMins -- wait for upto @MaxRetryMins
BEGIN

	IF (DATEPART(DAY, @TodaysScheduleOut) <> DATEPART(DAY, getdate())) -- rolled over to next day
		AND NOT EXISTS
			(	-- No backup running 	
				SELECT TOP 1 1 
				FROM sys.dm_exec_requests r 
					CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) a 
				WHERE r.command = 'BACKUP DATABASE' 
					AND a.[text] LIKE '%'+ @DBName + '%'
			) 
		GOTO GET_BACKUP_DATA -- Refresh schedule status
	ELSE ----------------
		SELECT TOP 1 @backup_finish_date = bs.backup_finish_date
		FROM msdb.dbo.backupset bs WITH (NOLOCK)
		WHERE bs.database_name = @DBName
			AND bs.[type] IN ('D','I')
			AND bs.backup_finish_date >= @TodaysScheduleOut
		GROUP BY bs.database_name, bs.backup_finish_date
		ORDER BY bs.backup_finish_date DESC

	IF @backup_finish_date IS NULL
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_dbUpdateStats: WARNING: Unable to determine CVSchedulePolicy or backup_finish_date for ' + @DBName
						+ ' - executing updatestats; however results may not be optimal'
		SELECT
			getdate() as 'Time'
			,@CVSchedulePolicy as 'CVSchedulePolicy'
			,@TodaysScheduleOut as 'TodaysScheduleOut'
			,@backup_finish_date as 'backup_finish_date'
			,@RetryCnt as 'RetryCntMins'
			,@MaxRetryMins as 'MaxRetryMins'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2			
		BREAK
	END

	WAITFOR DELAY '00:01' -- Wait 1min
	SET @RetryCnt = @RetryCnt + 1 
END

--------------------------------------------------------
UPDATESTATS:

PRINT 'Execution time: ' + CAST (getdate() as nvarchar(40)) 

SET @SQLStr = '[' + @DBName + ']..sp_updatestats'
		+ CASE @resample
			WHEN 1 THEN ' @resample =''resample'''
			ELSE ''
		 END
EXEC (@SQLStr)

SET @RC = @@ERROR
IF @RC <> 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_dbUpdateStats: Unhandled exception updatestats failed for ' + @DBName
	GOTO END_IT
END
ELSE 
	RETURN 0 -- Success

--------------------------------------------------------
END_IT:

-- Raise error
EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2		

RETURN 1 -- quit with failure

END --Main

GO
/****** Object:  StoredProcedure [dbo].[usp_DelFile]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_DelFile] (@Filename nvarchar(255))
AS

/****************************************************************************************
// @File: usp_DelFile.SQL
//
// @Version 6.0.0.29
//
// Purpose:
//   Deletes a given file and bypasses 128 char del cmd limit
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 02/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.7 @Action: TRRv3 Beta 
//   @Date: 04/04/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.29 @Action: Refined
****************************************************************************************/

BEGIN -- main
SET NOCOUNT ON
SET DATEFORMAT ymd
SET QUOTED_IDENTIFIER ON

DECLARE @RC int,
		@cmd nvarchar(640),
		@slashpos tinyint,
		@ActualFilename nvarchar(128),
		@Path nvarchar(255)

SET @Filename = LTRIM(RTRIM(@Filename))
SET @slashpos = CHARINDEX('\', REVERSE(@Filename))
SET @ActualFilename = RIGHT(@Filename, @slashpos-1)
SET @Path = LEFT(@Filename, LEN(@Filename) - @slashpos)

SET @cmd= LEFT(@Path,2) 
	+ ' & cd "' + @Path 
	+ '" & del "' + @ActualFilename + '" /F /Q'

EXEC @RC = master..xp_cmdshell @cmd, no_output

SET QUOTED_IDENTIFIER OFF

RETURN @RC

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_Display_LogMarks]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

create proc [dbo].[usp_Display_LogMarks]
		@Target_DB nvarchar(60) = 'N/A',
		@Mark_startstring nvarchar(10) = 'N/A'
		
as
/*
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
*/

SET DATEFORMAT ymd
declare @cmd nvarchar(100)

set nocount on

CREATE table #Syslogs(
[Current LSN]		nvarchar(50),
Operation     		nvarchar(50),
Context       		nvarchar(50),
[Transaction ID] 	nvarchar(50),
[Tag Bits]		nvarchar(50),
[Log Record Length]	nvarchar(50),
[Previous LSN]		nvarchar(50),
[Flag Bits]		nvarchar(50),
[Log Marks]		nvarchar(50) )

select @cmd = 'DBCC log ('+@Target_DB+',1 ) WITH NO_INFOMSGS'

insert #Syslogs
	exec (@cmd ) 

select distinct [Log Marks] from #syslogs
	where [Log Marks] like @Mark_startstring

if @@rowcount = 0
	print 'No Log Marks available'


GO
/****** Object:  StoredProcedure [dbo].[usp_FileExists]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_FileExists] 
		(
			@FileName nvarchar(255),
			@exists bit = 0 OUTPUT
		)
AS

/************************************************************************************************
Name: 		usp_FileExists.SQL
Purpose:	Get filename for  scheduled jobs for a task for output log
              
Modification History:
Version  Name                Date        Notes
1.0      Rakesh Bist   	    21/04/2006   Original version
					 Add to the DBServices UBSMWE (2.0)
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production//
//   @Date: 08/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Update for case sensitive issues.
//   @Date: 08/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
************************************************************************************************/

BEGIN -- main

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @command nvarchar(300)
	, @RC int
	, @echo_text nvarchar(20)
	, @ErrCode int

SET @echo_text = 'FILE_EXISTS'
SET @command = N'if exist "' + @FileName COLLATE database_default + N'" echo ' + @echo_text

DECLARE @text_ret TABLE (cmdoutput nvarchar(20) COLLATE database_default NULL)

INSERT INTO @text_ret 
	EXEC @RC = master..xp_cmdshell @command

SET @ErrCode = @@ERROR
IF @ErrCode <> 0 OR @RC <> 0
BEGIN
	PRINT 'UBSMWE: usp_FileExists: Unhandled exception error: ' + CAST(@ErrCode as varchar(8)) 
		+ ' - ' + @FileName + ' Unable to identify if file exists' 
    SET @exists = 0
	RETURN 1
END

IF EXISTS (SELECT 1 FROM @text_ret WHERE LTRIM(RTRIM(UPPER(cmdoutput))) = @echo_text)
    SET @exists = 1
ELSE 
    SET @exists = 0

RETURN 0

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_FileRetentionStatus]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_FileRetentionStatus] (
					@FullFilePath nvarchar(255)
					, @dbUID uniqueidentifier
					, @CreateDate datetime
					, @KeepFile bit OUTPUT )
AS

/****************************************************************************************
// @File: usp_FileRetentionStatus.sql - replaces original GetFileRetainHours.SQL
// 
// Purpose:
//   Return 1 for keep given file or 0 to delete
//
// Notes: This Function is called from usp_PurgeOldBackupFiles
//
// History: Date Format dd/mm/yyyy
//
//			@dbsDBHFileName ,@dbsDatabaseUID ,@dbsDBHEndDate
//
//	 @Date: 31/07/2014 @Author: Chris Basson @Version 6.0.0.0 @Action: TRRv3 Beta
//	 @Date: 07/10/2014 @Author: Chris Basson @Version 6.0.0.8 @Action: TRRv3 Beta
//	 @Date  19/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.28 @Action: Refinement
****************************************************************************************/

BEGIN -- main

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RetainHours int
	, @HoursPast int
	, @ReturnValue bit
	, @RC int
	, @sqlError1 nvarchar(500)
	, @dbsDatabaseExceptionSubType nvarchar(255)
	, @dbsExceptionActive bit
	, @dbsDiffBackup bit
	, @dbsFGRPBackup bit
	, @now datetime
	, @debug tinyint
	, @exists bit

SET @ReturnValue = 1 -- keep file by default
SET @RC = 0
SET @now = getdate()
SET @RetainHours = NULL

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDiffBackup', @dbsDiffBackup OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsFGRPBackup', @dbsFGRPBackup OUTPUT, @quiet = 1


IF NOT (CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 
	OR CHARINDEX('_Part_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0
	OR CHARINDEX('_Diff_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0
	OR CHARINDEX('_LOG_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0) 
BEGIN
	SET @exists = 0
	EXEC @RC = [DBServices].[dbo].[usp_FileExists] 
		   @FullFilePath
		  ,@exists OUTPUT

	-- External file dump thus prevent deletion if file exists as not fully managed by UBSMWE
	-- otherwise mark to remove entry from FS backups
	SET @ReturnValue = @exists 

	GOTO END_IT
END
ELSE
BEGIN

	SELECT TOP 1
		@RetainHours = dbe.dbsRetain 
		,@dbsDatabaseExceptionSubType = LOWER(LTRIM(RTRIM(dbe.dbsDatabaseExceptionSubType)))
		,@dbsExceptionActive = dbe.dbsExceptionActive
	FROM DBServices.dbo.dbsDatabaseException dbe
	WHERE dbsDatabaseUID = @dbUID
		AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'backup'
		AND LOWER(LTRIM(RTRIM(dbe.dbsDatabaseExceptionSubType))) = CASE
				WHEN CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0
					AND @dbsDiffBackup = 1 
					AND dbe.dbsExceptionActive = 1 THEN 'differential'
				WHEN CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 
					AND @dbsDiffBackup = 1 
					AND dbe.dbsExceptionActive = 0 THEN 'full'
				WHEN CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 
					AND @dbsFGRPBackup = 1 
					AND dbe.dbsExceptionActive = 1 THEN 'partial'
				WHEN CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 
					AND @dbsFGRPBackup = 1 
					AND dbe.dbsExceptionActive = 0 THEN 'full'
				WHEN CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 
					AND @dbsDiffBackup = 0 
					AND @dbsFGRPBackup = 0 THEN 'full'
				WHEN CHARINDEX('_Part_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 THEN 'partial'
				WHEN CHARINDEX('_Diff_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 THEN 'differential'
				WHEN CHARINDEX('_LOG_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0 THEN 'transaction_log'
				ELSE NULL
				END
	ORDER BY dbe.dbsDatabaseExceptionID DESC	

	IF @debug = 3
	BEGIN
		PRINT '------------------------------------------------'	
		PRINT 'usp_FileRetentionStatus: Exception status => '
		PRINT 'usp_FileRetentionStatus: dbsDiffBackup: ' + CAST(@dbsDiffBackup as varchar(5))
		PRINT 'usp_FileRetentionStatus: dbsFGRPBackup: ' + CAST(@dbsFGRPBackup as varchar(5))
		PRINT 'usp_FileRetentionStatus: RetainHours: ' + CAST(@RetainHours as varchar(5))
		PRINT 'usp_FileRetentionStatus: dbsDatabaseExceptionSubType: ' + CAST(@dbsDatabaseExceptionSubType as varchar(128))	
		PRINT 'usp_FileRetentionStatus: dbsExceptionActive: ' + CAST(@dbsExceptionActive as char(1))
		PRINT '------------------------------------------------'			
	END

	IF @dbsDiffBackup = 1 
		AND (CHARINDEX('_Full_',@FullFilePath COLLATE Latin1_General_CS_AS) > 0)
		AND	@RetainHours IS NULL	-- No exception found for FULL backup when differentials enabled - thus use dbsDiffBackupThreshold value
	BEGIN
		IF EXISTS (SELECT 1 
			FROM [DBServices].[dbo].[dbsDatabase]
			WHERE [dbsDatabaseUID] = @dbUID
				AND ([dbsDatabaseIsActive] = 1 OR [dbsDatabaseName] LIKE '%*OFFLINE*')
				AND [dbsDatabaseIsSystemObjectFlag] = 0)
		
			EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDiffBackupThreshold', @RetainHours OUTPUT, @quiet = 1 
	END

	IF @RetainHours IS NULL -- No exception found - just use dbinstance dbsRetainBackupFileDurationHrs value
	BEGIN

		EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsRetainBackupFileDurationHrs', @RetainHours OUTPUT, @quiet = 1 

		IF @RC <> 0
			OR @RetainHours IS NULL
		BEGIN
			SET @sqlError1 = 'UBSMWE: usp_FileRetentionStatus: Setting dbsRetainBackupFileDurationHrs was not found in dbsInstanceConfig; defaulting to 23' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @sqlError1, 1

			SET @RetainHours = 23
		END
	END

	-------------------

	SET @HoursPast =  DATEDIFF(hh, @CreateDate, @now)	

	IF @RetainHours < @HoursPast
		--file is older then retention period, code for purging the file
		SET @ReturnValue = 0

	-- AVC Added = otherwise we return a -1 and run around the retry loop for ages when the hour equals the same as retain!
	-- On systems with many databases and therefore 1000's of t.log this causes the procedure
	-- to be too slow and we don't delete our full backups in time...

	IF @RetainHours >= @HoursPast
	BEGIN 
		--file is newer then retnetion period return 1 to prevent deletion
		SET @ReturnValue = 1
	END

	IF @debug = 3
	BEGIN
		PRINT '------------------------------------------------'	
		PRINT 'usp_FileRetentionStatus: Final results =>'
		PRINT 'usp_FileRetentionStatus: FullFilePath: ' + CAST(@FullFilePath as varchar(255))
		PRINT 'usp_FileRetentionStatus: dbUID: ' + CAST(@dbUID as varchar(50))
		PRINT 'usp_FileRetentionStatus: RetainHours: ' + CAST(@RetainHours as varchar(5))
		PRINT 'usp_FileRetentionStatus: HoursPast: ' + CAST(@HoursPast as varchar(5))	
		PRINT 'usp_FileRetentionStatus: ReturnValue: ' + CAST(@ReturnValue as varchar(5))	
		PRINT '------------------------------------------------'		
	END
END

END_IT:
		
SET @KeepFile = @ReturnValue
  
END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_fixeddrives2]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_fixeddrives2] @PercThreshold tinyint = NULL, @quiet bit = 0
AS

/****************************************************************************************
// @File: usp_fixeddrives2.sql
// 
// Purpose:
//   Alternative to xp_fixeddrives: displays drive free space inc mountpoints
//
// Dependancies: xp_cmdshell
//
// Notes: This stored procedure can be run by hand
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 21/11/2014 @Author: Chris Basson @Version: 6.0.0.12 @Action: TRRv3
//   @Date: 27/10/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Minor Refinement
****************************************************************************************/

BEGIN --main

SET ARITHIGNORE ON
SET NOCOUNT ON

DECLARE @RC int
	,@astr nvarchar(512)
	,@OutDelimiter char(1)
	,@Node varchar(128) 
	,@Caption nvarchar(128) 
	,@DeviceID varchar(128) 
	,@DriveType tinyint
	,@FreeSpace real
	,@DeviceName nvarchar(128) 
	,@TotalCapacity real
	,@VolumeName nvarchar(128) 
	,@PercFree smallint
	,@now smalldatetime
	
-----------------------------------------------
-- Init

SET @OutDelimiter = ','
SET @now = getdate()

IF @PercThreshold IS NULL
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupLUN_SpaceThresholdPerc', @PercThreshold OUTPUT

IF @PercThreshold NOT BETWEEN 0 AND 100
BEGIN
	PRINT '@PercTreshold must be a value between 0 and 100'
	RETURN 1
END	

DECLARE @VolInfoRAW TABLE (
    [VolRAW] nvarchar(512))

IF object_id('DBServices.dbo.dbsVolInfo ') IS NULL
	CREATE TABLE DBServices.dbo.dbsVolInfo (
		Node varchar(128) null
		,Capacity real
		,Caption nvarchar(128) null
		,DeviceID varchar(128) null
		,DriveType tinyint null
		,FreeSpace real
		,DeviceName nvarchar(128) null
		,PercFree smallint null
		,ThresholdStatus varchar(8)
		,LastRun smalldatetime)

-----------------------------------------------
-- Get data using wmic

IF EXISTS (SELECT 1		
		FROM DBServices.dbo.dbsVolInfo
		WHERE LastRun > DATEADD(mi,-5,@now))
BEGIN
	IF @quiet = 0
		PRINT 'Last execution < 5 mins - using existing data...'

	GOTO SKIP_REFRESH	-- Skip data refresh as run in the last 5 mins
END
ELSE
	TRUNCATE TABLE DBServices.dbo.dbsVolInfo

INSERT INTO @VolInfoRAW
EXEC master..xp_cmdshell 'WMIC /FailFast:ON volume WHERE (DriveType = "3") GET DeviceID, Name, Caption, Capacity, FreeSpace, DriveType /Format:csv'

/*
drivetype:
 0 = Unknown
 1 = No Root Directory
 2 = Removable Disk
 3 = Local Disk
 4 = Network Drive
 5 = Compact Disc
 6 = RAM Disk
*/

-- Clean up output
DELETE
FROM @VolInfoRAW
WHERE ISNULL(LTRIM(RTRIM([VolRAW])), '') = '' 
	OR [VolRAW] LIKE 'Node,%'
	OR [VolRAW] LIKE '\\?\Volume{%'
	OR LEN([VolRAW]) < 7

-----------------------------------------------
-- Parse RAW csv output

BEGIN TRANSACTION

DECLARE volcur CURSOR FAST_FORWARD FOR
SELECT LTRIM(RTRIM([VolRAW])) 
FROM @VolInfoRAW

OPEN volcur 

FETCH NEXT FROM volcur INTO @astr
WHILE @@FETCH_STATUS=0 
BEGIN
	-- Parse @astr into #VolInfoParsed
	-- @astr order: Node,Capacity,Caption,DeviceID,DriveType,FreeSpace,Name

	SELECT @TotalCapacity= CAST(Value as real)/1048576 FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 2
	IF ISNULL(@TotalCapacity, 0) = 0
		GOTO SKIPIT
		
	-- else parse the rest
	SELECT @Node=Value FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 1
	SELECT @Caption=REPLACE(REPLACE(Value, char(13),''), char(10),'') FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 3
	SELECT @DeviceID=REPLACE(REPLACE(Value, char(13),''), char(10),'') FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 4 -- not used, for future info
	SELECT @DriveType=CAST (Value as tinyint) FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 5 -- not used, for future info
	SELECT @FreeSpace= CAST(Value as real)/1048576 FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 6
	SELECT @DeviceName=REPLACE(REPLACE(Value, char(13),''), char(10),'') FROM DBServices.dbo.fn_Split(@OutDelimiter, @astr) WHERE RowID = 7

	SET @PercFree = CAST((@FreeSpace / @TotalCapacity) * 100 as smallint)
		
	INSERT INTO DBServices.dbo.dbsVolInfo WITH (TABLOCKX, HOLDLOCK) 
	VALUES (
		@Node
		, @TotalCapacity
		, @Caption
		, @DeviceID
		, @DriveType
		, @FreeSpace
		, @DeviceName
		, @PercFree
		, CASE 
			WHEN @PercFree <= @PercThreshold THEN '*ALERT*'
			ELSE 'OK' 
	 	 END
		, @now)

	SKIPIT: 	
	FETCH NEXT FROM volcur INTO @astr
END
CLOSE volcur
DEALLOCATE volcur 

COMMIT TRANSACTION
-----------------------------------------------
-- Display and return code

SKIP_REFRESH:

IF @quiet = 0
	SELECT 
		DeviceName
		,CAST(Capacity as numeric(20,2)) as 'CapacityMB'
		,CAST(FreeSpace as numeric(20,2)) as 'FreeMB'
		,PercFree
		,ThresholdStatus 
	FROM DBServices.dbo.dbsVolInfo
	ORDER BY DeviceName

IF EXISTS (SELECT 1 
			FROM DBServices.dbo.dbsVolInfo
			WHERE ISNULL(DeviceName, '') <> ''
				AND PercFree <= @PercThreshold) 
	SET @RC = 999
ELSE		
	SET @RC = 0

-----------------------------------------------

RETURN @RC

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_Gen_rnd_filename]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_Gen_rnd_filename](
		@Suffix as nvarchar(20) = ''
		,@RTN_Filename nvarchar(32) OUTPUT )
AS
/****************************************************************************************
// @File: usp_Gen_rnd_filename.SQL
//
// @Version 6.0.0.21
//
// Purpose: Generates a unique random filename with the users login name 
// Notes: MWE system sp, not for user usage
//	Output filename max 32 chars in length
// History: Date Format dd/mm/yyyy
//
//	@Date: 05/06/2014 @Author: Chris Basson @Version 6.0.0.0 @Action: TRRv3 Beta Created
//	@Date: 03/10/2014 @Author: Chris Basson @Version 6.0.0.7 @Action: TRRv3 Beta
//	@Date: 16/01/2014 @Author: Chris Basson @Version 6.0.0.21 @Action: bugfix
****************************************************************************************/

SET NOCOUNT ON
SET DATEFORMAT ymd

BEGIN -- main

DECLARE @pool nchar(62)
		,@counter int
		,@rstring nvarchar(128)
		,@Pos smallint 

SET @Suffix = LTRIM(RTRIM(@Suffix))
SET @pool = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
SET @counter = 1
SET @rstring = ''

WHILE @counter <= 6
BEGIN
	SET @Pos = CEILING(RAND() * 62)
	SET @rstring = @rstring + SUBSTRING(@pool, @Pos, 1)
	SET @counter = @counter + 1
END

SET @Pos = CHARINDEX ('\', REVERSE (SUSER_NAME()))

SET @RTN_Filename = @rstring + '_' 
	+ LEFT(REPLACE(
			CASE
			WHEN @Pos > 0
				THEN RIGHT(SUSER_NAME(), @Pos - 1)
				ELSE SUSER_NAME()
			END
			, ' ', '_')
		,10) 
	+ LEFT(@Suffix,11) 
	+ '.txt'

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_GenerateSubclientGroup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_GenerateSubclientGroup] 	
						 @DBName nvarchar(128)
						,@dbsSubclientGroupDistributionMode tinyint  --0=Size, 1=Add to s.client with least DB's ,2=Named Group
						,@dbsConfigType nvarchar(20)
						,@dbsConfigTypeGroupOut nvarchar(20) OUTPUT
						,@dbsFailed bit OUTPUT
AS

/****************************************************************************************
// @File: usp_GenerateSubclientGroup.SQL
// @Version: 6.0.0.7
// Purpose:
//   Returns the name of the subclient group that the DB should be added to
//
// Notes: Called by usp_ConfigureCVSubclients 
//
// History: Dates are in dd/mm/yyyy format
//
//   @Date: 10/02/2014 @Author: Andrew Calvett @Version: 5.0.10 @Action: First release of proc to return group subclient to add/move to
//   @Date: 20/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta - bugfix
//   @Date: 02/09/2014 @Author: Chris Basson @Version: 6.0.0.5 @Action: TRRv3 Beta - bugfix
//   @Date: 02/09/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta - input param standard
//
****************************************************************************************/
BEGIN -- main
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @CV_SubclientGroupingType tinyint
	,@CV_SubclientGroupingNumGroups tinyint
	,@RC int							
	,@dbsNumRecoveryModels tinyint
	,@dbsRecovery nvarchar(128)
	,@dbsGroupRecovery nvarchar(128)
	,@dbsAddGroup tinyint

SET @dbsFailed = 0

--This table is used to allow us to do concurrent group adds. If we did not use it we would have to do them serially because
--we would not be able to calculate the right group to add a db to and we don't want to do that because things are slow enough already... :)

IF NOT EXISTS (SELECT 1 FROM DBServices.sys.objects
				WHERE [name] = 'dbsCVSubclient_GroupChecks' AND type = 'U')
	CREATE TABLE DBServices.dbo.dbsCVSubclient_GroupChecks
		(
		 dbsDatabaseName nvarchar(128) NULL,
		 dbsSubclientName nvarchar(128) NULL,
		 dbsRuntime datetime NULL
		)


--We should never see a record in here with the same db name or older than 60 mins unless CV is seriously hosed so we can assume it has been orphaned some how
IF EXISTS (SELECT 1 
			FROM DBServices.dbo.dbsCVSubclient_GroupChecks 
			WHERE DATEDIFF(MI,dbsRuntime,getdate()) > 60 
				OR dbsDatabaseName = @DBName)
BEGIN
	DELETE FROM DBServices.dbo.dbsCVSubclient_GroupChecks
	WHERE DATEDIFF(MI,dbsRuntime,getdate()) > 60
		OR dbsDatabaseName = @DBName
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_SubclientGroupingType', @CV_SubclientGroupingType OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_SubclientGroupingNumGroups', @CV_SubclientGroupingNumGroups OUTPUT

IF @dbsSubclientGroupDistributionMode is NULL
	SET @dbsSubclientGroupDistributionMode = 0 --Default it to a size based distribution

PRINT 'Performing GROUP SubClient operation for '+ @DBName

-- Global value has to be 2 for backups to use GROUPING so if its not set then we bail out here.
IF @CV_SubclientGroupingType <> 2
BEGIN
	PRINT 'UBSMWE: usp_GenerateSubclientGroup: You are attemping to add a database to the GROUP subclient but the UBSMWE is not configured to initiate group backups.'
	PRINT 'If you intend to initate group backups execute the command below and resubmit the ConfigureCVSubclient command.'
	PRINT 'EXECUTE [dbo].[usp_ConfigureUBSMWE] ''CV_SubclientGroupingType'', 2 '
	PRINT 'Database '+ @DBName + ' was NOT added to any subclient.'
	SET @dbsFailed = 1
	GOTO Exit_Proc
END

--Check we have a valid number of subclient groups configured
IF @CV_SubclientGroupingNumGroups < 2 or @CV_SubclientGroupingNumGroups > 8
BEGIN
	PRINT 'UBSMWE: usp_GenerateSubclientGroup: The number of subclient groups to be used is incorrectly specified as: ' 
		+ ISNULL(CAST(@CV_SubclientGroupingNumGroups as nvarchar (4)),'<NULL>') + '.'
	PRINT 'Please correct the configuration error by executing the command below with a valid value between 2 & 8 (4 is recommended).'
	PRINT 'EXECUTE [dbo].[usp_ConfigureUBSMWE] ''CV_SubclientGroupingNumGroups'', 4 '
	PRINT 'Database '+ @DBName + ' was NOT added to any subclient.'
	SET @dbsFailed = 1
	GOTO Exit_Proc
END

--Validate that the group name is formed correctly as this was user supplied
IF @dbsSubclientGroupDistributionMode = 2 and (LEN(@dbsConfigType) <> 6 or ISNUMERIC(RIGHT(@dbsConfigType,1)) = 0)
BEGIN
	PRINT 'UBSMWE: usp_GenerateSubclientGroup: Invalid named group supplied: "' 
		+ @dbsConfigType + '". Resubmit the command with a valid group name.'
	PRINT 'Valid group names are GROUP<1-8>, for example GROUP1 adds a db to GROUP1.'
	PRINT 'Database '+ @DBName + ' was NOT added to any subclient.'
	SET @dbsFailed = 1
	GOTO Exit_Proc
END
--Validate we have a group number 1-8 in the group name passed in by the user.
IF @dbsSubclientGroupDistributionMode = 2 and (RIGHT(@dbsConfigType,1) = 0 or RIGHT(@dbsConfigType,1) > 8)
BEGIN
	PRINT 'UBSMWE: usp_GenerateSubclientGroup: Invalid named group number supplied: "'
		 + @dbsConfigType + '" resubmit the command with a valid group number.'
	PRINT 'Valid group numbers are GROUP<1-8>, for example GROUP1 adds a db to GROUP1.'
	PRINT 'Database '+ @DBName + ' was NOT added to any subclient.'
	SET @dbsFailed = 1
	GOTO Exit_Proc
END

--We begin a transaction here because we want to lock out the table in DBServices to ensure serial access 
--to the table whilst we work out the group to use (pretty fast) so should not cause any issues.

BEGIN TRAN
--Check we are not mixing recovery modes within the groups. SIMPLE recovery databases can not be mixed with FULL/Bulk Logged
SELECT 
	@dbsGroupRecovery =   
		CASE DATABASEPROPERTYEX(COALESCE(dbsD.dbsDatabaseName,dbsSubTmp.dbsDatabaseName) ,'Recovery')
			WHEN 'BULK_LOGGED' THEN 'FULL'
			WHEN 'FULL' THEN 'FULL'
			WHEN 'SIMPLE' THEN 'SIMPLE'
			ELSE 'UNKNOWN'
		END 	
	,@dbsRecovery = UPPER(CONVERT(nvarchar, DATABASEPROPERTYEX(@DBName, 'recovery')))
FROM 
	[DBServices].[dbo].[dbsDatabase] dbsD
	JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB 
		ON dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB 
		ON dbsSubDB.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	LEFT OUTER JOIN DBServices.dbo.dbsCVSubclient_GroupChecks dbsSubTmp (tablockx) 
		ON UPPER(dbsSubDB.dbsDatabaseName) = UPPER(dbsSubTmp.dbsDatabaseName)
WHERE  
	dbsD.dbsDatabaseIsActive = 1 
	AND (dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]' or dbsSubTmp.dbsSubclientName LIKE '%GROUP[0-9]')
GROUP BY
	DATABASEPROPERTYEX(COALESCE(dbsD.dbsDatabaseName,dbsSubTmp.dbsDatabaseName),'Recovery')
	

IF ISNULL(@dbsGroupRecovery,@dbsRecovery) <> @dbsRecovery --Now we have the values we can check. ISNULL handles the first ever add to a group
BEGIN
	PRINT 'UBSMWE: usp_GenerateSubclientGroup: The database ' + @DBName + ' has a recovery model of ' 
		+ @dbsRecovery + ' which is not compatible with the other databases present in the GROUP subclient.'
	PRINT 'Either change the recovery model of the database or use a subclient other than GROUP'
	PRINT 'Database '+ @DBName + ' was NOT added to any subclient.'
	SET @dbsFailed = 1
	GOTO Exit_Proc_With_Commit
END
 

--DO A CHECK HERE TO SEE IF THE GROUP ALREADY EXISTS, if not just set it and move on...
--This works out the highest group number in use.
SELECT TOP 1
	@dbsAddGroup =  CAST(COALESCE(RIGHT(dbsSubTmp.dbsSubclientName,1), RIGHT(dbsSubDB.dbsSubclientName,1),0) as tinyint)
FROM [DBServices].[dbo].[dbsDatabase] dbsD
INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB 
	ON dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB 
	ON dbsSubDB.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
LEFT OUTER JOIN DBServices.dbo.dbsCVSubclient_GroupChecks dbsSubTmp (tablockx) 
	ON UPPER(dbsSubDB.dbsDatabaseName)  = UPPER(dbsSubTmp.dbsDatabaseName)
WHERE  
	dbsD.dbsDatabaseIsActive = 1 
	AND (dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]' OR dbsSubTmp.dbsSubclientName LIKE '%GROUP[0-9]')
ORDER BY  
	CAST(COALESCE(RIGHT(dbsSubTmp.dbsSubclientName,1),RIGHT(dbsSubDB.dbsSubclientName,1),0) as tinyint) desc

IF @CV_SubclientGroupingNumGroups > ISNULL(@dbsAddGroup,0) AND LEN(@dbsConfigType) = 5 
BEGIN
	--We have not used all our configured groups yet so thats the one to use.
	SELECT @dbsConfigTypeGroupOut  = 'GROUP' + CAST(ISNULL(@dbsAddGroup,0) + 1 as nvarchar(2))

	INSERT INTO DBServices.dbo.dbsCVSubclient_GroupChecks
	VALUES (@DBName,@dbsConfigTypeGroupOut,getdate())
	GOTO Exit_Proc_With_Commit
END


IF 	@dbsSubclientGroupDistributionMode = 0 
BEGIN
	--This gets the size of the databases per group, by ordering the size ASC we get the group with the smallest total db size.
	SELECT TOP 1
		@dbsConfigTypeGroupOut = MAX(COALESCE(UPPER(dbsSubTmp.dbsSubclientName),RIGHT(UPPER(dbsSubDB.dbsSubclientName),6)))
	FROM 
		[DBServices].[dbo].[dbsDatabase] dbsD
	INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB
		ON dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
		ON dbsSubDB.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	INNER JOIN master.dbo.sysaltfiles sysalt
		ON UPPER(dbsSubDB.dbsDatabaseName) = UPPER(db_name(sysalt.dbid))
	LEFT OUTER JOIN DBServices.dbo.dbsCVSubclient_GroupChecks dbsSubTmp (tablockx)
		ON UPPER(db_name(sysalt.dbid)) = UPPER(dbsSubTmp.dbsDatabaseName) 
	WHERE 
		sysalt.groupid > 0 --Exclude transaction log
		AND sysalt.dbid not in  (2,32767) --Exclude DBServices and resource db
		AND dbsD.dbsDatabaseIsActive = 1 
		AND (dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]' OR dbsSubTmp.dbsSubclientName LIKE '%GROUP[0-9]')
	GROUP BY
		COALESCE(UPPER(dbsSubTmp.dbsSubclientName), RIGHT(UPPER(dbsSubDB.dbsSubclientName),6))
	ORDER BY
		SUM(sysalt.size) ASC

	INSERT INTO DBServices.dbo.dbsCVSubclient_GroupChecks
	VALUES (@DBName,@dbsConfigTypeGroupOut,getdate())
END

IF 	@dbsSubclientGroupDistributionMode = 1
BEGIN
	--This gets the number of databases per group, by ordering the COUNT ASC we get the group with the least databases.
	SELECT TOP 1
		@dbsConfigTypeGroupOut =  MAX(COALESCE(UPPER(dbsSubTmp.dbsSubclientName), RIGHT(UPPER(dbsSubDB.dbsSubclientName),6)))
	FROM [DBServices].[dbo].[dbsDatabase] dbsD
	INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB
		ON dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbsSubDB
		ON dbsSubDB.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
	LEFT OUTER JOIN DBServices.dbo.dbsCVSubclient_GroupChecks dbsSubTmp (tablockx) 
		ON UPPER(dbsSubDB.dbsDatabaseName) = UPPER(dbsSubTmp.dbsDatabaseName)
	WHERE  
		dbsD.dbsDatabaseIsActive = 1 
		AND (dbsSubDB.dbsSubclientName LIKE '%GROUP[0-9]' OR dbsSubTmp.dbsSubclientName LIKE '%GROUP[0-9]')
	GROUP BY
		COALESCE(UPPER(dbsSubTmp.dbsSubclientName), RIGHT(UPPER(dbsSubDB.dbsSubclientName),6) )
	ORDER BY  
		COUNT(dbsD.dbsDatabaseName) ASC

	INSERT INTO DBServices.dbo.dbsCVSubclient_GroupChecks
	VALUES (@DBName,@dbsConfigTypeGroupOut,getdate())
END

IF 	@dbsSubclientGroupDistributionMode = 2
BEGIN
	--Passed all the validation so simply return the GROUP we the user passed in.
	SELECT @dbsConfigTypeGroupOut = @dbsConfigType

	INSERT INTO DBServices.dbo.dbsCVSubclient_GroupChecks
	VALUES (@DBName,@dbsConfigTypeGroupOut,getdate())
END

IF @dbsConfigTypeGroupOut IS NULL
BEGIN
	PRINT 'UBSMWE: usp_GenerateSubclientGroup: Unexpected Error, no subclient group generated for database ' + @DBName + '!'
	PRINT 'SubclientGroupDistributionMode:' + CAST(@dbsSubclientGroupDistributionMode as char(1))
	PRINT 'Config type:' + @dbsConfigType
	PRINT 'Database '+ @DBName + ' was NOT added to any subclient.'
	SET @dbsFailed = 1
END

Exit_Proc_With_Commit:
COMMIT TRAN
RETURN 0

Exit_Proc:
RETURN 1

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_get_logins]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

-- You need to be aware of the following issues:
--    If the Mirror server is in a different domain to the principal server we may have to change domain names and SID's
--    If a database has a user defined as LocalMachine\UserName, you will need to manually resolve this issue on the mirror
--    We cannot set the default database for each login if it is a Mirrored database because the database needs to be online. Need to test ALTER LOGIN
--    If Principal is CASE INSENSITIVE and Mirror is CASE SENSITIVE, Users will have to enter their passwords in UPPER CASE
--    If Principal is CASE SENSITIVE and Mirror is CASE INSENSITIVE, Users may not be able to login at all depending on the chars they used in their passwords
--    There is a slim chance that the SID used on the Principal server is already used by a different login on the Mirror Server.
--    If we consolidate multiple databases from different Principal servers to a single mirror server, the SID's may not match up on one or more databases. 
--       For SQL Authenticated accounts you can use usp_CHANGE_USERS_LOGIN to remap the SIDS.
--       For Windows Authenticated accounts you would need to run DROP USER in each of those databases and then re-add them using CREATE USER. 
--          Note: Using this method will cause permissions associated with this user to be lost

CREATE PROCEDURE [dbo].[usp_get_logins]
AS

BEGIN TRY

	DECLARE @name                  sysname
	DECLARE @type                  VARCHAR(1)
	DECLARE @hasaccess             INT
	DECLARE @denylogin             INT
	DECLARE @is_disabled           INT
	DECLARE @PWD_varbinary         VARBINARY(256)
	DECLARE @PWD_string            VARCHAR(514)
	DECLARE @SID_varbinary         VARBINARY(85)
	DECLARE @SID_string            VARCHAR(514)
	DECLARE @tmpstr                VARCHAR(8000)
	DECLARE @is_policy_checked     VARCHAR(3)
	DECLARE @is_expiration_checked VARCHAR(3)
	DECLARE @defaultdb             sysname
	DECLARE @MachineName           NVARCHAR(128)
	DECLARE @RoleServerRole        NVARCHAR(32)
	DECLARE @permission_name       NVARCHAR(128)
	DECLARE @state                 CHAR(1)

	-- Get the Machine Name. On a cluster this will return the Virtual Name
	-- We need to exclude any local user accounts
	SELECT @MachineName = CONVERT(NVARCHAR(128),SERVERPROPERTY('MachineName'))

	-- Declare cursor to fetch all logins except sa
	DECLARE    login_curs 
	CURSOR FOR
	SELECT     p.sid, 
	           p.name, 
	           p.type, 
	           p.is_disabled, 
	           p.default_database_name, 
	           l.hasaccess, 
	           l.denylogin 
	FROM       sys.server_principals p 
	LEFT JOIN  sys.syslogins l ON ( l.name = p.name ) 
	WHERE      p.type        IN ( 'S', 'G', 'U' ) 
	AND        p.name        <> 'sa'
	AND        p.name        NOT LIKE @MachineName + '\%'
	AND        UPPER(p.name) NOT LIKE 'NT SERVICE\%'
	AND        p.name        NOT LIKE '##%'

	-- Open the cursor and fetch each login
	OPEN login_curs

	FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @type, @is_disabled, @defaultdb, @hasaccess, @denylogin

	IF (@@fetch_status = -1)
	BEGIN
		-- Check for zero logins fetched
		PRINT 'No Data Found'
		CLOSE login_curs
		DEALLOCATE login_curs
		RETURN 0
   END
   
	WHILE (@@fetch_status <> -1)
	BEGIN
		IF (@@fetch_status <> -2)
		BEGIN
			IF (@type IN ( 'G', 'U'))
			BEGIN 
				-- NT authenticated account/group
				SET @tmpstr = 'IF NOT EXISTS (SELECT * FROM sys.server_principals WHERE NAME = ''' + @name + ''')' + CHAR(13) + CHAR(10) + 'BEGIN' + CHAR(13) + CHAR(10)
				SET @tmpstr = @tmpstr + '   CREATE LOGIN ' + QUOTENAME( @name ) + ' FROM WINDOWS ' + CHAR(13) + CHAR(10)
				SET @tmpstr = @tmpstr + 'END' + CHAR(13) + CHAR(10)

				-- Need to check if the default database is Database Mirrored or log shipping
				IF NOT EXISTS (SELECT 1 FROM sys.database_mirroring WHERE mirroring_partner_name IS NOT NULL AND database_id = DB_ID(@defaultdb)
							   UNION
							   SELECT 1 FROM msdb.dbo.log_shipping_primary_databases WHERE primary_database = @defaultdb
							   UNION
							   SELECT 1 FROM  sys.dm_hadr_database_replica_states WHERE database_id = DB_ID(@defaultdb))
					SET @tmpstr = @tmpstr + 'ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH DEFAULT_DATABASE = [' + @defaultdb + ']'
				ELSE
					SET @tmpstr = @tmpstr + 'ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH DEFAULT_DATABASE = [tempdb]'

			END
			ELSE 
			BEGIN 
				-- SQL Server authentication, obtain password and sid
				SET @PWD_varbinary = CAST( LOGINPROPERTY( @name, 'PasswordHash' ) AS VARBINARY(256) )
				EXEC usp_hexadecimal @PWD_varbinary, @PWD_string OUT
				EXEC usp_hexadecimal @SID_varbinary, @SID_string OUT
 
				-- Obtain password policy state
				SELECT @is_policy_checked = CASE is_policy_checked 
											   WHEN 1 THEN 'ON' 
											   WHEN 0 THEN 'OFF' 
											   ELSE NULL 
											END 
				FROM   sys.sql_logins 
				WHERE  name = @name

				-- Obtain password expiration state
				SELECT @is_expiration_checked = CASE is_expiration_checked 
												   WHEN 1 THEN 'ON' 
												   WHEN 0 THEN 'OFF' 
												   ELSE NULL 
												END 
				FROM   sys.sql_logins 
				WHERE  name = @name
 
				-- Build CREATE LOGIN statement for SQL Authenticated login
				SET @tmpstr = 'IF NOT EXISTS (SELECT * FROM sys.server_principals WHERE NAME = ''' + @name + ''')' + CHAR(13) + CHAR(10) + 'BEGIN' + CHAR(13) + CHAR(10)
				SET @tmpstr = @tmpstr + '   IF EXISTS (SELECT * FROM sys.server_principals WHERE SID = ' + @SID_string + ')' + CHAR(13) + CHAR(10) + '   BEGIN' + CHAR(13) + CHAR(10)
				SET @tmpstr = @tmpstr + '      DECLARE @cmd NVARCHAR(1000)' + CHAR(13) + CHAR(10)
				SET @tmpstr = @tmpstr + '      SET @cmd = ''DROP LOGIN [''+SUSER_SNAME(' + @SID_string + ')+'']''' + CHAR(13) + CHAR(10) 
				SET @tmpstr = @tmpstr + '      EXEC(@cmd)' + CHAR(13) + CHAR(10) + '   END' + CHAR(13) + CHAR(10)
				SET @tmpstr = @tmpstr + '   CREATE LOGIN ' + QUOTENAME( @name ) + ' WITH PASSWORD = ' + @PWD_string + ' HASHED,' + CHAR(13) + CHAR(10) + SPACE(16) + 'SID = ' + @SID_string

				IF ( @is_policy_checked IS NOT NULL )
				BEGIN
					SET @tmpstr = @tmpstr + ', CHECK_POLICY = ' + @is_policy_checked
				END

				IF ( @is_expiration_checked IS NOT NULL )
				BEGIN
					SET @tmpstr = @tmpstr + ', CHECK_EXPIRATION = ' + @is_expiration_checked
				END

				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'END'

				-- Always alter the logins password in case it was changed on the source
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'IF EXISTS (SELECT * FROM sys.sql_logins WHERE name = ''' + @name + ''' AND is_policy_checked = 1)'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'BEGIN'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + '   ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH CHECK_POLICY = OFF'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + '   ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH PASSWORD = '+ @PWD_string + ' HASHED'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + '   ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH CHECK_POLICY = ON'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'END'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'ELSE'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'BEGIN'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + '   ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH PASSWORD = '+ @PWD_string + ' HASHED'
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'END'			

				IF NOT EXISTS (SELECT 1 FROM sys.database_mirroring WHERE mirroring_partner_name IS NOT NULL AND database_id = DB_ID(@defaultdb)
							   UNION
							   SELECT 1 FROM msdb.dbo.log_shipping_primary_databases WHERE primary_database = @defaultdb
							   UNION
							   SELECT 1 FROM  sys.dm_hadr_database_replica_states WHERE database_id = DB_ID(@defaultdb))
					SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH DEFAULT_DATABASE = [' + @defaultdb + ']'
				ELSE
					SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'ALTER LOGIN ' + QUOTENAME( @name ) + ' WITH DEFAULT_DATABASE = [tempdb]'
			END

			IF (@denylogin = 1)
			BEGIN 
				-- Check if login is denied access
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'DENY CONNECT SQL TO ' + QUOTENAME( @name )
			END
			ELSE 
				IF (@hasaccess = 0)
				BEGIN 
					-- login exists but does not have access
					SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'REVOKE CONNECT SQL TO ' + QUOTENAME( @name )
				END

			IF (@is_disabled = 1)
			BEGIN 
				-- login is disabled
				SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'ALTER LOGIN ' + QUOTENAME( @name ) + ' DISABLE'
			END

			-- Get any System Roles
			DECLARE    roles_cur
			CURSOR FOR
				SELECT sp2.name
				FROM   sys.server_principals sp1
				JOIN   sys.server_role_members srm ON sp1.principal_id      = srm.member_principal_id
				JOIN   sys.server_principals sp2   ON srm.role_principal_id = sp2.principal_id
				WHERE  sp1.name = @name
			OPEN roles_cur

			FETCH NEXT FROM roles_cur INTO @RoleServerRole
			IF (@@fetch_status = -1)
			BEGIN
				CLOSE roles_cur
				DEALLOCATE roles_cur
			END
			ELSE
			BEGIN
				WHILE (@@fetch_status <> -1)
				BEGIN
					IF (@@fetch_status <> -2)
					BEGIN
						SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'EXEC sp_addsrvrolemember N''' + @name + ''', N''' + @RoleServerRole + ''''
					END
					FETCH NEXT FROM roles_cur INTO @RoleServerRole
				END
				CLOSE roles_cur
				DEALLOCATE roles_cur
			END

			-- Get any Server Permissions
			DECLARE perms_cur
			CURSOR FOR
				SELECT B.state, B.permission_name
				FROM   sys.server_principals AS A
				JOIN   sys.server_permissions AS B ON (A.principal_id = B.grantee_principal_id)
				WHERE  A.name             = @name
				AND    B.permission_name != 'CONNECT SQL'
			OPEN perms_cur

			FETCH NEXT FROM perms_cur INTO @state, @permission_name
			IF (@@fetch_status = -1)
			BEGIN
				CLOSE perms_cur
				DEALLOCATE perms_cur
			END
			ELSE
			BEGIN
				WHILE (@@fetch_status <> -1)
				BEGIN
					IF (@@fetch_status <> -2)
					BEGIN
						IF (@state = 'D')
							SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'DENY ' + @permission_name + ' TO ' + QUOTENAME( @name )

						IF (@state = 'G')
							SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'GRANT ' + @permission_name + ' TO ' + QUOTENAME( @name )

						IF (@state = 'W')
							SET @tmpstr = @tmpstr + CHAR(13) + CHAR(10) + 'GRANT ' + @permission_name + ' TO ' + QUOTENAME( @name ) + ' WITH GRANT OPTION '
					END
					FETCH NEXT FROM perms_cur INTO @state, @permission_name
				END
				CLOSE perms_cur
				DEALLOCATE perms_cur
			END

			-- Print out the complete SQL to create the login

			PRINT @tmpstr
			PRINT '--END_OF_CREATE'
		END

		-- Get the next login 
		FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @type, @is_disabled, @defaultdb, @hasaccess, @denylogin

	END

	-- Tidyup
	CLOSE login_curs
	DEALLOCATE login_curs

	RETURN 0

END TRY
 
BEGIN CATCH

	PRINT 'Msg: '        + CONVERT(NVARCHAR,ERROR_NUMBER())   +
		  ', Severity: ' + CONVERT(NVARCHAR,ERROR_SEVERITY()) +
		  ', State: '    + CONVERT(NVARCHAR,ERROR_STATE())    +
		  ', Proc: '     + ERROR_PROCEDURE()                  +
		  ', Line: '     + CONVERT(NVARCHAR,ERROR_LINE())     +
		  ', Error: '    + ERROR_MESSAGE()

	RETURN ERROR_NUMBER()

END CATCH

GO
/****** Object:  StoredProcedure [dbo].[usp_GetdbsInstanceConfig]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_GetdbsInstanceConfig] 
						@dbsInstanceConfigName nvarchar(255)
						,@dbsInstanceConfigValue nvarchar(255) OUTPUT
						,@quiet bit = 0
AS

/****************************************************************************************
// @File: usp_GetdbsInstanceConfig.SQL
// @Version 6.0.0.29
// 
// Purpose:
//  Update dbsInstanceConfig table with given value
//  Returns 0 for success, 1 for failure
//
// History: Dates are in mm/dd/yyyy format
//
//	 @Date: 10/05/2004 @Author: Kevin Wagner @Version: UBSMWE 1.0.1 @Action: Created.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 29/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 25/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.4 @Action: TRRv3 Beta
//   @Date: 09/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.29 @Action: Minor CS update
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @debug int
	,@ErrorText as varchar(255)
	,@RC tinyint -- workaround

SELECT @debug = CONVERT(int, dbsInstanceConfigValue) 
FROM dbsInstanceConfig
WHERE UPPER(dbsInstanceConfigName) = 'DEBUG'

SET @dbsInstanceConfigName = LTRIM(RTRIM(@dbsInstanceConfigName))

IF EXISTS ( SELECT 1 
			FROM [DBServices].[dbo].dbsInstanceConfig
			WHERE UPPER(dbsInstanceConfigName) = UPPER(@dbsInstanceConfigName))
BEGIN	-- Search for param
	SELECT 	@dbsInstanceConfigValue = LTRIM(RTRIM(dbsInstanceConfigValue))
	FROM	[DBServices].[dbo].dbsInstanceConfig 
	WHERE	UPPER(dbsInstanceConfigName) = UPPER(@dbsInstanceConfigName)

	SET @RC = 0
END
ELSE
BEGIN
	SET @dbsInstanceConfigValue = NULL

	IF @quiet = 0
	BEGIN
		SET @ErrorText = 'UBSMWE: usp_GetdbsInstanceConfig: dbsInstanceConfig configuration entry missing: ' 
				+ @dbsInstanceConfigName + ' - toolkit may be incorrectly installed'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 1	-- raise an info alert
	END

	SET @RC = 1
END

IF @quiet = 0 
	AND @debug >= 1 --Only print info if in debug mode
	PRINT '@dbsInstanceConfigName : ' +  @dbsInstanceConfigName 
		+ ', @dbsInstanceConfigValue : ' + @dbsInstanceConfigValue 

RETURN @RC

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_GetJobState]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO



CREATE PROCEDURE [dbo].[usp_GetJobState] @dbsJobName  nvarchar(255)--, @JobState INT OUTPUT

AS
SET DATEFORMAT ymd
SET NOCOUNT ON
/****************************************************************************************
// @File: usp_GetJobState.SQL
// 
// Purpose:
//   Return running state of a job
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History:
//
//   
//   
//   @Date: 11/09/2004 @Author: Kevin Wagner @Version: 1.5.2 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 3/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Changed implimentation to use more reliable source for Job State information.
																		--Placing offical request to Microsoft to provide reliable interface for Job State information in a system function.
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/


BEGIN
	
	
	DECLARE @jobid 		uniqueidentifier
		,@is_sysadmin	INT
		,@job_owner	sysname
		,@job_id	uniqueidentifier
		,@JobState	INT
		,@StepID	INT
		,@RunStatus	INT
	
	  CREATE TABLE #xp_results  (job_id                UNIQUEIDENTIFIER NOT NULL,
                            last_run_date         INT              NOT NULL,
                            last_run_time         INT              NOT NULL,
                            next_run_date         INT              NOT NULL,
                            next_run_time         INT              NOT NULL,
                            next_run_schedule_id  INT              NOT NULL,
                            requested_to_run      INT              NOT NULL, -- BOOL
                            request_source        INT              NOT NULL,
                            request_source_id     sysname          COLLATE database_default NULL,
                            running               INT              NOT NULL, -- BOOL
                            current_step          INT              NOT NULL,
                            current_retry_attempt INT              NOT NULL,
                            job_state             INT              NOT NULL)


	SELECT @jobid = job_id     
	FROM   msdb.dbo.sysjobs    
	WHERE name = @dbsJobName 

	IF ((@@microsoftversion / 0x01000000) >= 8) -- SQL Server 8.0 or greater
		INSERT INTO #xp_results
		EXECUTE master.dbo.xp_sqlagent_enum_jobs 1, '', @jobid
  ELSE
	PRINT 'Wrong SQL Version, Must be MSSQL 2000 or greater.'

	IF EXISTS (SELECT * FROM #xp_results WHERE job_id = @jobid )
		BEGIN
			SELECT @JobState = job_state FROM #xp_results WHERE job_id = @jobid
		END
	ELSE
		BEGIN
			SELECT @JobState = -1 --Job not found
		END

RETURN @JobState

END



GO
/****** Object:  StoredProcedure [dbo].[usp_GetLogfilename]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_GetLogfilename] (
		@WFTaskname varchar(128),
		@FileName   varchar(200) OUTPUT
		)
AS

/************************************************************************************************
Name: 		usp_GetLogfilename.SQL
Purpose:	Get filename for  scheduled jobs for a task for output log
              
Modification History:
Version  Name                Date        Notes
1.0      Rakesh Bist   	    14/02/2006   Original version
					 Add to the DBServices UBSMWE (1.5.3)
2.0	 Rakesh Bist	    20/04/2006	 Added support for SQL Server 2005,code changes 
					 to replace with system view for DB file location.
					 Check that batch output log folder exists.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 28/01/2009 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Update to allow for running on MSSQL 2000 (Dont use sys.objects)
//   @Date: 27/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta 
//   @Date: 29/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta 
************************************************************************************************/
BEGIN -- main

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE 
		@RC int
		,@LogPath nvarchar(255)
		,@exists bit
		,@dbsInstanceFileLocation nvarchar(255)
		,@Cmd nvarchar(255)
		,@ErrorMsg nvarchar(255)
		,@dbsJobLogPathOverride nvarchar(128)

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT
EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsJobLogPathOverride', @dbsJobLogPathOverride OUTPUT

IF ISNULL(@dbsJobLogPathOverride,'') = '' 
BEGIN
	IF RIGHT(@dbsInstanceFileLocation,1) <> '\'
		SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

	-- Default: Job Log files are kept under instance name folder JobLogs
	SET @LogPath = @dbsInstanceFileLocation + 'JobLogs'
END
ELSE
BEGIN
	-- Option to override the default path detected
	IF RIGHT(@dbsJobLogPathOverride,1) = '\'
		SET @dbsJobLogPathOverride = LEFT (@dbsJobLogPathOverride, LEN(@dbsJobLogPathOverride) -1)

	SET @LogPath = @dbsJobLogPathOverride
END

IF @LogPath IS NOT NULL
	SET @FileName = @LogPath + '\' + REPLACE(@WFTaskname, ' ','_') + '.log'	
ELSE
BEGIN ------
	SET @FileName = ''	-- Return empty file
	RETURN (0)
END

IF LEN(@FileName) > 200
BEGIN -- Failed
	SET @ErrorMsg = 'UBSMWE: usp_GetLogfilename: ERROR: '
		+ 'The length of the file path: ' + @FileName 
		+ ' is ' + CAST (LEN(@FileName) as varchar(3))
		+ ' chars - MSSQL log limit is 200 chars. Investigation required (option; use dbsJobLogPathOverride)'
	
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	RETURN (1)
END

-- Verify the log folder exists	
EXEC [DBServices].[dbo].[usp_FileExists] @LogPath, @exists OUTPUT

IF @exists = 0
BEGIN
	SET @Cmd = 'mkdir ' + @LogPath  
   	EXEC @RC = master..xp_cmdshell @Cmd, NO_OUTPUT

	IF @RC <> 0
	BEGIN -- Failed
		SET @ErrorMsg = 'UBSMWE: usp_GetLogfilename: ERROR: Creation of the Job log folder: '
			 + @LogPath + ' failed'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
		RETURN (1)
	END
END

-- Success
RETURN (0)

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_GetSystemBackupInformation]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_GetSystemBackupInformation]
					@dbsDatabaseName nvarchar(128)
					,@BackupType char(1)
AS

/****************************************************************************************
// @File: usp_GetSystemBackupInformation.SQL
// @Version: 6.0.0.12
// Purpose:
//	System sp: Updates dbsDatabaseBackupHistory table for a given DB (not backed up by UBSMWE) from the msdb DB
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: 1.5.2 @Action: Created
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated to detect if we have entered in a Full database backup and then return a 1 else a 0 if not.
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Updated for MSSQLCentral Integration
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 05/06/2009 @Author: Kevin Wagner @Version: UBSMWE 3.0   @Action: Updated for issue with bringing in old outdated information from the msdb tables. Now based on max date for the database and backup type.
//   @Date: 05/06/2009 @Author: Steve Trogub @Version: UBSMWE 5.0.3 @Action: Bug fix - Detecting external backups when no entries for the database being backed up are present in dbsDatabaseHistory table
//   @Date: 12/02/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9 @Action: minor fix - Added maxdop hint
//   @Date: 10/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta tidy up
//   @Date: 19/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.12 @Action: TRRv3 RC1
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd

DECLARE @RC int
		,@dbsDBHParentID bigint
		,@EnddbsDBHParentID bigint
		,@BeginIDFULL bigint
		,@EndIDFULL  bigint
		,@BeginID bigint
		,@EndID  bigint
		,@dbsDBHID bigint
		,@dbsDatabaseUID char(36)
		,@dbsDBHIsLogFlag char(1)
		,@dbsDBHStartDate varchar(50)
		,@dbsDBHEndDate varchar(50)
		,@dbsDBHFileName nvarchar(255)
		,@dbsDBHIsOnDiskFlag char(1)
		,@dbsDBackupProcessorID varchar(2)
		,@dbsDBHActiveComputerName nvarchar(128)
		,@dbsDBHSentToNBFlag char(1)
		,@exists bit
		,@StartDate datetime
		,@BeginDate datetime
		,@BackupType_int int
		,@isLS nchar(1) 
		,@dbsBackupProcessor tinyint

---------------------------------------------------
-- Init 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT

---------------------------------------------------
-- Checks 

IF ISNULL(@dbsDatabaseName,'') = ''
BEGIN
	PRINT 'UBSMWE: usp_GetSystemBackupInformation: ERROR: Empty string passed for DB name, backup type: ' 
		+ @BackupType + ' skipping'
	RETURN 0 -- Call error - ignore DB
END

-- Check for FS exception
IF EXISTS (SELECT 1
	FROM DBServices.dbo.dbsDatabase db
	INNER JOIN DBServices.dbo.dbsDatabaseException dbe
		ON dbe.dbsDatabaseUID = db.dbsDatabaseUID
	WHERE db.dbsDatabaseName = @dbsDatabaseName
		AND db.dbsDatabaseIsActive = 1
		AND dbe.dbsDatabaseExceptionType = 'filesystem'
		AND dbe.dbsExceptionActive = 1)
BEGIN
	PRINT 'File System Backup exception exists for DB: ' + @dbsDatabaseName + ' - skipping'
	RETURN 0 -- FS exception exists - skip
END

--------------------------

-- LS Check: 
EXEC DBServices.dbo.usp_isLogshipped @dbsDatabaseName, @isLS OUTPUT

IF @isLS = 'S'	-- Secondary node 
	OR (@dbsBackupProcessor = 5 AND @isLS <> 'P') -- CV Scheduled backups, not logshipped
	RETURN 0 -- skip

--------------------------
-- Get the last Full database backup ID from the history table. 
-- Need to see if we have actually received a valid full db backup 
-- to kick off the Netbackup integration.

SELECT @BeginID = MAX(dbsDBH.dbsDBHID)
FROM DBServices.dbo.dbsDatabaseBackupHistory dbsDBH
INNER JOIN DBServices.dbo.dbsDatabase dbsD
	ON dbsD.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
WHERE dbsD.dbsDatabaseName = @dbsDatabaseName
	AND dbsD.dbsDatabaseIsActive = 1

IF @BackupType = 'L'
BEGIN
	SELECT @BeginIDFULL = MAX(dbsDBH.dbsDBHID)
	FROM DBServices.dbo.dbsDatabaseBackupHistory dbsDBH
	INNER JOIN DBServices.dbo.dbsDatabase dbsD
		ON dbsD.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
	WHERE dbsD.dbsDatabaseName = @dbsDatabaseName
		AND dbsD.dbsDatabaseIsActive = 1
		AND dbsDBH.dbsDBHIsLogFlag = 0 

	SET @dbsDBHParentID = @BeginIDFULL
	SET @BackupType_int = 1
END
ELSE
BEGIN
	SET @dbsDBHParentID = NULL
	SET @BackupType_int = 0
END

IF @BeginID IS NOT NULL
BEGIN
	SELECT @BeginDate = dbsDBHStartDate
	FROM DBServices.dbo.dbsDatabaseBackupHistory
	WHERE @BeginID = dbsDBHID
END

---------------------------------------------------
-- Get msdb data

--@StartDate = Only try to get info from the system tables for those dates still in the DBServices database.
SELECT @StartDate = ISNULL(MAX(dbsDBHStartDate),DATEADD(HH, -23, GETDATE()))
FROM DBServices.dbo.dbsDatabaseBackupHistory dbsDBH
INNER JOIN DBServices.dbo.dbsDatabase dbsD 
	ON dbsD.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
WHERE dbsD.dbsDatabaseName = @dbsDatabaseName
	AND	dbsD.dbsDatabaseIsActive = 1
	AND dbsDBH.dbsDBHIsLogFlag = @BackupType_int

--------------------------

INSERT INTO [DBServices].[dbo].[dbsDatabaseBackupHistory](
		[dbsDatabaseUID], 
		[dbsDBHIsLogFlag], 
		[dbsDBHStartDate], 
		[dbsDBHEndDate], 
		[dbsDBHFileName], 
		[dbsDBHIsOnDiskFlag], 
		[dbsDBackupProcessorID], 
		[dbsDBHParentID], 
		[dbsDBHActiveComputerName])
SELECT  dbsD.dbsDatabaseUID as 'dbsDatabaseUID', 
		CASE
			WHEN backupset.type = 'D' THEN 0
			WHEN backupset.type = 'L' THEN 1
		END as 'dbsDBHIsLogFlag',
		backupset.backup_start_date as 'dbsDBHStartDate', 
		backupset.backup_finish_date as 'dbsDBHEndDate',
		backupmediafamily.physical_device_name as 'dbsDBHFileName', 
		1 as 'dbsDBHIsOnDiskFlag',
		1 as 'dbsDBackupProcessorID',
		@dbsDBHParentID, 
		backupset.machine_name

FROM DBServices.dbo.dbsDatabase dbsD 
INNER JOIN msdb.dbo.backupset backupset WITH (NOLOCK)
	ON backupset.database_name = dbsD.dbsDatabaseName
INNER JOIN msdb.dbo.backupmediaset backupmediaset WITH (NOLOCK)
	ON backupmediaset.media_set_id = backupset.media_set_id 
INNER JOIN msdb.dbo.backupmediafamily backupmediafamily WITH (NOLOCK)
	ON backupmediafamily.media_set_id = backupmediaset.media_set_id 
LEFT OUTER JOIN DBServices.dbo.dbsDatabaseBackupHistory dbsDBH
	ON dbsDBH.dbsDBHFileName = backupmediafamily.physical_device_name 

WHERE dbsD.dbsDatabaseName = @dbsDatabaseName
	AND	dbsD.dbsDatabaseIsActive = 1
	AND backupset.type = @BackupType
	AND backupset.backup_start_date > @StartDate
	AND backupmediafamily.physical_device_name NOT LIKE 'VDI_%' --exclude VDI names from result set as virtual devices not physical files.	
	AND dbsDBH.dbsDatabaseUID IS NULL	-- does not exist

ORDER BY backupset.backup_start_date
OPTION (MAXDOP 1)

-- ST: Excluded the following due to Duplicate files when a db has more than one logical file name.	
--	INNER JOIN msdb.dbo.backupfile backupfile 
--	ON backupset.backup_set_id = backupfile.backup_set_id 

SET @EndID = NULL

SELECT @EndID = MAX(dbsDBH.dbsDBHID)
FROM DBServices.dbo.dbsDatabaseBackupHistory dbsDBH
INNER JOIN DBServices.dbo.dbsDatabase dbsD
	ON dbsD.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
WHERE dbsD.dbsDatabaseName = @dbsDatabaseName
	AND	dbsD.dbsDatabaseIsActive = 1
	AND dbsDBH.dbsDBHIsOnDiskFlag = 1
	AND	dbsDBH.dbsDBHSentToNBFlag = 0

---------------------------------------------------
-- Update [dbsDatabaseBackupHistory] with msdb data

DECLARE cur_dbsDatabaseBackup CURSOR READ_ONLY FORWARD_ONLY 
FOR SELECT [dbsDatabaseUID], 
			[dbsDBHIsLogFlag], 
			[dbsDBHStartDate], 
			[dbsDBHEndDate], 
			[dbsDBHFileName], 
			[dbsDBHIsOnDiskFlag], 
			[dbsDBackupProcessorID], 
			[dbsDBHParentID], 
			[dbsDBHActiveComputerName],
			[dbsDBHSentToNBFlag]
FROM [DBServices].[dbo].[dbsDatabaseBackupHistory]
WHERE dbsDBHID > @BeginID 
	AND dbsDBHID <= @EndID

OPEN cur_dbsDatabaseBackup

FETCH NEXT FROM cur_dbsDatabaseBackup INTO @dbsDatabaseUID, 
			@dbsDBHIsLogFlag, 
			@dbsDBHStartDate, 
			@dbsDBHEndDate, 
			@dbsDBHFileName, 
			@dbsDBHIsOnDiskFlag, 
			@dbsDBackupProcessorID, 
			@dbsDBHParentID, 
			@dbsDBHActiveComputerName,
			@dbsDBHSentToNBFlag
	  
WHILE (@@fetch_status <> -1)
BEGIN
	IF (@@fetch_status <> -2)
	BEGIN
		EXEC @RC = [DBServices].[dbo].[msc_UpdatedbsDatabaseBackupHistory] 
					   @dbsDBHID
					  ,@dbsDatabaseUID
					  ,@dbsDBHIsLogFlag
					  ,@dbsDBHStartDate
					  ,@dbsDBHEndDate
					  ,@dbsDBHFileName
					  ,@dbsDBHIsOnDiskFlag
					  ,@dbsDBackupProcessorID
					  ,@dbsDBHParentID
					  ,@dbsDBHActiveComputerName
					  ,@dbsDBHSentToNBFlag

		IF @RC <> 0
			PRINT 'UBSMWE: usp_GetSystemBackupInformation: Unhandled Exception for DB: '
				+ @dbsDatabaseName + ' backup type: ' + @BackupType
	END

	FETCH NEXT FROM cur_dbsDatabaseBackup INTO @dbsDatabaseUID, 
			@dbsDBHIsLogFlag, 
			@dbsDBHStartDate, 
			@dbsDBHEndDate, 
			@dbsDBHFileName, 
			@dbsDBHIsOnDiskFlag, 
			@dbsDBackupProcessorID, 
			@dbsDBHParentID, 
			@dbsDBHActiveComputerName,
			@dbsDBHSentToNBFlag

END --While cur_dbsDatabaseBackup

CLOSE cur_dbsDatabaseBackup
DEALLOCATE cur_dbsDatabaseBackup

---------------------------------------------------

IF @BackupType = 'L' -- TLog backup, just return 0 since we do not kick off the Netbackup from a Tlog run	
	RETURN 0
ELSE 	
BEGIN -- Full database run - check to see if we have a new entry in the list for this database

	SET @EndIDFULL = NULL

	SELECT @EndID = MAX(dbsDBH.dbsDBHID)
	FROM DBServices.dbo.dbsDatabase dbsD
	INNER JOIN DBServices.dbo.dbsDatabaseBackupHistory dbsDBH
		ON dbsDBH.dbsDatabaseUID =  dbsD.dbsDatabaseUID
	WHERE dbsD.dbsDatabaseName = @dbsDatabaseName
		AND	dbsD.dbsDatabaseIsActive = 1
		AND dbsDBH.dbsDBHIsLogFlag = 0
		AND dbsDBH.dbsDBHIsOnDiskFlag = 1
		AND	dbsDBH.dbsDBHSentToNBFlag = 0

	SET @RC = CASE
		WHEN @BeginIDFULL IS NULL AND @EndIDFULL IS NULL THEN 0 	-- a new backup entry in the list for given DB
		WHEN @BeginIDFULL IS NOT NULL AND @EndIDFULL IS NULL THEN 0 -- to check if we have a NEW Full backup
		WHEN @BeginIDFULL = @EndIDFULL THEN 0 -- existing entry
		WHEN @BeginIDFULL IS NOT NULL AND @EndIDFULL IS NOT NULL AND @BeginID < @EndID THEN 1
		ELSE -1 -- unknown external backup condition 
	END

	IF @RC = -1
		PRINT 'UBSMWE: usp_GetSystemBackupInformation: Unhandled Exception for DB: '
			+ @dbsDatabaseName + ' backup type: ' + @BackupType 
			+ ' - unknown external backup condition'
	
	RETURN @RC
END

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_GetWorkFlowSubTaskJobState]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_GetWorkFlowSubTaskJobState] @dbsDatabaseUID uniqueidentifier, @WFTaskName_self nvarchar(255)
AS

/****************************************************************************************
// @File: usp_GetWorkFlowSubTaskJobState.SQL
// 
// Purpose:
//   Used in the execution path of a WFST, this will delay execution until we have no 
//			running sub task and will also clear bad running flags.
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History:
//
//   @Date: 3/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//   @Date: 10/11/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Re-write of old code: Log backups were not running during the Sunday workflow
//
****************************************************************************************/

BEGIN
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7

DECLARE @WFTaskName nvarchar(255)
	,@RC int

SET @RC = 1

------------------------------------

WHILE @RC <> 0
BEGIN
	-- Wait for WFTask dependancies
	SELECT TOP 1 @WFTaskName = WFTaskName
	FROM DBServices.dbo.WorkFlowTask wft
	WHERE wft.dbsDatabaseUID = @dbsDatabaseUID
		AND wft.WFTaskIsRunningFlag = 1
		AND wft.WFTaskName <> @WFTaskName_self
		AND wft.WFTaskTypeID IN
			(SELECT DISTINCT WFTaskTypeID_Dependancy
			FROM DBServices.dbo.WorkFlowTaskDependancies
			WHERE WFTaskTypeID = 
				(SELECT TOP 1 WFTaskTypeID
				FROM DBServices.dbo.WorkFlowTask
				WHERE dbsDatabaseUID = @dbsDatabaseUID
					AND WFTaskName = @WFTaskName_self
				)
			)

	IF ISNULL(@WFTaskName, '') = ''
		RETURN 0
	ELSE
	BEGIN
		EXEC @RC = DBServices.dbo.usp_GetJobState @WFTaskName

		IF @RC = -1
			OR @RC = 4 --Clear the running flag if we dont have the job or the job is idle
		BEGIN
			UPDATE DBServices.dbo.WorkFlowTask
			SET WFTaskIsRunningFlag = 0
			WHERE dbsDatabaseUID = @dbsDatabaseUID
				AND WFTaskName = @WFTaskName

			RETURN 0
		END ------------------

		SET @RC = 1
		WAITFOR DELAY '00:00:15'
	END ------------------
END

END

GO
/****** Object:  StoredProcedure [dbo].[usp_HealthChk]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_HealthChk]
AS

/********************************************
// @File: usp_HealthChk.SQL
// 
// Purpose:
//   For troubleshooting; produces a health check report for the instance 
//
// Notes: This sp is for DBA use and only executed manually 
//
// History: Dates are in mm/dd/yyyy format
//
//	 @Date: 10/07/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 Beta 
//	 @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta 
//	 @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta 
//	 @Date: 24/11/2014 @Author: Chris Basson @Version: 6.0.0.13 @Action: TRRv3 Beta 
//	 @Date: 09/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta 
//	 @Date: 12/01/2015 @Author: Chris Basson @Version: 6.0.0.20 @Action: TRRv3 
//	 @Date: 21/01/2015 @Author: Chris Basson @Version: 6.0.0.21 @Action: minor bugfix
//	 @Date: 27/01/2015 @Author: Chris Basson @Version: 6.0.0.22 @Action: TRR-120 minor bugfix
//	 @Date: 10/02/2015 @Author: Chris Basson @Version: 6.0.0.24 @Action: Feature request: add DB backup monitoring for CV TRRv3 
//	 @Date: 12/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Added Port info
//	 @Date: 10/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Added CV BRAT, Client ver info + DisableAdv param
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//	 @Date: 07/07/2015 @Author: Chris Basson @Version: 6.0.0.35 @Action: Minor: Added CVFQDNCommCell, MWE ver info 
//   @Date: 26/08/2015 @Author: Chris Basson @Version: 6.0.0.37 @Action: SysInfo, DBInfo Added + check (CV_DBname_Mismatch) for TRR-138
//   @Date: 12/10/2015 @Author: Chris Basson @Version: 6.0.0.39 @Action: Added AO AG, Mirror, Logshipping and Replication info
//   @Date: 13/11/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Minor refinement
********************************************/

BEGIN --main

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
	,@CR char(2)
	,@delimiter char(1)
	,@OffsiteFileBkType varchar(15)
	,@MajorVersion tinyint
	,@JobFailure_ConcernDays tinyint
	,@now smalldatetime
	,@portNo varchar(15) 
	,@sqlstr as nvarchar (4000)
	,@dbsInstanceFileLocation as varchar(255)
	,@dbsBackupProcessor as char(1)
	,@CV_Clientver varchar(15)
	,@CV_BRATver varchar(15)
	,@dbsVersion varchar(15)
	,@CVFQDNCommCell varchar(100)
	,@DisableAdv bit
	,@HostName sysname
	,@i smallint
	,@permdef nvarchar(100)

IF OBJECT_ID('tempdb..#Audit') IS NOT NULL 
	DROP TABLE #Audit

CREATE TABLE #Audit (
	InstanceName varchar(60)
	,TestType varchar(20)
	,DBName varchar(128)
	,[Status] varchar(40)
	,TestOutput varchar(512)
	,ViewOrder smallint
	,TestDateRun smalldatetime)

-----------------
-- Init 

SET @HostName = CONVERT(sysname, SERVERPROPERTY('ServerName'))
SET @CR = CHAR(13) + CHAR(10) -- Carridge return
SET @delimiter = CHAR(9)
SET @MajorVersion = DBServices.dbo.ufn_InstanceMajorVersion()

SET @JobFailure_ConcernDays  = 7
SET @now = getdate()

----------------------------------------------------------------------	
--Server Info

-- Port num
BEGIN TRY
	EXEC xp_instance_regread
		@rootkey = 'HKEY_LOCAL_MACHINE'
		,@key ='Software\Microsoft\Microsoft SQL Server\MSSQLServer\SuperSocketNetLib\Tcp\IpAll'
		,@value_name = 'TcpDynamicPorts'
		,@value = @portNo OUTPUT
END TRY

BEGIN CATCH
	SET @RC = 1
END CATCH

IF @portNo IS NOT NULL
	SET @portNo = @portNo + ' (Dynamic)'
ELSE
BEGIN
	BEGIN TRY
		EXEC xp_instance_regread
			@rootkey = 'HKEY_LOCAL_MACHINE'
			,@key ='Software\Microsoft\Microsoft SQL Server\MSSQLServer\SuperSocketNetLib\Tcp\IpAll'
			,@value_name = 'TcpPort'
			,@value = @portNo OUTPUT 
	END TRY

	BEGIN CATCH
		SET @portNo = '*ERROR*'
		SET @RC = 1
	END CATCH

	IF @portNo IS NOT NULL
		SET @portNo = @portNo + ' (Static)'
	ELSE
		SET @portNo = '*ERROR*'
END

-----------------

INSERT INTO #Audit
	SELECT @HostName
		,'Info'
		, '--'
		, '--'
		,CASE 
			WHEN SERVERPROPERTY('IsClustered') = 1
				THEN 'FO clustered - ' +  CAST (SERVERPROPERTY('ComputerNamePhysicalNetBIOS') as varchar(20))
			ELSE 'Standalone'
		  END
		+ @delimiter + LEFT(@@version,CHARINDEX(CHAR(10),@@version)-1)
		+ @delimiter + CAST(SERVERPROPERTY('Edition') as varchar(100)) 
			+ CASE
					WHEN CHARINDEX('(Hypervisor)', @@VERSION) > 1 THEN ' (VirtualMachine)'
					ELSE ''
				END
		+ @delimiter + CAST (SERVERPROPERTY('Collation') as varchar(30))
		+ @delimiter + 'Port: ' + @portNo
		+ @delimiter + 'Security: ' + CASE CAST (SERVERPROPERTY('IsIntegratedSecurityOnly') as tinyint)
										WHEN 1 THEN 'Windows Only'
										WHEN 0 THEN 'Mixed'
										ELSE '?'
									END
		+ @delimiter + 'OS_PID: ' + CAST (SERVERPROPERTY('ProcessID') as varchar(15))
		, 1
		, @now

------------------------------------------
-- CPU details

DECLARE
	@WinVersion varchar(40)
	,@CPULogicalCoreCnt smallint
	,@hyperthread_ratio smallint
	--,@CPUModel varchar(5)
	,@CPUName varchar(60)
	--,@PhysicalCPUSockets tinyint

DECLARE @tblStats TABLE (
	[Index] int,
	[Name] varchar(200),
	Internal_Value varchar(50),
	Character_Value varchar(200) )

-------------------
-- Physical CPU details 
SELECT @CPULogicalCoreCnt = ISNULL(cpu_count,1)
		,@hyperthread_ratio = ISNULL(hyperthread_ratio,1)
		--,@PhysicalCPUSockets = ISNULL(cpu_count,1) / ISNULL(hyperthread_ratio,1)
FROM sys.dm_os_sys_info 

-------------------
-- OS CPU details
BEGIN TRY
	EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE',
		N'HARDWARE\DESCRIPTION\System\CentralProcessor\0',
		N'ProcessorNameString',
		@CPUName OUTPUT,
		N'no_output' 
END TRY
BEGIN CATCH
	SET @CPUName = '*ERROR*'
	SET @RC = 1
END CATCH

-------------------
-- OS Details

BEGIN TRY
	INSERT INTO @tblStats
		EXEC master.dbo.xp_msver 'WindowsVersion'
END TRY
BEGIN CATCH
	SET @RC = 1
END CATCH
/*
SELECT @CPUModel = Internal_Value
FROM @tblStats 
WHERE [Index] = 18
*/
SELECT @WinVersion = Character_Value 
FROM @tblStats 
WHERE [Index] = 15

SET @WinVersion = @WinVersion
	+ CASE LTRIM(LEFT(@WinVersion,3))
		WHEN '5.2' THEN ' Windows Server 2003'									
		WHEN '6.0' THEN ' Windows Server 2008'								
		WHEN '6.1' THEN ' Windows Server 2008 R2'		
		WHEN '6.2' THEN ' Windows Server 2012'
		WHEN '6.3' THEN ' Windows Server 2012 R2'
		WHEN '10.0' THEN ' Windows Server 2016'
		ELSE 'Unknown'
		END

-------------------
--Result

INSERT INTO #Audit
	SELECT @HostName
		,'Info'
		, '--'
		, '--'
		, 'OSVer: ' + @WinVersion
			+ @delimiter + 'LogicalCPUcnt: ' + CAST(@CPULogicalCoreCnt as varchar(3))
			--+ @delimiter + 'HostCPUModel: ' + ISNULL(@CPUModel, '--')
			+ @delimiter + 'HostCPUDesc: ' + ISNULL(@CPUName, '--') 
			--+ @delimiter + 'HostCPUSockets: ' + ISNULL(CAST(@PhysicalCPUSockets as varchar(3)), '--')
		, 1
		, @now

------------------------------------------
-- Backup Processor info

SET @RC = 0
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Clientver', @CV_Clientver OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_BRATver', @CV_BRATver OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DisableAdv', @DisableAdv OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT, @quiet = 1
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsVersion', @dbsVersion OUTPUT, @quiet = 1

INSERT INTO #Audit
	SELECT @HostName
		,'Info'
		, '--'
		, '--'
		, 'UBSMWE v' + @dbsVersion + @delimiter + ' Backup processor: ' + CAST(dbsDatabaseBackupProcessorID as varchar(2)) 
			+ ' (' + dbp.dbsDatabaseBackupProcessorName + ')'
			+ CASE 
				WHEN @dbsBackupProcessor IN (4,5) THEN 
					@delimiter + 'CV Client: ' + ISNULL(@CV_Clientver,'unknown')
					+ @delimiter + 'CV BRAT: ' + ISNULL(@CV_BRATver,'unknown')
					+ @delimiter + 'CommCell: ' + ISNULL(@CVFQDNCommCell,'*NULL*') 
				ELSE ''
			END
		, 1 -- results pos
		, @now
	FROM DBServices.dbo.dbsDatabaseBackupProcessor dbp
	WHERE dbsDatabaseBackupProcessorID = @dbsBackupProcessor

------------------------------------------
-- DB Backup check

DECLARE @TblOutput TABLE(
	DBName varchar(128)
	,[Status] varchar(40)
	,TestOutput varchar(255)
	)

INSERT INTO @TblOutput
	EXEC @RC = DBServices.dbo.[usp_DBBackupChk]

INSERT INTO #Audit
	SELECT @HostName
		,'msdbBkupCheck'
		,DBName
		,[Status]
		,TestOutput
		,3 -- results position
		,@now
	FROM @TblOutput


------------------------------------------
-- DB filegroup space check

DECLARE @FG_Perc_Free tinyint --= 10 --DB Space check % threshold
	, @DBName sysname
	, @FileGroupName nvarchar(50)
	, @DataSize float(24)
	, @PercFree int
	, @Spacefree float
	, @AutoG_MaxSize_MB float(24)
	, @AutoG_MaxAvail_MB float(24)
	, @AutoG_MaxPercFree int
	, @RecModel nvarchar(15)
	, @growth int

IF OBJECT_ID('tempdb..#data') IS NOT NULL 
	DROP TABLE #data

CREATE TABLE #data (
	DatabaseName sysname
	,FileType int
	,FileGroupID smallint
	,FileGroupName nvarchar(50)
	,RecModel nvarchar(15)
	,Data_Size_MB float(24)
	,Data_Avail_MB float(24)
	,AutoG_MaxSize_MB float(24)
	,AutoG_MaxAvail_MB float(24)
	,growth int)


SET @FG_Perc_Free = 10

------------------------

DECLARE vcursor CURSOR FOR
	SELECT [name]
	FROM master..sysdatabases
	WHERE (([status] & 32) = 0
		AND ([status] & 64) = 0 
		AND ([status] & 128) = 0
		AND ([status] & 256) = 0
		AND ([status] & 512) = 0
		--AND ([status] & 1024) = 0
		AND ([status] & 4096) = 0
		AND ([status] & 32768) = 0) 
		AND [name] NOT IN ('tempdb', 'master', 'model', 'msdb', 'DBServices')
	ORDER BY [name]

OPEN vcursor

FETCH NEXT FROM vcursor INTO @DBName
WHILE @@FETCH_STATUS = 0
BEGIN
	SET @RecModel = CAST ((SELECT DATABASEPROPERTYEX('' + @DBName + '', 'RECOVERY')) as nvarchar(20))
	
	SET @sqlstr = ('use [' + @DBName + '] 
		INSERT INTO #data 
			SELECT ''' + @DBName + ''' as DBName
			,FILEPROPERTY([name],''IsLogFile'') As FileType
			,groupid
			,ISNULL(FILEGROUP_NAME(groupid),''TLOG   '')
			, ''' + @RecModel + ''' as RecModel
			,SUM(size/128) as Data_Size_MB
			,SUM(size/128.0 - CAST(FILEPROPERTY(name, ''SpaceUsed'') as int)/128.0) as [Data_Avail_MB]
			,[MaxSize_MB]= CASE 
				WHEN growth = 0 THEN SUM(size/128.0)
				ELSE SUM(maxsize/128.0) 
				END
			,[MaxSize_Avail_MB]= CASE 
				WHEN growth = 0 THEN (SUM(size/128.0) - CAST(FILEPROPERTY(name, ''SpaceUsed'') as int)/128.0)
				ELSE (SUM(maxsize/128.0) - CAST(FILEPROPERTY(name, ''SpaceUsed'') as int)/128.0)
				END
			,growth
			FROM [' + @DBName + '].dbo.sysfiles
			GROUP BY FILEPROPERTY([name],''IsLogFile''),groupid,name,growth;') 
		
		EXEC (@sqlstr)

   FETCH NEXT FROM vcursor INTO @DBName
END

------------------------
-- Fix data

UPDATE #data 
SET AutoG_MaxSize_MB = -1
WHERE AutoG_MaxSize_MB = 0

CLOSE vcursor
DEALLOCATE vcursor 


IF (SELECT TOP 1 COUNT(*)
		FROM #data 
		GROUP BY FileGroupID
		HAVING ((SUM(AutoG_MaxAvail_MB) / SUM(AutoG_MaxSize_MB) * 100) <= @FG_Perc_Free)
	) > 0
BEGIN

	DECLARE vcursor CURSOR FORWARD_ONLY FOR 
	SELECT DatabaseName
		,RecModel
		,FileGroupName
		,CAST(SUM(Data_Size_MB) as numeric(20,1)) 'DataSize_MB'
		,CAST(SUM(Data_Avail_MB) as numeric(20,1)) 'Data_Avail_MB'
		,CAST(((SUM(Data_Avail_MB) / SUM(Data_Size_MB)) * 100) as numeric(10,1)) as 'PercFree'
		,CAST(SUM(AutoG_MaxSize_MB) as numeric(20,1)) 'AutoG_MaxSize_MB'
		,CAST(SUM(AutoG_MaxAvail_MB) as numeric(20,1)) 'AutoG_MaxAvail_MB'
		,CAST(((SUM(AutoG_MaxAvail_MB) / SUM(AutoG_MaxSize_MB)) * 100) as numeric(10,1)) as 'AutoG_MaxPercFree'
		,growth
	FROM #data 
	GROUP BY FileGroupID,DatabaseName,FileGroupName,growth,RecModel
	HAVING ((SUM(AutoG_MaxAvail_MB) / SUM(AutoG_MaxSize_MB) * 100) <= @FG_Perc_Free)
	ORDER BY  DatabaseName, FileGroupID
	OPEN vcursor

	FETCH NEXT FROM vcursor
		INTO @DBName,@RecModel,@FileGroupName,@DataSize,@Spacefree,@PercFree
			,@AutoG_MaxSize_MB,@AutoG_MaxAvail_MB,@AutoG_MaxPercFree,@growth
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF (@growth = 0)
		BEGIN
			--Fixed FG size 
			INSERT INTO #Audit
				SELECT @HostName
					,'DB_FG_Size'
					,@DBName 
					, '--' 
					,@RecModel 
					+ @delimiter + 'Fg: ' + @FileGroupName
					+ @delimiter + 'DataSize:' + CAST(CAST(@DataSize as bigint) as nvarchar(20)) + 'MB'
					+ @delimiter + 'DataFree: ' + CAST(CASE  
															WHEN @PercFree > 100 THEN 100
															ELSE @PercFree
														END	as nvarchar(15)) + '%'
					+ @delimiter + 'Spacefree: ' + CAST(CAST(@Spacefree as bigint) as nvarchar(20)) + 'MB'
					, 5 -- results pos
					, @now
		END ------------------------
		ELSE 
		BEGIN -- Auto grow
			INSERT INTO #Audit
				SELECT @HostName
					,'DB_FG_Size'
					,@DBName
					, '--'  
					,@RecModel 
					+ @delimiter + 'Fg:' + @FileGroupName
					+ @delimiter + 'DataSize:' + CAST(CAST(@DataSize as bigint) as nvarchar(20)) + 'MB'
					+ @delimiter + 'DataFree:' + CAST(CASE  
														WHEN @PercFree > 100 THEN 100
														ELSE @PercFree
														END	as nvarchar(15)) + '%'
					+ @delimiter + CAST(CAST(@Spacefree as bigint) as nvarchar(20)) + 'MB'
					+ @delimiter + 'AutoGMaxFree:' + CAST(CASE  
																WHEN @AutoG_MaxPercFree > 100 THEN 100
																ELSE @AutoG_MaxPercFree
															END	as nvarchar(15)) + '%'
					+ @delimiter + CASE 
									WHEN CAST(@AutoG_MaxAvail_MB as bigint) = -1 THEN 'Unrestricted'
									ELSE CAST(CAST(@AutoG_MaxAvail_MB as bigint) as nvarchar(20)) + 'MB'
									END 
					, 5 -- results pos
					, @now
		END
			
		FETCH NEXT FROM vcursor	
			INTO @DBName,@RecModel,@FileGroupName,@DataSize,@Spacefree,@PercFree
				,@AutoG_MaxSize_MB,@AutoG_MaxAvail_MB,@AutoG_MaxPercFree,@growth
	END

	SET @RC = @@ERROR
	IF @RC <> 0
		INSERT INTO #Audit VALUES (@HostName, 'DB_FG_Size', '--', 'Err', '** Runtime Error DB filegroup space **', 1, @now)

	CLOSE vcursor
	DEALLOCATE vcursor
END
ELSE
	 INSERT INTO #Audit VALUES (@HostName, 'DB_FG_Size', '--', 'OK', '', 4, @now)


------------------------------------------
-- UBSMWE Error table Check

IF EXISTS (SELECT TOP 1 [InitialLogTime]
	FROM [DBServices].[dbo].[UBSMWE_Errors]
	WHERE [InitialLogTime] BETWEEN @now -2 AND @now
	ORDER BY [UBSMWE_Error_ID] DESC)
BEGIN
	INSERT INTO #Audit
	SELECT TOP 3
		@HostName
		,'UBSMWE_LastErr'
		,'--'
		,'--'
		,CAST([UBSMWE_Error_ID] as varchar(15))
		+ @delimiter + CAST([InitialLogTime] as varchar(25))
		+ @delimiter + RIGHT([message],150)
		, 2 -- results pos
		, @now
	FROM [DBServices].[dbo].[UBSMWE_Errors]
	WHERE [InitialLogTime] BETWEEN @now -2 AND @now
	ORDER BY [UBSMWE_Error_ID] DESC
END

SET @RC = @@ERROR
IF @RC <> 0
	INSERT INTO #Audit VALUES (@HostName, 'UBSMWE_LastErr', '--','Err', '** Runtime Error UBSMWE Error table **', 1, @now)
		
------------------------------------------
-- DiskSpace check

EXEC @RC = DBServices.dbo.usp_fixeddrives2 @quiet=1

IF @RC = 1
	INSERT INTO #Audit VALUES (@HostName, 'DiskSpace', '--','Err', '** Runtime Error DiskSpace **', 1, @now)
ELSE
	INSERT INTO #Audit 
	SELECT @HostName
		,'DiskSpace'
		, '--'
		,ThresholdStatus 
		,LTRIM(RTRIM(DeviceName)) 
			+ @delimiter + 'Capacity(GB): '+ CAST(CAST(Capacity/1024 as numeric(20,2)) as varchar(20))
			+ @delimiter + 'FreeSpace(GB): ' + CAST(CAST(FreeSpace/1024 as numeric(20,2)) as varchar(20))
			+ @delimiter + '%Free: ' + CAST(PercFree as varchar(15))  
		,6 -- results pos
		, @now
	FROM DBServices.dbo.dbsVolInfo

------------------------------------------
-- SQL job failure check

DECLARE @Job_Name sysname
	, @last_run_outcome tinyint
	, @FailedDate as smalldatetime

IF EXISTS (	SELECT 1
			FROM msdb..sysjobs j
			INNER JOIN msdb..sysjobsteps s WITH (NOLOCK)
				ON s.job_id=j.job_id
			INNER JOIN msdb..sysjobhistory h WITH (NOLOCK)
				ON h.job_id= j.job_id AND h.step_id = s.step_id
			WHERE
				j.[enabled] <> 0
				AND h.run_status <> 1
				AND s.last_run_outcome <> 1
				AND h.run_date >= (CAST(CONVERT(char(8), @now, 112) as int) - @JobFailure_ConcernDays)
				AND s.command NOT LIKE '%usp_UBSMWE_Engine%'
			)
BEGIN
	DECLARE @lastjob TABLE (lastjobname sysname)

	DECLARE vcursor CURSOR FOR
	SELECT TOP 10 j.[name]
			, FailedTime = CAST ((CONVERT (smalldatetime, RTRIM(h.run_date)) 
				+ (h.run_time * 9 
				+ h.run_time % 10000 * 6 
				+ h.run_time % 100 * 10) / 216e4) as smalldatetime)
			,[last_run_outcome]

	FROM  msdb..sysjobs j
	INNER JOIN msdb..sysjobsteps s WITH (NOLOCK)
		ON s.job_id=j.job_id
	INNER JOIN msdb..sysjobhistory h WITH (NOLOCK)
		ON h.job_id= j.job_id AND h.step_id = s.step_id

	WHERE
		j.[enabled] <> 0
		AND h.run_status <> 1
		AND s.last_run_outcome <> 1
		AND h.run_date >= (CAST(CONVERT(char(8), @now, 112) as int) - @JobFailure_ConcernDays)
		AND s.command NOT LIKE '%usp_UBSMWE_Engine%'
	GROUP BY h.run_date , h.run_time, j.[name],[last_run_outcome]
	ORDER BY h.run_date DESC, h.run_time DESC

	OPEN vcursor

	FETCH NEXT FROM vcursor INTO @Job_Name,@FailedDate,@last_run_outcome 
	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF NOT EXISTS (SELECT DISTINCT lastjobname 
			FROM @lastjob
			WHERE lastjobname = @Job_Name) 
		BEGIN
			INSERT INTO #Audit
			SELECT @HostName
				,'JobFailure', '--'
				,CASE @last_run_outcome
					WHEN 0 THEN '*FAILED*' 
					WHEN 3 THEN 'Canceled'
					ELSE CAST(@last_run_outcome as char(1))
				END
				, @Job_Name + @delimiter + CAST(@FailedDate as varchar(20)) 
				, 8 -- results pos
				, @now

			INSERT INTO @lastjob VALUES (@Job_Name)	
		END
		
			FETCH NEXT FROM vcursor INTO @Job_Name,@FailedDate,@last_run_outcome 
	END
	CLOSE vcursor
	DEALLOCATE vcursor 
END

SET @RC = @@ERROR
IF @RC <> 0
	INSERT INTO #Audit VALUES (@HostName, 'JobFailure', '--', 'Err', '** Runtime Error SQL job failures **', 1, @now)
	
------------------------------------------------------------------------------------
-- UBSMWE Checks

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT, @quiet = 1
SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\CVbackup'

IF @dbsBackupProcessor IN (1,2,3) 
	AND EXISTS (SELECT [dbsInstanceConfigValue]
			FROM DBServices..[dbsInstanceConfig]
			WHERE [dbsInstanceConfigName]= 'NB_Enabled' AND [dbsInstanceConfigValue] = 1) 
	SET @OffsiteFileBkType = 'Netbackup'

IF	EXISTS (SELECT [dbsInstanceConfigValue]
				FROM DBServices..[dbsInstanceConfig]
				WHERE [dbsInstanceConfigName]= 'CV_Enabled' AND [dbsInstanceConfigValue] = 1) 
	SET @OffsiteFileBkType = 'CV_Filebak'
ELSE 
	SET @OffsiteFileBkType = 'NA'


------------------------------------------
-- File Backup Job Check

IF @OffsiteFileBkType <> 'NA'
BEGIN
	INSERT INTO #Audit
		SELECT @HostName
			, @OffsiteFileBkType + '_JobChk'
			, '--'
			, CASE last_run_outcome 
				WHEN 0 THEN '*FAILED*'
				WHEN 1 THEN 'OK'
				WHEN 2 THEN 'Retry'
				WHEN 3 THEN 'Canceled'
				WHEN 5 THEN 'Unknown' -- --0 = Failed,1 = Succeeded,2 = Retry,3 = Canceled,5 = Unknown
				END
				
			, CAST(CAST(SUBSTRING(STR(last_run_duration),LEN(STR(last_run_duration))-5,2) as tinyint) as varchar(6)) + 'h '
				+ CAST(CAST(SUBSTRING(STR(last_run_duration),LEN(STR(last_run_duration))-3,2)as tinyint) as char(2)) + 'm '
				+ CAST(CAST(SUBSTRING(STR(last_run_duration),LEN(STR(last_run_duration))-1,2)as tinyint) as char(2)) + 's'
				
				+ @delimiter + 'LastRan: ' + 
				CASE 
				WHEN s.last_run_date <> 0 THEN
					 CAST(CAST ((CONVERT (DATETIME, RTRIM(s.last_run_date)) 
						+ (last_run_time * 9 
						+ last_run_time % 10000 * 6 
						+ last_run_time % 100 * 10) / 216e4) as smalldatetime) as varchar(20))
				ELSE '--'	
				END	
				, 3 -- results pos
				, @now
		FROM  msdb..sysjobsteps s
		WHERE s.step_id=1
			AND s.database_name='DBServices' 
			AND (s.command LIKE '%usp_RunFilebackup%')
END

SET @RC = @@ERROR
IF @RC <> 0
	INSERT INTO #Audit VALUES (@HostName, @OffsiteFileBkType + '_JobChk', '--', 'Err', '** Runtime Error File Backup Job Check **', 1, @now)

------------------------------------------
-- UBSMWE job failure count
	
INSERT INTO #Audit
	SELECT @HostName 
		, 'UBSMWE_ErrCnt'
		, '--'
		, '--'
		, 'Errors over ' + CAST (@JobFailure_ConcernDays as varchar(6)) + ' days = ' 
			+ CAST (COUNT([InitialLogTime]) as varchar(4)) 
		, 2 -- results pos
		, @now
	FROM [DBServices].[dbo].[UBSMWE_Errors]
	WHERE [InitialLogTime] BETWEEN (@now - @JobFailure_ConcernDays) AND @now

------------------------------------------
-- UBSMWE backup job failure count 

INSERT INTO #Audit
	SELECT @HostName 
		,'UBSMWE_BkJob_FailCnt'
		, '--'
		, '--'
		,'Failures over ' + CAST (@JobFailure_ConcernDays as varchar(6)) + ' days = '
			+ CAST (COUNT(j.[name]) as varchar(4)) 
		, 2 -- results pos
		, @now
	FROM msdb..sysjobs j 
		INNER JOIN msdb..sysjobsteps s WITH (NOLOCK)
			ON s.job_id = j.job_id
		INNER JOIN msdb..sysjobhistory h WITH (NOLOCK)
			ON h.job_id = j.job_id AND h.step_id = s.step_id
	WHERE  
		j.[enabled] <> 0
		--AND s.last_run_outcome <> 1
		AND h.run_status <> 1
		AND h.run_date >= (CAST(CONVERT(char(8), @now, 112) as int) - @JobFailure_ConcernDays)
		AND (j.[name] IN ('UBSMWE_WF_Daily_BUFull','UBSMWE_WF_Daily_BULog','UBSMWE_WF_Filebackup')
			OR (j.[name] LIKE 'UBSMWE_WFST_BUFull%')
			OR  (j.[name] LIKE 'UBSMWE_WFST_BULog%'))
		AND h.[message] NOT LIKE '%Failed to connect to QSDK Server%'

------------------------------------------------------------
-- CV migrated

IF @dbsBackupProcessor IN (4,5)
BEGIN

	------------------------------------------
	-- Compare SQL DB names with CV Subclient DB names (case sensitive) for mismatch

	INSERT INTO #Audit
	SELECT @HostName 
		,'CV_DBname_Mismatch'
		, ISNULL(sd.name, '*unidentified*')
		, CASE db.dbsDatabaseIsActive
				WHEN 0 THEN 'Inactive'
				WHEN 1 THEN 'Active'
				ELSE 'Unknown'
			END
		,'CV Subclient DB name: ' + ISNULL(dbs.dbsDatabaseName, '*unidentified*') 
		, 3 -- results pos
		, @now
	FROM [DBServices].[dbo].[dbsDatabase] db
	INNER JOIN sys.sysdatabases sd WITH (NOLOCK)
		ON db.dbsDatabasedbid = sd.dbid
	INNER JOIN [DBServices].[dbo].[dbsCVSubclients] dbs
		ON dbs.dbsDatabaseUID = db.dbsDatabaseUID
	WHERE LOWER(sd.name) = LOWER(dbs.dbsDatabaseName)
		AND sd.name <> dbs.dbsDatabaseName COLLATE Latin1_General_CS_AS 
	ORDER BY db.dbsDatabaseCreateDate DESC

	------------------------------------------
	-- Verify CV Services status

	IF ISNULL(@DisableAdv,0) = 0
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_CVKickService] 1 -- Query CV services

		INSERT INTO #Audit 
		VALUES (@HostName
			, 'CV_Service'
			, '--'
			, CASE @RC
					WHEN 0 THEN 'OK'
					WHEN 999 THEN '*CV SERVICE OFFLINE*'
					ELSE '** Runtime Error CV_Service **'
			  END
			, ''
			, 3 
			, @now)
	END --------------------
	ELSE -- @DisableAdv = 1 - unable to determine CV Services status
		INSERT INTO #Audit
		SELECT @HostName
			,'Info'
			, '--'
			, '--'
			, 'DisableAdv = 1 - advanced feature set disabled'
			, 1 -- results pos
			, @now

	------------------------------------------
	-- TRRv3 - CV Tlog Chain 

	IF @dbsBackupProcessor = 5 
	BEGIN
		INSERT INTO #Audit 
		SELECT DISTINCT TOP 10
				@HostName
				,'CV_TlogChain'
				,dbsD.dbsDatabaseName 
				,'*CV BAK CHAIN BROKEN*'
				,CAST(bs.backup_start_date as char(19))
					+ @delimiter + 'File: ' + bsmf.physical_device_name 
				,4 -- results pos
				,@now
				
		FROM DBServices.dbo.dbsDatabase dbsD WITH (NOLOCK)
		INNER JOIN msdb.dbo.backupset bs WITH (NOLOCK)
			ON bs.database_name = dbsD.dbsDatabaseName
		INNER JOIN msdb.dbo.backupmediaset bsm WITH (NOLOCK)
			ON bsm.media_set_id = bs.media_set_id 
		INNER JOIN msdb.dbo.backupmediafamily bsmf WITH (NOLOCK)
			ON bsmf.media_set_id = bsm.media_set_id 

		WHERE dbsD.dbsDatabaseIsActive = 1
			AND dbsD.dbsDatabaseName NOT IN (
				SELECT DISTINCT primary_database
				FROM [msdb].[dbo].[log_shipping_primary_databases] WITH (NOLOCK)
				UNION
				SELECT DISTINCT secondary_database 
				FROM [msdb].[dbo].[log_shipping_secondary_databases] WITH (NOLOCK)
				)
			AND bs.[type] = 'L'
			AND bs.[name] <> 'CommVault Galaxy Backup'
			AND bs.backup_start_date > (@now - @JobFailure_ConcernDays)
			AND bs.backup_start_date > (
					SELECT MIN(backup_finish_date)
					FROM msdb.dbo.backupset bs WITH (NOLOCK)
					WHERE bs.[name] = 'CommVault Galaxy Backup'
						AND bs.[type] <> 'L')
						
		GROUP BY bs.backup_start_date
			,dbsD.dbsDatabaseName
			,bsmf.physical_device_name
			
		ORDER BY CAST(bs.backup_start_date as char(19))
				+ @delimiter + 'File: ' + bsmf.physical_device_name ASC
	END

	------------------------------------------
	-- Verify NT AUTHORITY\SYSTEM SQL permissions

	IF  IS_SRVROLEMEMBER ('sysadmin','NT AUTHORITY\SYSTEM') = 2 
	BEGIN
		INSERT INTO #Audit
			SELECT @HostName
				,'SystemAccnt'
				,'--'
				,'*ALERT*'
				,'Account: NT AUTHORITY\SYSTEM missing from sysadmin; CV FileSystem iDA backups will fail'
				, 10 -- results pos
				, @now
	END
	------------------------------------------
	-- CV FS Registration check

	DECLARE @CVFSBackupSet nvarchar(128)
		,@CVFSSubclient nvarchar(128)

	EXEC @RC = [DBServices].[dbo].[usp_CVFSBackupSet] @CVFSBackupSet OUTPUT, @CVFSSubclient OUTPUT

	INSERT INTO #Audit
		SELECT @HostName
				,'CV_FSReg'
				,'--'
				,CASE @RC
					WHEN 0 THEN 'YES'
					WHEN 1 THEN 'NO' 
					ELSE 'ERR'
				 END
				,ISNULL('FSBackupSet: ' + @CVFSBackupSet + @delimiter + 'FSSubclient: ' + @CVFSSubclient,'')
				, 3 -- results pos
				, @now

	------------------------------------------
	-- dbsCVScheduleCmdLog failures 

	IF @dbsBackupProcessor = 5 
		AND OBJECT_ID('DBServices.dbo.dbsCVScheduleCmdLog') IS NOT NULL 
	BEGIN
		SELECT @RC = COUNT(*)
		FROM DBServices.dbo.dbsCVScheduleCmdLog
		WHERE CmdDateTime > (@now - @JobFailure_ConcernDays)
			AND CmdSuccess = 0

		INSERT INTO #Audit
			SELECT @HostName
					,'CV_SchCmdCnt'
					,'--'
					,CASE
						WHEN @RC > 0 THEN '*ALERT*'
						ELSE 'OK'
					 END -- status
					,'CV Scheduled Cmd failures over ' + CAST(@JobFailure_ConcernDays as varchar(6)) 
						+ ' days = ' + CAST(@RC as varchar(6)) 
						+ ' - See tbl dbsCVScheduleCmdLog for details'
					, 3 -- results pos
					, @now
	END
END ------------------------------------------
ELSE
BEGIN
	INSERT INTO #Audit
		SELECT @HostName,'TRR Mig','--','Info', '** Not Migrated **', 2, @now
END


------------------------------------------
------------------------------------------
--SysInfo

DECLARE @Mem_usage_MB bigint
	,@Physical_Mem_MB bigint
	,@Target_Mem_MB bigint
	,@MemMgr_usage_MB bigint
	,@Uptime_hrs bigint
	,@Avg_cpu_Ghz numeric(10,2)
	,@total_buffer int
	,@BufferCacheHitRatio numeric(10,2)
	,@PagelifeSecs bigint
	,@BPoolused_MB bigint
	,@BPoolused_perc numeric(10,2)
	,@AvgDiskLatency_ms numeric(10,2)
--	,@VM char(1)
	,@MinMem_MB bigint
	,@MaxMem_MB bigint
	
SELECT TOP 1 @Target_Mem_MB = cntr_value
FROM sys.dm_os_performance_counters 
WHERE ([object_name] LIKE '%Memory Manager%'
		AND counter_name = 'Target Server Memory (KB)')
 
SET @total_buffer = @Target_Mem_MB / 8
SET @Target_Mem_MB = @Target_Mem_MB / 1024

;WITH BufCount as (
		SELECT
			database_id
			,db_buffer_pages = COUNT_BIG(*)
		FROM sys.dm_os_buffer_descriptors
		GROUP BY database_id
		)

	,BufCount_detail as (
		SELECT 
		   [Database_Name] =
				CASE [database_id]
					WHEN 32767 THEN'MSSQL System Resource'
					ELSE DB_NAME([database_id])
				END
			,[database_id]
			,[BPool page cnt] = db_buffer_pages
			,[BPool use (MB)] = db_buffer_pages / 128
			,[BPool use (%)] = CONVERT(numeric(6,3), db_buffer_pages * 100.0 / @total_buffer)
		FROM BufCount
		)

--------------------

INSERT INTO #Audit
	SELECT @HostName
			,'DBInfo'
			,[Database_Name]
			,CAST(DATABASEPROPERTYEX ([Database_Name], 'Status') as varchar(15))
			,'dbid: ' + CAST([database_id] as varchar(5)) 
			+ @delimiter + 'DataFilesSize_MB: ' + CAST([Data File(s) Size (KB)] / 1024 as varchar(20))
			+ @delimiter + 'TLogFilesSize_MB: ' + CAST([Log File(s) Size (KB)] / 1024 as varchar(20))
			+ @delimiter + 'BPoolused_MB: ' + CAST([BPool use (MB)] as varchar(15))
			+ @delimiter + 'BPoolused_%: ' + CAST([BPool use (%)] as varchar(15))
			+ @delimiter + 'Transactions_sec: ' + CAST([Transactions/sec] as varchar(15))
			,50 -- results pos
			, @now
	FROM (
		SELECT 
			pc.instance_name
			,pc.counter_name
			,pc.cntr_value as 'value'
		FROM sys.dm_os_performance_counters pc
		WHERE pc.[object_name] LIKE '%:Databases%'
				AND pc.counter_name IN (
				'Data File(s) Size (KB)'
				,'Log File(s) Size (KB)'
				,'Transactions/sec')
		) as src
	PIVOT (
		SUM([value])
		FOR counter_name IN (
				[Data File(s) Size (KB)]
				,[Log File(s) Size (KB)]
				,[Transactions/sec]
				)
		) as perfcnt
	INNER JOIN (
		SELECT bc.[Database_Name]
			,bc.[database_id]
			,bc.[BPool use (MB)]
			,bc.[BPool use (%)]
		FROM BufCount_detail bc
		) as BPool
		ON BPool.[Database_Name] = perfcnt.instance_name
	OPTION (MAXDOP 1)

------------------------------------------

;WITH BufCount as (
		SELECT
			database_id
			,db_buffer_pages = COUNT_BIG(*)
		FROM sys.dm_os_buffer_descriptors
		GROUP BY database_id)
SELECT 
	--[Total BPool page cnt] = SUM(db_buffer_pages)
	@BPoolused_MB = SUM(db_buffer_pages) / 128 --[Total BPool use (MB)]
	,@BPoolused_perc = CONVERT(numeric(6,3), SUM(db_buffer_pages) * 100.0 / @total_buffer) --[Total BPool use (%)]
FROM BufCount;

--------------------

SELECT @MemMgr_usage_MB = SUM(cntr_value) / 1024
FROM sys.dm_os_performance_counters 
WHERE [object_name] LIKE '%Memory Manager%'
		AND counter_name IN (
			'Connection Memory (KB)'
			,'Granted Workspace Memory (KB)'
			,'Lock Memory (KB)'
			,'Optimizer Memory (KB)'
			,'SQL Cache Memory (KB)'
			,'Total Server Memory (KB)')

--------------------

SELECT
	@Uptime_hrs = ms_ticks / 3600000
	,@Avg_cpu_Ghz = CAST(
		CAST(((cpu_ticks / ms_ticks)) as numeric(20,2))
			/ 1000000 as numeric(20,2) )
FROM sys.dm_os_sys_info

--------------------

SET @sqlstr = N'SELECT @Physical_Mem_MBOUT = '
					+ CASE 
						WHEN @MajorVersion >= 11 THEN 'physical_memory_kb / 1024'
						ELSE 'physical_memory_in_bytes / 1048576'
					END
			+ ' FROM sys.dm_os_sys_info'

SET @permdef = N'@Physical_Mem_MBOUT bigint OUTPUT'

EXEC sp_executesql @sqlstr, @permdef, @Physical_Mem_MBOUT = @Physical_Mem_MB OUTPUT

--------------------


--------------------

SELECT @BufferCacheHitRatio = CAST((a.cntr_value * 1.0 / b.cntr_value) * 100.0 as numeric(10,2)) 
FROM sys.dm_os_performance_counters  a
INNER JOIN (SELECT cntr_value, [OBJECT_NAME] 
			FROM sys.dm_os_performance_counters  
			WHERE counter_name = 'Buffer cache hit ratio base'
				AND [OBJECT_NAME] LIKE '%Buffer Manager%'
		) b 
	ON a.[OBJECT_NAME] = b.[OBJECT_NAME]
WHERE a.counter_name = 'Buffer cache hit ratio'
	AND a.[OBJECT_NAME] LIKE '%Buffer Manager%'

--------------------

-- less than 300 seconds this could indicate memory pressure, a cache flush or missing indexes.
SELECT @PagelifeSecs = cntr_value
FROM sys.dm_os_performance_counters 
WHERE counter_name = 'Page life expectancy'
	AND [OBJECT_NAME] LIKE '%Buffer Manager%'

--------------------

SELECT TOP 1 @AvgDiskLatency_ms = CAST((SUM(io_stall)) / (1.0 + SUM(num_of_reads + num_of_writes)) as numeric(10, 1)) 
FROM sys.dm_io_virtual_file_stats(NULL, NULL) as d
INNER JOIN sys.master_files as m
	ON m.database_id = d.database_id
		AND m.file_id = d.file_id
GROUP BY physical_name
ORDER BY CAST((SUM(io_stall)) / (1.0 + SUM(num_of_reads + num_of_writes)) as numeric(10, 1)) DESC;

--------------------
/*
IF @MajorVersion >= 10
BEGIN
	SET @sqlstr = 'SELECT TOP 1 @VM_OUT = virtual_machine_type FROM sys.dm_os_sys_info'
	SET @permdef = N'@VM_OUT char(1) OUTPUT'

	EXEC sp_executesql @sqlstr, @permdef, @VM_OUT = @VM OUTPUT
	SET @VM = ISNULL(@VM, '?')
END
ELSE
	SET @VM = '?'
*/
--------------------

SELECT @MinMem_MB = CAST([value_in_use] as bigint)
FROM sys.configurations
WHERE [name] = 'min server memory (MB)'

SELECT @MaxMem_MB = CAST([value_in_use] as bigint)
FROM sys.configurations
WHERE [name] = 'max server memory (MB)'

--------------------

INSERT INTO #Audit
	SELECT @HostName
			,'SysInfo'
			,'--'
			,'--'
			,'Uptime_hrs: ' + CAST(@Uptime_hrs as varchar(15))
			--+ @delimiter + 'VM: ' + @VM 
			+ @delimiter + 'Physical_Mem_MB: ' + CAST(@Physical_Mem_MB as varchar(15))
			+ @delimiter + 'AvgDiskLatency_ms: ' + CAST(@AvgDiskLatency_ms as varchar(15))  
			+ @delimiter + 'Avg_cpu_Ghz: ' + CAST(@Avg_cpu_Ghz as varchar(5))
			, 2 -- results pos
			, @now

--------------------

INSERT INTO #Audit
	SELECT @HostName
			,'SysInfo'
			,'--'
			,'--'
			,'SQLMinMB: ' + CAST(@MinMem_MB as varchar(15))
			+ @delimiter + 'SQLMaxMB: ' + CAST(@MaxMem_MB as varchar(15))
			+ @delimiter + 'SQLMemMgr_usage_MB: ' + CAST(@MemMgr_usage_MB as varchar(15))
			+ @delimiter + 'SQLMemMgr_usage_%: ' +  CAST( CAST( (CAST(@MemMgr_usage_MB as numeric(10,2)) / @Physical_Mem_MB) * 100  as numeric(10,2)) as varchar(15)) 
			+ @delimiter + 'BPTarget_Mem_MB: ' + CAST(@Target_Mem_MB as varchar(15))  
			+ @delimiter + 'BPoolused_MB: ' + CAST(@BPoolused_MB as varchar(15))  
			+ @delimiter + 'BPoolused_%: ' + CAST(@BPoolused_perc as varchar(15)) 
			+ @delimiter + 'BPoolCacheHitRatio: ' + CAST(@BufferCacheHitRatio as varchar(15)) 
			+ @delimiter + 'PageLife_secs: ' + CAST(@PagelifeSecs as varchar(15))
			, 2 -- results pos
			, @now

-----------------------
-- Sysinfo checks

IF (@AvgDiskLatency_ms > 20) 
	INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'Poor Avg disk latency: ' + CAST(@AvgDiskLatency_ms as varchar(15)) + 'ms (> 20ms => does not meet MS recommendations)'
			, 2 -- results pos
			, @now

IF (@PagelifeSecs <= 300) 
	INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'Pagelife_Secs low: '  + CAST(@PagelifeSecs as varchar(15)) + ' (< 300 => mem pressure)'
			, 2 -- results pos
			, @now

IF (@BufferCacheHitRatio <= 80) 
	INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'BPoolCacheHitRatio poor: ' + CAST(@BufferCacheHitRatio as varchar(15)) + '% (< 80% => insufficient mem allocation)'
			, 2 -- results pos
			, @now

IF (@BPoolused_perc <= 60)
	INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'BPoolused poor: ' + CAST(@BPoolused_perc as varchar(15)) + '% (< 60% => mem reduction candidate)'
			, 2 -- results pos
			, @now

IF (@Physical_Mem_MB - @MemMgr_usage_MB < 1000) 
		INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'OS Mem alloc: ' + CAST((@Physical_Mem_MB - @MemMgr_usage_MB) as varchar(15)) + 'MB (< 1000MB => review MSSQL mem allocation)'
			, 2 -- results pos
			, @now

IF (@MaxMem_MB >= (@Physical_Mem_MB - 1000)) 
		INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'MSSQL MaxMem alloc: ' + CAST((@MaxMem_MB) as varchar(15)) + 'MB (> Physical Mem - 1000MB => review MSSQL mem allocation)'
			, 2 -- results pos
			, @now

IF (@Avg_cpu_Ghz < 1)
		INSERT INTO #Audit
		SELECT
			@HostName
			,'SysInfo'
			,'--'
			,'*CHECK*'
			,'Low CPU avg Ghz: ' + CAST(@Avg_cpu_Ghz as varchar(15)) + 'Ghz (< 1 => server underutilized)'
			, 2 -- results pos
			, @now


------------------------------------------
-- AlwaysOn AG 

IF @MajorVersion >= 11
BEGIN
	SET @sqlstr = 'INSERT INTO #Audit
		SELECT DISTINCT CONVERT(sysname, SERVERPROPERTY(''ServerName''))
			,''AOAGInfo''
			,sd.[name] as ''DBname''
			,dbrs.synchronization_health_desc
			,''AG:'' + ag.[name]
			+ ''' + @delimiter + ''' + CASE
					WHEN ags.primary_replica = CONVERT(sysname, SERVERPROPERTY(''ServerName'')) THEN ''*''
					ELSE ''''
				END + ''Pnode: '' + ags.primary_replica
			+ ''' + @delimiter + ''' + ''Pstate: '' + ISNULL(ags.primary_recovery_health_desc, ''--'')
			+ ''' + @delimiter + ''' + ''Sstate: '' + ISNULL(ags.secondary_recovery_health_desc, ''--'')
			+ ''' + @delimiter + ''' + ''ListenDNS: '' + ISNULL(agl.[dns_name], ''--'')
			+ ''' + @delimiter + ''' + ''ListenPort: '' + ISNULL(CAST(agl.[port] as varchar(5)), ''--'')
			+ ''' + @delimiter + ''' + ''AvailMode: '' + LOWER(ar.[availability_mode_desc])
			+ ''' + @delimiter + ''' + ''FailoverMode: '' + LOWER(ar.[failover_mode_desc])
			+ ''' + @delimiter + ''' + ''BackupPref: '' + LOWER(ag.[automated_backup_preference_desc])
			,60 -- results pos
			,''' + CAST(@now as varchar(20))
		+ ''' FROM sys.availability_groups ag
		INNER JOIN sys.availability_replicas ar
			ON ar.group_id = ag.group_id
		LEFT OUTER JOIN sys.availability_group_listeners agl
			ON agl.group_id = ag.group_id
		INNER JOIN sys.databases sd WITH (NOLOCK)
			ON sd.[replica_id] = ar.replica_id
		INNER JOIN sys.dm_hadr_availability_group_states ags
			ON ags.group_id = ag.group_id
		INNER JOIN sys.dm_hadr_database_replica_states dbrs
			ON dbrs.database_id = sd.database_id
				AND dbrs.group_id = ag.group_id
				AND dbrs.replica_id = ar.replica_id'

	EXEC (@sqlstr)
END

------------------------------------------
-- DB Mirroring

IF @MajorVersion >= 9
BEGIN
	SET @sqlstr = 'INSERT INTO #Audit
		SELECT CONVERT(sysname, SERVERPROPERTY(''ServerName''))
			,''DBMirrorInfo''
			,DB_NAME(database_id)
			,''MirrorState: '' + mirroring_state_desc
			,''MRole: '' + mirroring_role_desc 
			+ ''' + @delimiter + ''' + ''MPartner: '' + mirroring_partner_instance
			+ ''' + @delimiter + ''' + ''MSafety: ''
				+ CASE
					WHEN mirroring_safety_level = 1 THEN ''HighPerf''
					WHEN mirroring_safety_level = 2 THEN ''HighSafety''
					ELSE NULL
				END
			,61 -- results pos
			,''' + CAST(@now as varchar(20))
		+ ''' FROM sys.database_mirroring dbm
		WHERE mirroring_guid IS NOT NULL'

	EXEC (@sqlstr)
END

------------------------------------------
-- DB Logshipping

IF @MajorVersion >= 9
BEGIN
	IF EXISTS (SELECT TOP 1 1
				FROM msdb.dbo.log_shipping_primary_databases)
	BEGIN
		--Logshipping - Primary host

		INSERT INTO #Audit
			SELECT @HostName
				,'LSInfo'
				,lsmp.primary_database
				,CASE 
					WHEN DATEDIFF(minute, lsmp.last_backup_date, getdate()) > lsmp.backup_threshold THEN '*CHECK*'
					ELSE 'PBak<' + CAST(lsmp.backup_threshold as varchar(6)) + 'm'
				END
				,'*PNode: ' + lsmp.primary_server
				+ @delimiter + 'SNode: ' + lsps.secondary_server
				+ @delimiter + 'SDB: ' + lsps.secondary_database
				+ @delimiter + 'Mon: ' + lspd.monitor_server
				+ @delimiter + 'PTLogStaging: ' + lspd.backup_directory
				+ @delimiter + 'PLastBak: ' + CAST(lsmp.last_backup_date as varchar(20))
				, 62 -- results pos
				, @now
			FROM msdb.dbo.log_shipping_primary_secondaries lsps
			INNER JOIN msdb.dbo.log_shipping_monitor_primary lsmp 
				ON lsps.primary_id = lsmp.primary_id
			INNER JOIN msdb.dbo.log_shipping_primary_databases lspd
				ON lsps.primary_id = lspd.primary_id
			WHERE lsmp.primary_server = @HostName
				AND lsmp.primary_server <> lsps.secondary_server
	END --------------------
	 
	IF EXISTS (SELECT TOP 1 1
				FROM msdb.dbo.log_shipping_secondary )
	BEGIN
		--Logshipping - Secondary host

		INSERT INTO #Audit
			SELECT @HostName
				,'LSInfo'
				,lsms.secondary_database
				,CASE 
					WHEN DATEDIFF(minute, lsms.last_restored_date, getdate()) > lsms.restore_threshold THEN '*CHECK*'
					ELSE 'SRest' + CAST(lsms.restore_threshold as varchar(6)) + 'm'
				END
				,'PNode: ' + lss.primary_server
				+ @delimiter + '*SNode: ' + lsms.secondary_server
				+ @delimiter + 'PDB: ' + lss.primary_database
				+ @delimiter + 'PSource: ' + lss.backup_source_directory
				+ @delimiter + 'SDest: ' + lss.backup_destination_directory
				+ @delimiter + 'SLastRestore: ' + CAST(lsms.last_restored_date as varchar(20))
				, 63 -- results pos
				, @now
			FROM msdb.dbo.log_shipping_secondary lss 
			INNER JOIN msdb.dbo.log_shipping_secondary_databases lssd 
				ON lss.secondary_id = lssd.secondary_id
			INNER JOIN msdb.dbo.log_shipping_monitor_secondary lsms
				ON lss.secondary_id = lsms.secondary_id
			WHERE lsms.secondary_server = @HostName
				AND lss.primary_server <> lsms.secondary_server
	END --------------------
	--ELSE 'No Logshipping'
END

------------------------------------------
-- DB Replication

IF @MajorVersion >= 9
	AND EXISTS (
		SELECT TOP 1 1
		FROM master..sysdatabases
		WHERE LOWER([name]) = 'distribution') 
BEGIN

	DECLARE @ReplStats TABLE (
		[DistributionAgentName] [nvarchar](100) NOT NULL
		,[DistributionAgentStartTime] [datetime] NOT NULL
		,[DistributionAgentRunningDurationInSeconds] [int] NOT NULL
		,[IsAgentRunning] [bit] NULL
		,[ReplicationStatus] [varchar](14) NULL
		,[LastSynchronized] [datetime] NOT NULL
		--,[Comments] [nvarchar](max) NOT NULL
		,[Publisher] [sysname] NOT NULL
		,[PublicationName] [sysname] NOT NULL
		,[PublisherDB] [sysname] NOT NULL
		,[Subscriber] [nvarchar](128) NULL
		,[SubscriberDB] [sysname] NULL
		,[SubscriptionType] [varchar](64) NULL
		,[DistributionDB] [sysname] NULL
		,[Article] [sysname] NOT NULL
		,[UndelivCmdsInDistDB] [int] NULL
		,[DelivCmdsInDistDB] [int] NULL
		,[CurrentSessionDeliveryRate] [float] NOT NULL
		,[CurrentSessionDeliveryLatency] [int] NOT NULL
		,[TotalTransactionsDeliveredInCurrentSession] [int] NOT NULL
		,[TotalCommandsDeliveredInCurrentSession] [int] NOT NULL
		,[AverageCommandsDeliveredInCurrentSession] [int] NOT NULL
		,[DeliveryRate] [float] NOT NULL
		,[DeliveryLatency] [int] NOT NULL
		,[TotalCommandsDeliveredSinceSubscriptionSetup] [int] NOT NULL
		,[SequenceNumber] [varbinary](16) NULL
		,[LastDistributerSync] [datetime] NULL
		,[Retention] [int] NULL
		,[WorstLatency] [int] NULL
		,[BestLatency] [int] NULL
		,[AverageLatency] [int] NULL
		,[CurrentLatency] [int] NULL
		) 
	 
	INSERT INTO @ReplStats
	SELECT da.[name] as [DistributionAgentName]
		,dh.[start_time] as [DistributionAgentStartTime]
		,dh.[duration] as [DistributionAgentRunningDurationInSeconds]
		,md.[isagentrunningnow] as [IsAgentRunning]
		,CASE md.[status]
			WHEN 1 THEN 'Started'
			WHEN 2 THEN 'Succeeded'
			WHEN 3 THEN 'InProgress'
			WHEN 4 THEN 'Idle'
			WHEN 5 THEN 'Retrying'
			WHEN 6 THEN 'Failed'
			END as [ReplicationStatus]
		,dh.[time] as [LastSynchronized]
		--,dh.[comments] as [Comments]
		,md.[publisher] as [Publisher]
		,da.[publication] as [PublicationName]
		,da.[publisher_db] as [PublisherDB]
		,CASE
			WHEN da.[anonymous_subid] IS NOT NULL
				THEN UPPER(da.[subscriber_name])
			ELSE UPPER(s.[name])
			END as [Subscriber]
		,da.[subscriber_db] as [SubscriberDB]
		,CASE da.[subscription_type]
			WHEN '0' THEN 'Push'
			WHEN '1' THEN 'Pull'
			WHEN '2' THEN 'Anonymous'
			ELSE CAST(da.[subscription_type] as [varchar](64))
			END as [SubscriptionType]
		,md.[distdb] as [DistributionDB]
		,ma.[article] as [Article]
		,ds.[UndelivCmdsInDistDB]
		,ds.[DelivCmdsInDistDB]
		,dh.[current_delivery_rate] as [CurrentSessionDeliveryRate]
		,dh.[current_delivery_latency] as [CurrentSessionDeliveryLatency]
		,dh.[delivered_transactions] as [TotalTransactionsDeliveredInCurrentSession]
		,dh.[delivered_commands] as [TotalCommandsDeliveredInCurrentSession]
		,dh.[average_commands] as [AverageCommandsDeliveredInCurrentSession]
		,dh.[delivery_rate] as [DeliveryRate]
		,dh.[delivery_latency] as [DeliveryLatency]
		,dh.[total_delivered_commands] as [TotalCommandsDeliveredSinceSubscriptionSetup]
		,dh.[xact_seqno] as [SequenceNumber]
		,md.[last_distsync] as [LastDistributerSync]
		,md.[retention] as [Retention]
		,md.[worst_latency] as [WorstLatency]
		,md.[best_latency] as [BestLatency]
		,md.[avg_latency] as [AverageLatency]
		,md.[cur_latency] as [CurrentLatency]
	    
	FROM [distribution]..[MSdistribution_status] ds
	INNER JOIN [distribution]..[MSdistribution_agents] da
		ON da.[id] = ds.[agent_id]
	INNER JOIN [distribution]..[MSArticles] ma
		ON ma.publisher_id = da.publisher_id
			AND ma.[article_id] = ds.[article_id]
	INNER JOIN [distribution]..[MSreplication_monitordata] md 
		ON [md].[job_id] = da.[job_id]
	INNER JOIN [distribution]..[MSdistribution_history] dh
		ON [dh].[agent_id] = md.[agent_id]
			AND md.[agent_type] = 3
	INNER JOIN [master].[sys].[servers] s 
		ON s.[server_id] = da.[subscriber_id]

	WHERE da.[subscriber_db] <> 'virtual'
		AND da.[anonymous_subid] IS NULL
		AND dh.[start_time] = (
			SELECT TOP 1 start_time
			FROM [distribution]..[MSdistribution_history] a
			INNER JOIN [distribution]..[MSdistribution_agents] b ON a.[agent_id] = b.[id]
				AND b.[subscriber_db] <> 'virtual'
			WHERE [runstatus] <> 1
			ORDER BY [start_time] DESC
			)
		AND dh.[runstatus] <> 1

	----------------------
	-- Publications

	INSERT INTO #Audit
		SELECT TOP 10
			@HostName
			,'ReplInfo'
			,CASE
				WHEN [Publisher] = @HostName THEN [PublisherDB]
				WHEN [Subscriber] = @HostName THEN [SubscriberDB]
				ELSE '?'
			END	-- DB				
			,'Backlog: ' + CAST(SUM([UndelivCmdsInDistDB]) as varchar(15))
			, + CASE
					WHEN [Publisher] = @HostName THEN '*'
					ELSE ''
				END 
					+ 'Publisher: ' + [Publisher]
				+ @delimiter + 'Publication: ' + [PublicationName]
				+ @delimiter + 'PubDB: ' + [PublisherDB]
				+ @delimiter + CASE
									WHEN [Subscriber] = @HostName THEN '*'
									ELSE ''
								END
									+ 'Subscriber: ' + [Subscriber]
				+ @delimiter + 'SubDB: ' + [SubscriberDB]
				+ @delimiter + 'SubType: ' + [SubscriptionType]
				+ @delimiter + 'Status: ' + [ReplicationStatus] 
				+ @delimiter + 'Delivered: ' + CAST(SUM([DelivCmdsInDistDB]) as varchar(15))
			,70 -- results pos
			,@now
		FROM @ReplStats
		GROUP BY 
			[Publisher]
			,[PublicationName]
			,[PublisherDB]
			,[Subscriber]
			,[SubscriberDB]
			,[SubscriptionType]
			,[DistributionDB]
			,[ReplicationStatus]
	
END ----------------------

IF @MajorVersion >= 9
	AND OBJECT_ID('msdb.dbo.sysreplicationalerts') IS NOT NULL 
BEGIN
	--Repl alerts

	INSERT INTO #Audit
		SELECT TOP 10
			@HostName
			,'ReplInfo'
			,CASE
				WHEN [Publisher] = @HostName THEN ra.publisher_db
				WHEN [Subscriber] = @HostName THEN ra.subscriber_db
				ELSE '?'
			END	-- DB	
			,'*CHECK*'
			,'Time: ' + CAST(ra.[time] as varchar(20))
			+ @delimiter + CASE
								WHEN ra.publisher = @HostName THEN '*'
								ELSE ''
							END
							+ 'Publisher: ' + ra.publisher
			+ @delimiter + 'Publication: ' + ra.publication
			+ @delimiter + 'PubDB: ' + ra.publisher_db
			+ @delimiter + 'AgentType: '
				+ CASE ra.[agent_type]
					WHEN 1 THEN 'Snapshot'
					WHEN 2 THEN 'LogReader'
					WHEN 3 THEN 'Distribution'
					WHEN 4 THEN 'Merge'
					ELSE '?'
				END
			+ @delimiter + CASE
								WHEN ra.subscriber = @HostName THEN '*'
								ELSE ''
							END
							+ 'Subscriber: ' + ra.subscriber
			+ @delimiter + 'SubDB: ' + ra.subscriber_db
			+ @delimiter + 'Article: ' + ra.article
			+ @delimiter + 'Error: ' + CAST(ra.alert_error_text as nvarchar(128))
			,75 -- results pos
			,@now
		FROM msdb.dbo.sysreplicationalerts ra
		WHERE DATEDIFF(hour, ra.[time], getdate()) <= 24
			AND ra.alert_error_text NOT LIKE '%succe%'
		ORDER BY ra.[time] DESC
END ----------------------

------------------------------------------
------------------------------------------
-- Display results

SELECT InstanceName
		,CAST(TestDateRun as varchar(20)) as 'DateRun'
		, TestType
		, DBName
		, [Status]
		, TestOutput
FROM #Audit
ORDER BY ViewOrder, TestType

------------------------------------------
-- Tidy up

IF OBJECT_ID('tempdb..#Audit') IS NOT NULL 
	DROP TABLE #Audit

IF OBJECT_ID('tempdb..#data') IS NOT NULL 
	DROP TABLE #data

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_Help_BackupMethod]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_Help_BackupMethod] (@GenAlert bit = 0)
AS

/****************************************************************************************
// @File: usp_Help_BackupMethod.SQL
//
// @Version 6.0.0.30
//
// Purpose: Audit Report detailing the configured MWE backup methods
//		TRR - @GenAlert=1 will raise a warning event if a DBs Subclient is incorrectly configured 
//
// Notes: This stored procedure called from usp_UBSMWE_Engine and can be run by hand
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 13/08/2014 @Author: Chris Basson @Version: 6.0.0.2 @Action: TRRv3 BETA
//   @Date: 19/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 BETA
//   @Date: 21/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 BETA
//   @Date: 04/09/2014 @Author: Chris Basson @Version: 6.0.0.6 @Action: TRRv3 BETA
//   @Date: 10/09/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 BETA
//   @Date: 27/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 BETA
//   @Date: 31/10/2014 @Author: Chris Basson @Version: 6.0.0.9 @Action: TRRv3 BETA
//   @Date: 05/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3
//   @Date: 30/01/2014 @Author: Chris Basson @Version: 6.0.0.22 @Action: Minor update
//   @Date: 04/02/2014 @Author: Chris Basson @Version: 6.0.0.23 @Action: Minor update - include warm standbys, no_full exclusion
//   @Date: 29/05/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: TRR-137; bugfix usp_Help_BackupMethod raises an alert for disabled CV schedule if Sunday workflow is running

****************************************************************************************/

BEGIN -- main
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@RC int
	,@dbsBackupProcessor tinyint
	,@CV_Parallel_Ops bit
	,@CV_Enabled bit
	,@NB_Enabled bit
	,@IncludeReadOnlyBackups bit
	,@DBName nvarchar(128)
	,@DBStatus nvarchar(15)
	,@IsInStandBy bit
	,@RecoveryModel nvarchar(12)
	,@Logshipped char(1)
	,@IsSystem bit
	,@Exclusion nvarchar(20)
	,@ExActive bit
	,@FULLBackuptype nvarchar(128)
	,@TLogBackuptype nvarchar(128)
	,@DefaultSubclient nvarchar(128)
	,@ActualSubclient nvarchar(128)
	,@AlertMsg nvarchar(255)
	,@Alert bit
	,@CVClient nvarchar(128) 
	,@CVInstance nvarchar(128) 
	,@CVSchedulePolicy nvarchar(64) 
	,@CVScheduleEnabled bit
	,@TodaysScheduleOut smalldatetime
	,@IDXRebldstatus bit
	,@blockalert bit
	,@AOnode bit
	,@AOPrim bit

DECLARE @BackupMethod TABLE (
			DBName nvarchar(128)
			,DBStatus nvarchar(15)
			,IsInStandBy bit
			,RecoveryModel nvarchar(12)
			,Logshipped char(1)
			,IsSystem bit
			,Exclusion nvarchar(20)
			,ExActive bit
			,FULLBackuptype nvarchar(128)
			,TLogBackuptype nvarchar(128)
			,DefaultSubclient nvarchar(128)
			,ActualSubclient nvarchar(128)
			,CVSchedulePolicy nvarchar(64)
			,CVScheduleEnabled bit
			,Alert bit ) 

-----------------------------------
-- Get config:

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Parallel_Ops', @CV_Parallel_Ops OUTPUT
IF @RC <> 0
	SET @CV_Parallel_Ops = 0

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT
IF @RC <> 0
	SET @CV_Enabled = 0

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT
IF @RC <> 0
	SET @NB_Enabled = 0

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IncludeReadOnlyBackups', @IncludeReadOnlyBackups OUTPUT
IF @RC <> 0
	SET @IncludeReadOnlyBackups = 0

IF [DBServices].[dbo].[ufn_InstanceMajorVersion] () >= 11
	SET @AOnode = CAST(SERVERPROPERTY ('IsHadrEnabled') as bit)
ELSE
	SET @AOnode = 0
	
-----------------------------------
-- Get DB Details:

PRINT 'dbsBackupProcessor: ' + CAST (@dbsBackupProcessor as char(1)) + char(13)

IF @dbsBackupProcessor IN (4,5)	-- TRR: ensure local Subclient and CV Schedule data is upto date 
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
												,@CVInstance = @CVInstance OUTPUT 

	DECLARE @hideout TABLE (astr nvarchar(128))
	INSERT INTO @hideout
		EXEC @RC = [DBServices].[dbo].[usp_CVList] @CVClient = @CVClient, @CVInstance = @CVInstance, @Quiet=1, @Force=0

	IF @RC <> 0
	BEGIN
		PRINT char(13) + 'UBSMWE: [usp_Help_BackupMethod]: ERROR whilst executing dependancy usp_CVList - exiting'
		RETURN 0 -- Return success as sp called from engine
	END

	IF @dbsBackupProcessor = 5
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_CVSchedule_List] @CVInstance = @CVInstance, @Quiet = 1
		IF @RC <> 0
		BEGIN
			PRINT char(13) + 'UBSMWE: [usp_Help_BackupMethod]: ERROR whilst executing dependancy usp_CVSchedule_List - exiting'
			RETURN 0 -- Return success as sp called from engine
		END
	END
END

-----------------------------------

SET @blockalert = 0

-- Check if idx rebuild task running
IF EXISTS (SELECT TOP 1 1
FROM [DBServices].[dbo].[WorkFlowTask]
WHERE [WFTaskTypeID] = 4	-- UBSMWE_WFST_IDXReBld
	AND [WFTaskEnabled] = 1
	AND [WFTaskIsRunningFlag] = 1)
	SET @IDXRebldstatus = 1
ELSE
	SET @IDXRebldstatus = 0

-----------------------------------

INSERT INTO @BackupMethod
SELECT 
	sd.[name]
	,CASE
		WHEN is_read_only = 1 THEN 'READ_ONLY'
		ELSE sd.state_desc
	END as 'state_desc'
	,ISNULL(sd.is_in_standby,0) as 'IsInStandBy'
	,sd.recovery_model_desc as 'RecoveryModel'
	,CASE
		WHEN EXISTS (SELECT 1
						FROM msdb.dbo.log_shipping_primary_databases
						WHERE primary_database = db.[dbsDatabaseName]) THEN 'P'
		WHEN EXISTS (SELECT 1 
						FROM msdb.dbo.log_shipping_secondary
						WHERE primary_database = db.[dbsDatabaseName]) THEN 'S'
		ELSE '-'
	END as 'Logshipped'
	,db.dbsDatabaseIsSystemObjectFlag
	,CASE 
		WHEN @dbsBackupProcessor = 5
			AND dbe.[dbsDatabaseExceptionSubType] = 'external'
			AND dbe.dbsExceptionActive = 1 THEN 'external'
		WHEN @dbsBackupProcessor <> 5
			AND dbe.[dbsDatabaseExceptionSubType] = 'full' THEN 'Local_FULL'
		WHEN @dbsBackupProcessor < 4
			AND dbe.[dbsDatabaseExceptionSubType] = 'partial' THEN 'Local_PARTIAL'
		WHEN @dbsBackupProcessor < 4 
			AND dbe.[dbsDatabaseExceptionSubType] = 'differential' THEN 'Local_DIFF'
		WHEN @dbsBackupProcessor <> 5 
			AND dbe.[dbsDatabaseExceptionSubType] = 'transaction_log' THEN 'Local_TLog'
		WHEN ((@dbsBackupProcessor IN (4,5) AND @CV_Enabled = 1)
			 OR (@dbsBackupProcessor < 4 AND @NB_Enabled = 1))
			AND dbe.[dbsDatabaseExceptionType] = 'filesystem' 
			AND dbe.dbsExceptionActive = 1 THEN 'Filesystem'
		WHEN @dbsBackupProcessor = 5
			AND dbe.[dbsDatabaseExceptionSubType] LIKE 'updatestats%' 
			AND dbe.dbsExceptionActive = 1 THEN dbe.[dbsDatabaseExceptionSubType]
		WHEN dbe.[dbsDatabaseExceptionSubType] IN ('indexrebuild', 'no_full')
			AND dbe.dbsExceptionActive = 1 THEN dbe.[dbsDatabaseExceptionSubType]
		ELSE '-'
	END as 'ExceptionType'
	,dbe.dbsExceptionActive
	,NULL -- FULLBackuptype later determined
	,NULL -- TLogBackuptype later determined
	,NULL -- DefaultSubclient later determined
	,ISNULL(cvsub.dbsSubclientName,'-') -- ActualSubclient later determined
	,'-' -- CVSchedulePolicy later determined
	,0 -- CVScheduleEnabled later determined
	,0 -- Alert later determined

FROM master.sys.databases sd 
LEFT OUTER JOIN DBServices.dbo.dbsDatabase db
	ON db.dbsDatabasedbid = sd.database_id 
LEFT OUTER JOIN DBServices.dbo.dbsCVSubclients cvsub
	ON cvsub.dbsDatabaseUID = db.dbsDatabaseUID
LEFT OUTER JOIN DBServices.dbo.dbsDatabaseException dbe
	ON dbe.dbsDatabaseUID = db.dbsDatabaseUID
WHERE sd.[name] <> 'tempdb'
	AND (db.dbsDatabaseIsActive = 1
		 OR sd.is_in_standby = 1)  
ORDER BY dbe.dbsDatabaseExceptionID DESC

-----------------------------------
-- Determine Backup Methods

DECLARE bakmethod_cur CURSOR LOCAL DYNAMIC SCROLL_LOCKS
FOR SELECT *
FROM @BackupMethod
FOR UPDATE
OPEN bakmethod_cur

FETCH NEXT FROM bakmethod_cur
	INTO @DBName 
		,@DBStatus 
		,@IsInStandBy 
		,@RecoveryModel
		,@Logshipped
		,@IsSystem
		,@Exclusion 
		,@ExActive 
		,@FULLBackuptype 
		,@TLogBackuptype
		,@DefaultSubclient 
		,@ActualSubclient 
		,@CVSchedulePolicy
		,@CVScheduleEnabled
		,@Alert

WHILE @@FETCH_STATUS = 0
BEGIN

	-- Determine Backuptypes

	UPDATE @BackupMethod
	SET FULLBackuptype = 
		CASE
			WHEN @Exclusion = 'no_full' AND @ExActive = 1 THEN '-'
			WHEN @dbsBackupProcessor = 1 AND @DBStatus = 'ONLINE' THEN 'Local SQL Native uncompressed'
			WHEN @dbsBackupProcessor = 1 AND @DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0 THEN 'Local SQL Native uncompressed'
			WHEN @dbsBackupProcessor = 1 AND @DBStatus <> 'ONLINE' AND NOT (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0) THEN '-'

			WHEN @dbsBackupProcessor = 2 AND @DBStatus = 'ONLINE' THEN 'Local LiteSpeed compressed'
			WHEN @dbsBackupProcessor = 2 AND @DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0 THEN 'Local LiteSpeed compressed'
			WHEN @dbsBackupProcessor = 2 AND @DBStatus <> 'ONLINE' AND NOT (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0) THEN '-'

			WHEN @dbsBackupProcessor = 3 AND @DBStatus = 'ONLINE' THEN 'Local SQL 2008+ compressed'
			WHEN @dbsBackupProcessor = 3 AND @DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0 THEN 'Local SQL 2008+ compressed'
			WHEN @dbsBackupProcessor = 3 AND @DBStatus <> 'ONLINE' AND NOT (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0) THEN '-'

			WHEN @dbsBackupProcessor = 4 AND @DBStatus = 'ONLINE' THEN 'CV SQL iDA'
			WHEN @dbsBackupProcessor = 4 AND @DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0 THEN 'CV SQL iDA'
			WHEN @dbsBackupProcessor = 4 AND @DBStatus <> 'ONLINE' AND NOT (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0) THEN '-'

			WHEN @dbsBackupProcessor = 5 AND @DBStatus = 'ONLINE' AND @Exclusion <> 'external' THEN 'CV Scheduled SQL iDA'
			WHEN @dbsBackupProcessor = 5 AND @DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0 THEN 'CV Scheduled SQL iDA'
			WHEN @dbsBackupProcessor = 5 AND @DBStatus = 'ONLINE' AND (@Exclusion = 'external' AND @ExActive = 1) THEN 'Local SQL Native'
			WHEN @dbsBackupProcessor = 5 AND @DBStatus <> 'ONLINE' AND NOT (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0) THEN '-'

			ELSE '** Unknown **'
		END ---------------------
	,TLogBackuptype = 
		CASE
			WHEN @Exclusion = 'no_full' AND @ExActive = 1 THEN '-'
			WHEN @dbsBackupProcessor IN (1,2,3,4,5) AND @DBStatus <> 'ONLINE' THEN '-'
			WHEN @RecoveryModel = 'SIMPLE' THEN '-'
			WHEN @dbsBackupProcessor = 1 AND @DBStatus = 'ONLINE' THEN 'Local SQL Native uncompressed'
			WHEN @dbsBackupProcessor = 2 AND @DBStatus = 'ONLINE' THEN 'Local LiteSpeed compressed'
			WHEN @dbsBackupProcessor = 3 AND @DBStatus = 'ONLINE' THEN 'Local SQL 2008+ compressed'

			WHEN @dbsBackupProcessor = 4 AND @DBStatus = 'ONLINE' AND (@CV_Parallel_Ops <> 1 AND @Logshipped = '-') THEN 'Local CV SQL iDA'
			WHEN @dbsBackupProcessor = 4 AND @DBStatus = 'ONLINE' AND (@CV_Parallel_Ops = 1 OR @Logshipped <> '-') THEN 'Local SQL Native'

			WHEN @dbsBackupProcessor = 5 AND @DBStatus = 'ONLINE' AND (@Exclusion <> 'external' AND @Logshipped = '-') THEN 'CV Scheduled SQL Native'
			WHEN @dbsBackupProcessor = 5 AND @DBStatus = 'ONLINE' AND (@Exclusion <> 'external' AND @Logshipped <> '-') THEN 'Local SQL Native'
			WHEN @dbsBackupProcessor = 5 AND @DBStatus = 'ONLINE' AND (@Exclusion = 'external' AND @ExActive = 1) THEN 'Local SQL Native'

			ELSE '** Unknown **'
		END
	WHERE CURRENT OF bakmethod_cur

	-----------------------------------
	-- Update Backuptypes to include FS 

	UPDATE @BackupMethod
	SET FULLBackuptype = FULLBackuptype + 
		CASE
			WHEN @Exclusion = 'no_full' AND @ExActive = 1 THEN ''
			WHEN FULLBackuptype LIKE 'Local SQL Native%' AND @CV_Enabled = 1 THEN ' + CV FS iDA'
			WHEN FULLBackuptype LIKE 'Local SQL Native%' AND @CV_Enabled = 0 AND @NB_Enabled = 1 THEN ' + Netbackup'
			WHEN FULLBackuptype LIKE 'Local SQL Native%' AND @CV_Enabled = 0 AND @NB_Enabled = 0 THEN ' - No OffSite'

			WHEN FULLBackuptype = 'Local LiteSpeed compressed' AND @CV_Enabled = 1 THEN ' + CV FS iDA'
			WHEN FULLBackuptype = 'Local LiteSpeed compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 1 THEN ' + Netbackup'
			WHEN FULLBackuptype = 'Local LiteSpeed compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 0 THEN ' - No OffSite'

			WHEN FULLBackuptype = 'Local SQL 2008+ compressed' AND @CV_Enabled = 1 THEN ' + CV FS iDA'
			WHEN FULLBackuptype = 'Local SQL 2008+ compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 1 THEN ' + Netbackup'
			WHEN FULLBackuptype = 'Local SQL 2008+ compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 0 THEN ' - No OffSite'

			ELSE ''
		END ---------------------
		,TLogBackuptype = TLogBackuptype + 
		CASE
			WHEN @Exclusion = 'no_full' AND @ExActive = 1 THEN ''
			WHEN @DBStatus <> 'ONLINE' THEN ''

			WHEN TLogBackuptype LIKE 'Local SQL Native%' AND @CV_Enabled = 1 THEN ' + CV FS iDA'
			WHEN TLogBackuptype LIKE 'Local SQL Native%' AND @CV_Enabled = 0 AND @NB_Enabled = 1 THEN ' + Netbackup'
			WHEN TLogBackuptype LIKE 'Local SQL Native%' AND @CV_Enabled = 0 AND @NB_Enabled = 0 THEN ' - No OffSite'

			WHEN TLogBackuptype = 'Local LiteSpeed compressed' AND @CV_Enabled = 1 THEN ' + CV FS iDA'
			WHEN TLogBackuptype = 'Local LiteSpeed compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 1 THEN ' + Netbackup'
			WHEN TLogBackuptype = 'Local LiteSpeed compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 0 THEN ' - No OffSite'

			WHEN TLogBackuptype = 'Local SQL 2008+ compressed' AND @CV_Enabled = 1 THEN ' + CV FS iDA'
			WHEN TLogBackuptype = 'Local SQL 2008+ compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 1 THEN ' + Netbackup'
			WHEN TLogBackuptype = 'Local SQL 2008+ compressed' AND @CV_Enabled = 0 AND @NB_Enabled = 0 THEN ' - No OffSite'

			WHEN TLogBackuptype = 'CV Scheduled SQL Native' THEN ' + CV FS iDA'

			ELSE ''
		END
	WHERE CURRENT OF bakmethod_cur

	-----------------------------------
	-- Determine default Subclient

	UPDATE @BackupMethod
	SET DefaultSubclient = 
		CASE
			WHEN @dbsBackupProcessor = 5 AND (@Exclusion = 'external' AND @ExActive = 1) THEN '-'

			WHEN @dbsBackupProcessor IN (1,2,3,4,5) AND (@RecoveryModel = 'SIMPLE' OR @Logshipped <> '-') THEN 'SIMPLE'
			WHEN @dbsBackupProcessor IN (1,2,3,4,5) AND (@RecoveryModel IN ('FULL','BULK_LOGGED') AND @Logshipped = '-') THEN 'TRANSACTIONAL'

			ELSE '** Unknown **'
		END
	WHERE CURRENT OF bakmethod_cur
	-----------------------------------
	--Determine CV Schedule
	--and alert based on CV Schedule data

	IF @AOnode = 1
		SET @AOPrim = sys.fn_hadr_backup_is_preferred_replica(@DBName)
	ELSE
		SET @AOPrim = 1

	IF @dbsBackupProcessor = 5
		AND (@DBStatus = 'ONLINE'
			OR (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0))
		AND NOT(@Exclusion = 'external' AND @ExActive = 1)  
		AND NOT(@Exclusion = 'no_full' AND @ExActive = 1) 
		AND @AOPrim = 1  -- primary 
	BEGIN

		SELECT @CVSchedulePolicy = cvs.CVSchedulePolicy
				,@CVScheduleEnabled = cvs.[Enabled]
		FROM [DBServices].[dbo].[dbsCVSchedule] cvs
		WHERE cvs.CVSubclient = @ActualSubclient  

		IF ISNULL(@CVSchedulePolicy,'') <> ''
		BEGIN
			EXEC @RC = [DBServices].[dbo].[usp_CVSchedulePolicyDecode]
						@CVSchedulePolicy = @CVSchedulePolicy
						,@TodaysScheduleOut = @TodaysScheduleOut OUTPUT

			IF @RC = 0
				AND (@IDXRebldstatus = 1) 
				AND (ABS(DATEDIFF(minute, getdate(), @TodaysScheduleOut)) > 15)
				SET @blockalert = 1 -- latch
		END -------------------
					
		UPDATE @BackupMethod
 		SET bm.CVSchedulePolicy = ISNULL(@CVSchedulePolicy,'-')
			,bm.CVScheduleEnabled = @CVScheduleEnabled
			,bm.Alert = CASE	
						WHEN (@Logshipped = 'P') AND (@CVSchedulePolicy LIKE '%-WLOGS%') THEN 1 -- Should be in a subclient with a -NOLOGS schedule
						WHEN (bm.FULLBackuptype = 'CV Scheduled SQL iDA') AND (@CVScheduleEnabled = 0) AND (@blockalert = 0) THEN 1
						WHEN (bm.TLogBackuptype = 'CV Scheduled SQL Native') AND (@CVScheduleEnabled = 0) AND (@blockalert = 0) THEN 1
						WHEN ISNULL(@CVSchedulePolicy,'') = '' THEN 1
						ELSE 0
					 END	
		FROM @BackupMethod bm
		WHERE CURRENT OF bakmethod_cur
	END ---------------------

	-----------------------------------
	-- Verify Subclient and alert accordingly

	IF @dbsBackupProcessor IN (4,5)
		AND (@DBStatus = 'ONLINE'
			OR (@DBStatus = 'READ_ONLY' AND @IncludeReadOnlyBackups = 1 AND @IsInStandBy = 0))
		AND NOT(@Exclusion = 'external' AND @ExActive = 1)
		AND NOT(@Exclusion = 'no_full' AND @ExActive = 1)
		AND @AOPrim = 1  -- primary  
	BEGIN
		UPDATE @BackupMethod
		SET Alert = CASE
						WHEN bm.Alert = 1 THEN 1 -- Keep alert setting if already triggered
						WHEN (bm.ActualSubclient LIKE '%' + bm.DefaultSubclient + '%') THEN 0 -- SIMPLE / TRANSACTIONAL
						WHEN (bm.ActualSubclient LIKE '%' + LEFT(@DBName,50) + '%') THEN 0	-- SINGLE
						WHEN (bm.ActualSubclient LIKE '%GROUP%') THEN 0  -- GROUP 
					ELSE 1
					END 
		FROM @BackupMethod bm
		WHERE CURRENT OF bakmethod_cur
	END

	FETCH NEXT FROM bakmethod_cur
		INTO @DBName 
			,@DBStatus 
			,@IsInStandBy 
			,@RecoveryModel
			,@Logshipped
			,@IsSystem
			,@Exclusion 
			,@ExActive 
			,@FULLBackuptype 
			,@TLogBackuptype
			,@DefaultSubclient 
			,@ActualSubclient
			,@CVSchedulePolicy
			,@CVScheduleEnabled
			,@Alert
END

CLOSE bakmethod_cur
DEALLOCATE bakmethod_cur

-- Display report
PRINT char(13) 
PRINT 'BackupMethod Report:' + char(13) 

IF @dbsBackupProcessor IN (1,2,3)
	SELECT 
		DBName 
		,DBStatus 
		,CASE IsInStandBy 
			WHEN 1 THEN 'Y'
			ELSE '-'
		END as 'IsInStandBy'
		,RecoveryModel
		,Logshipped
		,CASE IsSystem 
			WHEN 1 THEN 'Y'
			ELSE '-'
		END as 'IsSystem' 
		,Exclusion 
		,CASE
			WHEN Exclusion = '-' THEN '-' 
			WHEN Exclusion <> '-' AND ExActive = 0 THEN 'N'
			WHEN Exclusion <> '-' AND ExActive = 1 THEN 'Y'
			ELSE '-'
		END as 'ExActive'
		,FULLBackuptype 
		,TLogBackuptype
		,DefaultSubclient 
	FROM @BackupMethod
	ORDER BY IsSystem,DBName
ELSE ------------------- @dbsBackupProcessor IN (4,5)
	SELECT 
		DBName 
		,DBStatus 
		,CASE IsInStandBy 
			WHEN 1 THEN 'Y'
			ELSE '-'
		END as 'IsInStandBy'
		,RecoveryModel
		,Logshipped
		,CASE IsSystem 
			WHEN 1 THEN 'Y'
			ELSE '-'
		END as 'IsSystem'
		,Exclusion 
		,CASE
			WHEN Exclusion = '-' THEN '-' 
			WHEN Exclusion <> '-' AND ExActive = 0 THEN 'N'
			WHEN Exclusion <> '-' AND ExActive = 1 THEN 'Y'
			ELSE '-'
		END as 'ExActive'
		,FULLBackuptype 
		,TLogBackuptype
		,DefaultSubclient 
		,ActualSubclient
		,CVSchedulePolicy
		,CASE CVScheduleEnabled
			WHEN 1 THEN 'Y'
			ELSE '-'
		 END AS 'CVScheduleEnabled'
		,CASE Alert
			WHEN 1 THEN 'Y'
			ELSE '-'
		 END AS 'Alert'
	FROM @BackupMethod
	ORDER BY IsSystem,DBName

-- Gen alert if necessary
IF @GenAlert = 1 -- input param
	AND @dbsBackupProcessor IN (4,5)
	AND EXISTS (SELECT 1 FROM @BackupMethod WHERE Alert=1)
BEGIN
	SET @AlertMsg = 'UBSMWE: usp_Help_BackupMethod: Database(s) have been identified as being configured incorrectly at the CommServe back end; consequently backups may fail or not run!'
			+ ' - Run: DBServices..usp_Help_BackupMethod to investigate and contact Backup Services accordingly!'
	EXEC [DBServices].[dbo].[usp_LogEvent] @AlertMsg, 2		-- Warning
	RETURN 1
END
ELSE
	RETURN 0

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_Help_CVTLogBakStagingStatus]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_Help_CVTLogBakStagingStatus]
AS

BEGIN -- main

/****************************************************************************************
// @File: usp_Help_CVTLogBakStagingStatus.SQL
// 
// @Version 6.0.0.25
//
// Notes: User called; to read the CV SQL iDA reg key parameters
// for performing Transaction Log backups 
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 21/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 beta
//   @Date: 16/02/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.25 @Action: dependancy update
****************************************************************************************/

SET NOCOUNT ON

DECLARE	@RC int
		, @CV_SqlLogBackupStageFolder_out varchar(255) 
		, @CV_bTLBackupToFS_out  int 
		, @CV_backupFromFSForLog_out  int  
		, @CV_SqlLogBackupInterval_out int

SET @CV_SqlLogBackupStageFolder_out = NULL

EXEC @RC = [dbo].[usp_CVTLogBakStagingStatus] 
			@CV_SqlLogBackupStageFolder = @CV_SqlLogBackupStageFolder_out OUTPUT
			, @CV_bTLBackupToFS = @CV_bTLBackupToFS_out  OUTPUT
			, @CV_backupFromFSForLog = @CV_backupFromFSForLog_out  OUTPUT 
			, @CV_SqlLogBackupInterval = @CV_SqlLogBackupInterval_out OUTPUT

IF @RC = 0
BEGIN
	PRINT '----------------------------------------------------------------'
	PRINT 'CV TLog Backup Staging Reg Key Status:' + CHAR (13)
	PRINT 'backupFromFSForLog = ' + CAST (@CV_backupFromFSForLog_out as char(1))
	PRINT 'bTLBackupToFS = ' + CAST (@CV_bTLBackupToFS_out as char(1))
	PRINT 'SqlLogBackupStageFolder = ' + ISNULL(@CV_SqlLogBackupStageFolder_out, '*** Not Set! ***')
	PRINT 'TLogBackupInterval = ' + CAST (@CV_SqlLogBackupInterval_out as varchar(5)) 
	PRINT '----------------------------------------------------------------'
END

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_Help_FileBackup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_Help_FileBackup] @ManifestID bigint = NULL
									, @dbsNetbackupRunNumber int = NULL
AS

/****************************************************************************************
// @File: usp_Help_FileBackup.SQL
// @Version 6.0.0.29
// 
// Purpose:
//	Report on UBSMWE initiated file backup manifest status
//
// Notes: User sp
//
// History:
//
//   @Date: 10/14/2004 @Author: Kevin Wagner @Version: Beta General	@Action: Created
//   @Date: 27/02/2007 @Author: Kevin Wagner @Version: 2.5.2		@Action: Updated for issue #43 to reverse order of displayed Manifests.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 20/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Netbackup Rerun process change. Will now rerun under same Netbackup Manifest number.//
//   @Date: 25/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.5 @Action: TRRv3 Beta - sp renamed from usp_Help_Netbackup to usp_Help_FileBackup for CV
//   @Date: 19/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Refinement

****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@ActiveComputerName nvarchar(128)
	,@NB_Enabled bit
	,@CV_Enabled bit
	,@RC int

-------------------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT 

-------------------------------

SET @RC = 0

IF @NB_Enabled = 0
	AND @CV_Enabled = 0
BEGIN
	PRINT '*** FileSystem backups are not currently enabled on ' + @ActiveComputerName + '***'
		 + CHAR(13)
END

--Report on File backup operations 
IF @ManifestID IS NULL 
	AND @dbsNetbackupRunNumber IS NULL
BEGIN
	SELECT		
		nb.dbsNetbackupID,
		nbs.dbsNetbackupRunNumber, 
		nb.dbsNetbackupRequestStartDate, 
		nb.dbsNetbackupRequestEndDate, 
		nbs.dbsNetbackupFileListName, 
		nbs.dbsNetbackupLogName, 
		ISNULL(nb.dbsNetbackupExitStatus, '') as 'dbsNetbackupExitStatus', 
		nbs.dbsNetbackupStatus
	FROM DBServices.dbo.dbsNetbackup nb
	INNER JOIN DBServices.dbo.dbsNetbackupStatus nbs
		ON nb.dbsNetbackupID = nbs.dbsNetbackupID
	ORDER BY nb.dbsNetbackupID DESC, nbs.dbsNetbackupRunNumber DESC

END -------------------
ELSE
IF @ManifestID IS NOT NULL
	AND @dbsNetbackupRunNumber IS NULL
BEGIN
	SELECT @dbsNetbackupRunNumber = MAX(dbsNetbackupRunNumber)
	FROM dbo.dbsNetbackupStatus
	WHERE @ManifestID = dbsNetbackupID

	EXEC @RC = DBServices.dbo.usp_CheckNetbackupStatusDetail @ManifestID, 0, @dbsNetbackupRunNumber
END -------------------
ELSE
	EXEC @RC = DBServices.dbo.usp_CheckNetbackupStatusDetail @ManifestID, 0, @dbsNetbackupRunNumber

-------------------------------

RETURN @RC
END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_Help_WorkFlow]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_Help_WorkFlow] @WFName nvarchar(255) = NULL

AS
SET DATEFORMAT ymd
SET NOCOUNT ON
--[usp_CheckWorkFlowStatusDetail] @dbsWorkFlowID bigint = NULL
/****************************************************************************************
// @File: usp_Help_WorkFlow.SQL
// 
// Purpose:
//   Perform Backup to tape
//
// Notes: This stored procedure is used to describe the WorkFlow. 
//
// History:
//
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/
SET NOCOUNT ON
BEGIN  --Begin main()


	IF @WFName IS NULL 

		BEGIN
			SELECT     WorkFlow.WFName, WorkFlow.WFPriority, WorkFlowJob.WFJobName, WorkFlowJob.WFJobFreq, WorkFlowJob.WFJobStartTime, 
						  WorkFlowManifest.WFManifestEnabled, WorkFlowTask.WFTaskName, WorkFlowTask.WFTaskEnabled, WorkFlowTask.WFTaskPriority, 
						  WorkFlowTask.WFTaskIsRunningFlag, WorkFlowTaskException.WFTaskExceptionStartDate, WorkFlowTaskException.WFTaskExceptionDurationDays, 
						  WorkFlowTaskException.WFTaskExceptionDurationMinutes, WorkFlowTaskException.WFTaskExceptionExists, 
						  WorkFlowTaskType.WFTaskTypeName, WorkFlowTaskType.WFTaskComment
			FROM         WorkFlowTaskException RIGHT OUTER JOIN
								  WorkFlowTask ON WorkFlowTaskException.WFTaskID = WorkFlowTask.WFTaskID LEFT OUTER JOIN
								  WorkFlowTaskType ON WorkFlowTask.WFTaskTypeID = WorkFlowTaskType.WFTaskTypeID RIGHT OUTER JOIN
								  WorkFlowManifest ON WorkFlowTask.WFTaskID = WorkFlowManifest.WFTaskID RIGHT OUTER JOIN
								  WorkFlow ON WorkFlowManifest.WFID = WorkFlow.WFID LEFT OUTER JOIN
								  WorkFlowJob LEFT OUTER JOIN
								  WorkFlowJobManifest ON WorkFlowJob.WFJobID = WorkFlowJobManifest.WFJobID ON 
								  WorkFlow.WFID = WorkFlowJobManifest.WFID LEFT OUTER JOIN
								  WorkFlowException ON WorkFlow.WFID = WorkFlowException.WFID
				ORDER BY WorkFlow.WFPriority, WorkFlowJob.WFJobName, WorkFlowTask.WFTaskPriority
		END
	ELSE
	IF  EXISTS (SELECT * FROM WorkFlow WHERE WFName =  @WFName)
		BEGIN --Report on named Workflow since we found valid workflow name.
				SELECT     WorkFlow.WFName, WorkFlow.WFPriority, WorkFlowJob.WFJobName, WorkFlowJob.WFJobFreq, WorkFlowJob.WFJobStartTime, 
							  WorkFlowManifest.WFManifestEnabled, WorkFlowTask.WFTaskName, WorkFlowTask.WFTaskEnabled, WorkFlowTask.WFTaskPriority, 
							  WorkFlowTask.WFTaskIsRunningFlag, WorkFlowTaskException.WFTaskExceptionStartDate, WorkFlowTaskException.WFTaskExceptionDurationDays, 
							  WorkFlowTaskException.WFTaskExceptionDurationMinutes, WorkFlowTaskException.WFTaskExceptionExists, 
							  WorkFlowTaskType.WFTaskTypeName, WorkFlowTaskType.WFTaskComment
				FROM         WorkFlowTaskException RIGHT OUTER JOIN
									  WorkFlowTask ON WorkFlowTaskException.WFTaskID = WorkFlowTask.WFTaskID LEFT OUTER JOIN
									  WorkFlowTaskType ON WorkFlowTask.WFTaskTypeID = WorkFlowTaskType.WFTaskTypeID RIGHT OUTER JOIN
									  WorkFlowManifest ON WorkFlowTask.WFTaskID = WorkFlowManifest.WFTaskID RIGHT OUTER JOIN
									  WorkFlow ON WorkFlowManifest.WFID = WorkFlow.WFID LEFT OUTER JOIN
									  WorkFlowJob LEFT OUTER JOIN
									  WorkFlowJobManifest ON WorkFlowJob.WFJobID = WorkFlowJobManifest.WFJobID ON 
									  WorkFlow.WFID = WorkFlowJobManifest.WFID LEFT OUTER JOIN
									  WorkFlowException ON WorkFlow.WFID = WorkFlowException.WFID
				WHERE		WorkFlow.WFName = @WFName
				ORDER BY WorkFlow.WFPriority, WorkFlowJob.WFJobName, WorkFlowTask.WFTaskPriority
		END


	ELSE
		BEGIN --Report that WorkFlow is not enabled on this box.
			PRINT 'Can not find entry for WorkFlow ' + @WFName
		END
END --End main()


GO
/****** Object:  StoredProcedure [dbo].[usp_hexadecimal]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_hexadecimal]
	@binvalue VARBINARY(256),
	@hexvalue VARCHAR(514)    OUTPUT
AS

	DECLARE @charvalue VARCHAR(514)
	DECLARE @i         INT
	DECLARE @length    INT
	DECLARE @hexstring CHAR(16)
	DECLARE @tempint   INT
	DECLARE @firstint  INT
	DECLARE @secondint INT

	-- This is the start of the output hex string
	SELECT @charvalue = '0x'
	SELECT @i         = 1
	SELECT @length    = DATALENGTH (@binvalue)
	SELECT @hexstring = '0123456789ABCDEF'

	WHILE (@i <= @length)
	BEGIN
		-- Get 1 Binary char pointed to by @i. The Max value is 255
		SELECT @tempint   = CONVERT(INT, SUBSTRING(@binvalue,@i,1))

		-- Divide the binary char by 16 and round down
		SELECT @firstint  = FLOOR(@tempint/16)

		-- Get the remainder after the binary char has been divided by 16
		SELECT @secondint = @tempint - (@firstint*16)

		-- The max binary value is 255 and this is represented by 2 hex chars.
		-- Locate the first and second hex chars from @hexstring and append to the output hex string
		SELECT @charvalue = @charvalue + SUBSTRING(@hexstring, @firstint+1, 1) + SUBSTRING(@hexstring, @secondint+1, 1)

		-- Increment the counter to pick up the next binary char
		SELECT @i         = @i + 1
	END

	-- Write the finished hex string to the output parameter
	SELECT @hexvalue = @charvalue

GO
/****** Object:  StoredProcedure [dbo].[usp_InsertdbsDatabaseBackupHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_InsertdbsDatabaseBackupHistory] 
						@dbsDatabaseUID uniqueidentifier,
						@dbsDBHIsLogFlag bit, 
						@dbsDBHStartDate datetime,
						@dbsDBHFileName nvarchar(255),
						@dbsDBackupProcessorID tinyint,
						@dbsDBHActiveComputerName nvarchar(128),
						@dbsDBHID bigint OUTPUT
AS
/****************************************************************************************
// @File: usp_InsertdbsDatabaseBackupHistory.SQL
// @Version: 6.0.0.13
// 
// Purpose:
//   Insert Current list of databases from master..sysdatabases into local work table
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Inception...
//   @Date: 31/08/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Updated code for backupset functionality, Added @dbsDBHParentID that will hold the Full Backup this log is related to. 
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Updated for MSSQLCentral Integration
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//	 @Date: 02/06/2009 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Update with MAXDOP hint
//	 @Date: 20/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//	 @Date: 08/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.6 @Action: TRRv3 Beta
//	 @Date: 21/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//	 @Date: 25/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int,
	@dbsInstanceFileLocation nvarchar(255),
	@dbsCVParallelOps bit,
	@CV_FSIncSysDB bit,
	@dbsDBHParentID bigint,
	@DBName nvarchar(128),
	@astr nvarchar(255),
	@IsSysDB bit,
	@DBExternalException bit,
	@FSExclusion bit,
	@dbsDBHIsOnDiskFlag bit,
	@dbsDBHSentToNBFlag bit

SET @DBExternalException = 0
SET @IsSysDB = 0

-------------------------------
-- Get config

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Parallel_Ops', @dbsCVParallelOps OUTPUT
IF @RC <> 0  
	RETURN 1 -- fail

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT
IF @RC <> 0  
	RETURN 1 -- fail

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_FSIncSysDB', @CV_FSIncSysDB OUTPUT
IF @RC <> 0  
	RETURN 1 -- fail

-------------------------------
-- TRRv3 - FS DB dump exceptions

IF @dbsDBackupProcessorID = 5
BEGIN
	SELECT @IsSysDB = db.dbsDatabaseIsSystemObjectFlag 	-- If system obj
	FROM DBServices.dbo.dbsDatabase db
	WHERE db.dbsDatabaseUID = @dbsDatabaseUID

	SELECT @DBExternalException = 1 -- If DB external exception
	FROM DBServices.dbo.dbsDatabaseException dbe
	WHERE dbe.dbsDatabaseUID = @dbsDatabaseUID
		AND dbe.dbsExceptionActive = 1
		AND dbe.dbsDatabaseExceptionType = 'backup'
		AND dbe.dbsDatabaseExceptionSubType = 'external'
END

SELECT @FSExclusion = 1 -- If filesystem exception
FROM DBServices.dbo.dbsDatabaseException dbe
WHERE dbe.dbsDatabaseUID = @dbsDatabaseUID
	AND dbe.dbsExceptionActive = 1
	AND dbe.dbsDatabaseExceptionType = 'filesystem'
		
-------------------------------
-- Insert into dbsDatabaseBackupHistory DO

IF @dbsDBHIsLogFlag = 1 
BEGIN
	SELECT @dbsDBHParentID = MAX(dbsDBHID) 
	FROM  dbsDatabaseBackupHistory 
	WHERE  dbsDatabaseUID = @dbsDatabaseUID
		AND dbsDBHIsLogFlag = 0
END
ELSE
	SET @dbsDBHParentID = NULL

SET @dbsDBHIsOnDiskFlag = CASE
							WHEN ISNULL(@dbsDBHFileName,'') = '' THEN 0 

							WHEN (@dbsDBackupProcessorID = 4 
									AND @dbsDBHIsLogFlag = 0) THEN 0

							WHEN (@dbsDBackupProcessorID = 4
									AND @dbsDBHIsLogFlag = 1 
									AND @dbsCVParallelOps = 0) THEN 0

							WHEN (@dbsDBackupProcessorID = 5 
									AND @dbsDBHIsLogFlag = 0 
									AND @DBExternalException = 0
									AND @IsSysDB = 0) THEN 0

							WHEN (@dbsDBackupProcessorID = 5
									AND @dbsDBHIsLogFlag = 1
									AND @dbsCVParallelOps = 0
									AND @DBExternalException = 0
									AND @IsSysDB = 0) THEN 0

							WHEN (@dbsDBackupProcessorID = 5 
									AND (@DBExternalException = 1
										OR @IsSysDB = 1) ) THEN 1 
							ELSE 1
						END

SET @dbsDBHSentToNBFlag = CASE
							WHEN (@dbsDBackupProcessorID = 4 
									AND @dbsDBHIsLogFlag = 0) THEN 1 -- skip archive dump to CV FS

							WHEN (@dbsDBackupProcessorID = 4
									AND @dbsDBHIsLogFlag = 1 
									AND @dbsCVParallelOps = 0) THEN 1 -- skip archive dump to CV FS

							WHEN (@dbsDBackupProcessorID = 5 
									AND @dbsDBHIsLogFlag = 0	-- DB
									AND (@DBExternalException = 0 
										OR (@IsSysDB = 1 AND @CV_FSIncSysDB = 0))
								) THEN 1	-- skip archive dump to CV FS

							WHEN (@dbsDBackupProcessorID = 5
									AND @dbsDBHIsLogFlag = 1	-- Tlog
									AND @dbsCVParallelOps = 0
									AND (@DBExternalException = 0 
										OR (@IsSysDB = 1 AND @CV_FSIncSysDB = 0)) 
								) THEN 1 -- skip archive dump to CV FS

							WHEN (@dbsDBackupProcessorID = 5 
								AND (@DBExternalException = 1 
									OR (@IsSysDB = 1 AND @CV_FSIncSysDB = 1))
								) THEN 0 -- archive dumps to CV FS

							WHEN @FSExclusion = 1 THEN 1 -- skip archive dump to FS

							ELSE 0 -- archive dumps to offsite FS
						END

BEGIN TRANSACTION 

INSERT INTO [DBServices].[dbo].[dbsDatabaseBackupHistory] (
	[dbsDatabaseUID], 
	[dbsDBHIsLogFlag], 
	[dbsDBHStartDate], 
	[dbsDBHFileName],
	[dbsDBHIsOnDiskFlag],
	[dbsDBackupProcessorID],
	[dbsDBHParentID],
	[dbsDBHActiveComputerName],
	[dbsDBHSentToNBFlag]
	)
SELECT @dbsDatabaseUID,
	@dbsDBHIsLogFlag, 
	@dbsDBHStartDate,
	@dbsDBHFileName,
	@dbsDBHIsOnDiskFlag, 
	@dbsDBackupProcessorID,
	@dbsDBHParentID,
	@dbsDBHActiveComputerName,
	@dbsDBHSentToNBFlag
	OPTION (MAXDOP 1) --Use MAXDOP option to do the insert... MS Bug

SET @RC = @@ERROR

IF @RC = 0
BEGIN
	SELECT @dbsDBHID = SCOPE_IDENTITY() OPTION (MAXDOP 1)

	COMMIT TRANSACTION
	RETURN 0
END
ELSE
BEGIN
	SELECT @DBName = db.dbsDatabaseName
	FROM DBServices.dbo.dbsDatabase db
	WHERE dbsDatabaseUID = @dbsDatabaseUID

	SET @astr = ISNULL(@DBName,'Unknown DB') + ': UBSMWE: usp_InsertdbsDatabaseBackupHistory: Error when inserting into dbsDatabaseBackupHistory, please check SQL log for more information.'
	EXEC [DBServices].[dbo].[usp_LogEvent] @astr, 2
  
	ROLLBACK TRANSACTION
	
	SET @dbsDBHID = NULL
	RETURN -1
END	  

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_InsertdbsDatabasePartialBackupHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_InsertdbsDatabasePartialBackupHistory] 

@dbsDatabaseUID						[uniqueidentifier],
@dbsDatabaseName					[sysname],
@dbsPartialBackupIsActiveFlag		[bit],
@dbsPartialBackupStartDate			[datetime] ,
@dbsPartialBackupEndDate			[datetime],
@dbsPartialBackupStatus				[int],
@dbsPartialBackupExitStep			[int],  
@dbsDBHFileName						nvarchar(255),
@dbsDBHActiveComputerName			nvarchar(255),
@dbsFGList					nvarchar(4000)
--@dbsDBHID bigint output

AS

/****************************************************************************************
// @File: usp_InsertdbsDatabasePartialBackupHistory.SQL
// 
// Purpose:
//  Record Partial Backup Statistics for analysis and ability to quickly create restore scripts
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//
//   @Date: 12/26/2010 @Author: Steve Trogub @Version: MWE 4.0X @Action: Inception...
//
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd

BEGIN TRANSACTION --Use MAXDOP option to do the insert... MS Bug
INSERT INTO [DBServices].[dbo].[dbsPartialBackupHistory]
	(
	[dbsDatabaseUID],
	[dbsDatabaseName],
	[dbsPartialBackupIsActiveFlag],
	[dbsPartialBackupStartDate] ,
	[dbsPartialBackupEndDate],
	[dbsPartialBackupStatus],
	[dbsPartialBackupExitStep],  
	[dbsDBHFileName],
	[dbsDBHActiveComputerName],
	[dbsFGList]
	)
SELECT 		 
	@dbsDatabaseUID,
	@dbsDatabaseName,
	@dbsPartialBackupIsActiveFlag,
	@dbsPartialBackupStartDate,
	@dbsPartialBackupEndDate,
	@dbsPartialBackupStatus,
	@dbsPartialBackupExitStep,  
	@dbsDBHFileName,
	@dbsDBHActiveComputerName,
	@dbsFGList
OPTION (MAXDOP 1)

IF @@ERROR = 0
BEGIN
	-- select SCOPE_IDENTITY(), IDENT_CURRENT('dbsPartialBackupHistory')
	-- select @dbsDBHID = SCOPE_IDENTITY() OPTION (MAXDOP 1)--IDENT_CURRENT('dbsPartialBackupHistory')
	
	COMMIT TRANSACTION
	RETURN 0
END
ELSE
BEGIN
	-- TODO: Set parameter values here.

	EXECUTE [DBServices].[dbo].[usp_LogErrors] 
	  @Source = 'usp_InsertdbsDatabasePartialBackupHistory'
	  ,@message = 'UBSMWE Error: when inserting into usp_InsertdbsDatabasePartialBackupHistory, please check SQL log for more information.'
	  ,@LogEvent = 1
	  ,@NeedAlertGenerated = 1
	  
	  ROLLBACK TRANSACTION
	  RETURN -1
END	  

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_InsertWorkFlowTaskHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_InsertWorkFlowTaskHistory] @WFTaskID uniqueidentifier, @WFTaskHistoryID bigint = NULL OUTPUT
AS

SET DATEFORMAT ymd

/****************************************************************************************
// @File: usp_InsertWorkFlowTaskHistory.SQL
// 
// Purpose:
//   Insert Current list of databases from master..sysdatabases into local work table
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//
//   @Date: 26/02/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//
****************************************************************************************/

BEGIN  --Begin main()

DECLARE @WFTaskStartDate datetime
		,@dbsDBHActiveComputerName nvarchar(255)

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @dbsDBHActiveComputerName OUTPUT

IF ISNULL(@dbsDBHActiveComputerName, '') = ''
	SET @dbsDBHActiveComputerName = CONVERT(sysname, SERVERPROPERTY('ServerName'))

INSERT INTO [DBServices].[dbo].[WorkFlowTaskHistory]
	( 
		[WFTaskID],
		[WFTaskStartDate],
		[WFTaskActiveComputerName]
	)
VALUES
	( @WFTaskID
		,getdate()
		,@dbsDBHActiveComputerName
	)

SET @WFTaskHistoryID = IDENT_CURRENT('WorkFlowTaskHistory')

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_isLogshipped]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_isLogshipped] @DatabaseName nvarchar(255), @ReturnValue nchar(1)  OUTPUT
AS

/****************************************************************************************
// @File: usp_isLogshipped.SQL
//
// @Version 6.0.0.12
//
// Purpose:
//   Returns P (Primary) or S (Secondary) if a given DB is logshipped
//
// Notes: 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 21/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 BETA
//   @Date: 21/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.12 @Action: TRRv3 RC1
****************************************************************************************/
BEGIN

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @sqlstr nvarchar(1000)
	, @permdef nvarchar(1000)

SET @ReturnValue = NULL

SET @sqlstr = N'
IF EXISTS (SELECT 1 
	FROM [msdb].[sys].[sysobjects] WITH (NOLOCK)
	WHERE [name] =''log_shipping_primary_databases'')
BEGIN
	SELECT @ReturnValueOUT = N''P'' 
	FROM [msdb].[dbo].[log_shipping_primary_databases]
	WHERE primary_database = ''' + @DatabaseName + '''
END
IF @ReturnValueOUT IS NULL 
	AND EXISTS (SELECT 1
						FROM [msdb].[sys].[sysobjects]  WITH (NOLOCK)
						WHERE [name] =''log_shipping_secondary_databases'')
BEGIN
	SELECT @ReturnValueOUT = N''S'' 
	FROM [msdb].[dbo].[log_shipping_secondary_databases]  WITH (NOLOCK)
	WHERE secondary_database = ''' + @DatabaseName + '''
END'

SET @permdef = N'@ReturnValueOUT nchar(1) OUTPUT'

EXEC sp_executesql @sqlstr, @permdef, @ReturnValueOUT=@ReturnValue OUTPUT

IF  @ReturnValue NOT IN (N'P',N'S') 
	OR @ReturnValue IS NULL
	SET @ReturnValue = N'N'
END

GO
/****** Object:  StoredProcedure [dbo].[usp_KillCVProcs]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_KillCVProcs](
@KillType		INT = NULL
) 

AS
BEGIN
DECLARE				 @procname nvarchar(25)
					,@pid nvarchar(9)
					,@cmd nvarchar(128)
					,@RC INT
					,@result nvarchar(20)
					,@dbsForceCVKill INT
					,@debug INT

--EXEC usp_ConfigureUBSMWE 'dbsForceCVKill', 1
		EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT
		EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsForceCVKill', @dbsForceCVKill OUTPUT
IF @RC <> 0 AND (@debug is NULL or @debug = 1) PRINT 'Error while getting output param for dbsStripeSet;'


IF @KillType IS NULL or @dbsForceCVKill = 0 SET @KillType = 0

IF @dbsForceCVKill = 0 SELECT 'dbsForceCVKill=0. Reseting to view only. Please set @dbsForceCVKill to 1 if you need to kill CV processes.'

CREATE TABLE #output(string nvarchar (500))

CREATE TABLE #worktasklist(taskname nvarchar (25)
						   ,pid		nvarchar(9)
						   ,status	nvarchar(12)
							)

 INSERT #output
  EXEC [master].[dbo].[xp_cmdshell] 'tasklist'
DELETE FROM #output WHERE string IS NULL OR string = 'Image Name' OR string LIKE '%Mem Usage' OR string LIKE '===%'

--kill cvbackup.exe only
IF @KillType = 1
BEGIN
 INSERT #worktasklist
SELECT 
	LTRIM(RTRIM(LEFT(string,25))) 
	,LTRIM(RTRIM(RIGHT(LEFT(string,34),9))) 
	,'running'
FROM 
	#output WHERE LTRIM(RTRIM(LEFT(string,25))) IN ('cvbackup.exe')
END

--kill cvbackup.exe only
IF @KillType = 2 OR @KillType = 0
BEGIN
 INSERT #worktasklist
SELECT 
	LTRIM(RTRIM(LEFT(string,25))) 
	,LTRIM(RTRIM(RIGHT(LEFT(string,34),9))) 
	,'running'
FROM 
	#output WHERE LTRIM(RTRIM(LEFT(string,25))) IN ('cvbackup.exe','cvrestore.exe', 'cvcfglist.exe')
END


IF @KillType = 0 GOTO ViewOnly

DECLARE kill_pids CURSOR FOR
	SELECT taskname, pid FROM #worktasklist

OPEN kill_pids

FETCH NEXT FROM kill_pids
INTO @procname, @pid
WHILE @@FETCH_STATUS = 0
 BEGIN
		SET @cmd = 'TASKKILL /F /t /pid ' + @pid 
		PRINT 'Killing:' + @procname + '-' + @pid
		DELETE FROM #output
		INSERT #output exec @RC = master..xp_cmdshell @cmd
			SELECT @result=string FROM #output WHERE string IS NOT NULL
		IF @RC = 0 AND CHARINDEX('SUCCESS:',@result) <> 0  
				BEGIN
					UPDATE #worktasklist SET status = 'KILLED' WHERE pid = @pid
					PRINT 'Successfuly killed:' + @procname + '-' + @pid
				END
		ELSE
				BEGIN
				RAISERROR ('Could not kill process!!!', 0, 1) WITH NOWAIT
				PRINT 'Failed Killing:' + @procname + '-' + @pid
				END

		FETCH NEXT FROM kill_pids
		INTO @procname, @pid
 END
CLOSE kill_pids
DEALLOCATE kill_pids

EXEC usp_ConfigureUBSMWE 'dbsForceCVKill', 0

ViewOnly:

SELECT * FROM #worktasklist

DROP TABLE #output
DROP TABLE #worktasklist



END

--End Main

GO
/****** Object:  StoredProcedure [dbo].[usp_LogErrors]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_LogErrors] 
(	@JobID		uniqueidentifier = NULL,
	@error_id   int=0,
	@Source    	varchar(128) = 'UBSMWE',
	@command    varchar(128)= NULL,
	@message    varchar(512) = 'N/A',
	@LogEvent	bit=0,
	@NeedAlertGenerated bit=1,
	@Level		tinyint = 1 -- 1 info, 2 warning, 3 Error
)	
						
AS
SET DATEFORMAT ymd
/************************************************************************************************
// @File:usp_LogErrors.SQL
// Purpose:	Logs errors for  WorkFlow jobs
//               
// Modification History:
// History: Date Format dd/mm/yyyy
//
//   @Date:25/01/2006 @Author:Rakesh Bist @Version: 1.5.3 @Action:Created
//   @Date:25/01/2006 @Author:Rakesh Bist @Version: 2.0 @Action:Added message to raise alerts in MOM.
//   @Date: 01/10/2006 @Author: Kevin Wagner @Version:2.0 @Action:Renamed file and stored procedure
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 17/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 BETA
************************************************************************************************/

BEGIN --Main

SET NOCOUNT ON
DECLARE @JobIDTEXT nvarchar(50)
	,@MWE_ErrCode int

SET @MWE_ErrCode = CASE @Level
					WHEN 1 THEN 99901 --log informational
					WHEN 2 THEN 99902 --log warning
					WHEN 3 THEN 99903 --log Error
					ELSE 99903
				END

IF @command IS NULL
	SET @command = CASE @Level
					WHEN 1 THEN 'Informational' 
					WHEN 2 THEN 'Warning' 
					WHEN 3 THEN 'Error' 
					ELSE 'N/A'
				END

IF @JobID IS NOT NULL
BEGIN
	SET @JobIDTEXT  = CAST(@JobID as nvarchar(50))
	SELECT @message = ISNULL(message, 'No valid message for jobid ' + @JobIDTEXT)
		, @error_id= ISNULL(sql_severity, 'No valid severity for jobid ' + @JobIDTEXT)
	FROM msdb.dbo.sysjobhistory
	WHERE job_id=@JobID AND step_id=1
END
ELSE 
	SET @error_id = @MWE_ErrCode

INSERT INTO DBServices.dbo.[UBSMWE_Errors]
			([InitialLogTime]
			,[SQLErrorID]
			,[Source]
			,[command]
			,[message]
			,[NeedAlertGenerated]
			,[ErrorAlertCount]
			,[LastErrorEnteredDate])
VALUES (
	getdate()
	,@error_id
	,@Source
	,@command
	,@message
	,@NeedAlertGenerated
	,1
	,getdate())

IF @@ERROR <> 0
	RETURN (1) --failure

-- log event to application log as error for MOM/SCOM alerts
IF @LogEvent = 1
BEGIN
	IF @NeedAlertGenerated = 1
		RAISERROR (@MWE_ErrCode,16,1,@Source, @command, @message) WITH LOG
	ELSE
		RAISERROR (@MWE_ErrCode,16,1,@Source, @command, @message)

	RETURN (0)
END

END --Main	

GO
/****** Object:  StoredProcedure [dbo].[usp_LogErrorsCleanup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_LogErrorsCleanup]
(	@Log_retention INT = 60  -- two months
)	
						
AS
SET DATEFORMAT ymd
/************************************************************************************************
// @File:usp_LogErrorsCleanup.SQL
// Purpose:	removes Logs errors from   WorkFlow jobs error table based on 
// 		retention time period.
//               
// Modification History:
// History: Date Format dd/mm/yyyy
//
//   @Date:30/01/2006 @Author:Rakesh Bist @Version: 1.5.3 @Action: Created
//   @Date: 01/10/2006 @Author: Kevin Wagner @Version:2.0 @Action:Renamed file and stored procedure
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
************************************************************************************************/
SET NOCOUNT ON

    DECLARE @cutoff_time DATETIME
    DECLARE @start_time DATETIME  

-- Check for invalid parameter values 
IF @Log_retention < 0
    BEGIN
        RAISERROR('retention periods must be greater than 0. ', 16, -1)
        RETURN (1)
    END
    
-- Get start time 
SELECT @start_time = getdate()

-- Get cutoff time
SELECT @cutoff_time = dateadd(Day, -@Log_retention, getdate())

-- Delete log history entries(leave at least one row for monitoring)
DELETE DBServices.dbo.UBSMWE_Errors
	WHERE InitialLogTime <= @cutoff_time 

IF @@error <> 0
        BEGIN
        	RAISERROR('Error removing error log history from table.  %s ', 16, -1, 'UBSMWE_Errors')
        RETURN (1)
    END


RETURN (0)



GO
/****** Object:  StoredProcedure [dbo].[usp_LogEvent]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_LogEvent] 
		@ErrorText nvarchar(4000),
		@LogNTEvent int  = 1

AS

/****************************************************************************************
// @File: usp_LogEvent.SQL
// 
// Purpose:
//   Provide Logging information to alert MOM and the NT event log without sending back to client, needed for consistancy in application operation.
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//   @DateFormat DD/MM/YYYY
//   @Date: 27/07/2006 @Author: Kevin Wagner @Version: 2.0: Created
//	@LogNTEvent_Int = 0 --Do not log to NT event log 
//	@LogNTEvent_Int = 1 --log informational message to NT event log (blue i in a white baloon)
//	@LogNTEvent_Int = 2 --log warning message to NT event log (black ! in yellow triangle)
//	@LogNTEvent_Int = 3 --log error message to NT event log (white X in red circle)
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production//
//   @Date: 04/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 23/01/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.22 @Action: TRR-117 - SCOM picking up info events as alerts

****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT  ON
SET DATEFORMAT ymd

--    The idea here is to just enter an error into the event log without killing the connection.

/* 
TRR-117 - informational events being picked up by SCOM as alerts
- thus informational events now not to be registered - to output only to display for logging

IF @LogNTEvent = 1 
	EXEC master..xp_logevent 99901, @ErrorText, informational
ELSE
*/

IF @LogNTEvent = 2
	EXEC master..xp_logevent 99902, @ErrorText, warning
ELSE
IF @LogNTEvent = 3
	EXEC master..xp_logevent 99903, @ErrorText, error

PRINT @ErrorText
	
END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_Manage_WorkFlowSubTask]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_Manage_WorkFlowSubTask] (
	@Action nvarchar(10) = 'REPORT'
	, @WFSTName nvarchar(255) = NULL)

AS
/****************************************************************************************
// @File: usp_Manage_WorkFlowSubTask.SQL
// 
// Purpose:
//   
//
// Notes: This stored procedure is used to describe the WorkFlow. 
//
// History:
//
//   @Date: 01/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Created
//   @Date: 15/04/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.29 @Action: rewrite orig crap code
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @SQLStr nvarchar(1000)

SET @Action = LTRIM(RTRIM(UPPER(@Action)))

IF @Action NOT IN ('ENABLE', 'DISABLE', 'REPORT')
BEGIN
	PRINT 'UBSMWE: usp_Manage_WorkFlowSubTask: Invalid value for @Action; options ENABLE, DISABLE, REPORT'
	RETURN 1
END

IF @Action IN ('ENABLE', 'DISABLE')
BEGIN
	IF ISNULL(@WFSTName, '') <> ''
		UPDATE WorkFlowTask
		SET WFTaskEnabled = CASE @Action
									WHEN 'DISABLE' THEN 0
								ELSE 1
								END
		WHERE @WFSTName =  WFTaskName
	ELSE
	BEGIN
		PRINT 'UBSMWE: usp_Manage_WorkFlowSubTask: WorkFlowSubTask name required'
		RETURN 1
	END
END

SET @SQLStr ='
	SELECT WorkFlowTask.WFTaskName
			, dbsDatabase.dbsDatabaseName
			, WorkFlowTask.WFTaskEnabled
			, WorkFlowTaskType.WFTaskTypeName
			, WorkFlowTaskType.WFTaskComment
	FROM DBServices.dbo.WorkFlowTask
	INNER JOIN DBServices.dbo.dbsDatabase 
		ON WorkFlowTask.dbsDatabaseUID = dbsDatabase.dbsDatabaseUID
	INNER JOIN DBServices.dbo.WorkFlowTaskType
		ON WorkFlowTask.WFTaskTypeID = WorkFlowTaskType.WFTaskTypeID'
	+ CASE 
		WHEN (ISNULL(@WFSTName, '') = '') THEN ''
		ELSE ' WHERE WorkFlowTask.WFTaskName = ''' + @WFSTName + ''''
	END
EXEC (@SQLStr)

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ManageIndexRebuild]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_ManageIndexRebuild] 	@DatabaseName nvarchar(255) = null, @TableName nvarchar(255) = null, @IndexName nvarchar(255) = null , @DisableRebuildFlag bit = null, @TableOwner nvarchar(255) = 'dbo'
						

AS
SET DATEFORMAT ymd

/****************************************************************************************
// @File: usp_ManageIndexRebuild.SQL
// 
// Purpose:
//   Update index rebuild status....
//
// History: Dates are in mm/dd/yyyy format
//
//   @Date: 28/04/2008 @Author: Kevin Wagner @Version: 2.5.4 @Action: Inception.
//   
****************************************************************************************/

BEGIN  --Begin main()

	SET NOCOUNT ON
	SET DATEFORMAT ymd


	IF @DatabaseName is null
		BEGIN
			IF EXISTS (
						SELECT     *
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND [Table].TableName = [Index].TableName 
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1)
						)
				BEGIN
						SELECT     dbsDatabase.dbsDatabaseName, [Table].TableOwner, [Table].TableName, [Index].IndexName, [Index].DisableRebuildFlag
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1)
				END
			ELSE
				BEGIN
					PRINT 'No Reindex exceptions exist'
				END
		END
	ELSE IF @TableName is null
		BEGIN
			IF EXISTS (
						SELECT     *
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1) 
						AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
						--AND ([Table].TableName = @TableName) 
						--AND ([Index].IndexName = @IndexName)
						)
				BEGIN
						SELECT     dbsDatabase.dbsDatabaseName, [Table].TableOwner, [Table].TableName, [Index].IndexName, [Index].DisableRebuildFlag
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1)
						AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
						--AND ([Table].TableName = @TableName) 
						--AND ([Index].IndexName = @IndexName)
				END
			ELSE
				BEGIN
					PRINT 'No Reindex exceptions exist'
				END

		END
	ELSE IF @IndexName is null
 		BEGIN
			IF EXISTS (
						SELECT     *
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1) 
						AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
						AND ([Table].TableName = @TableName) 
						AND ([Table].TableOwner = @TableOwner)
						--AND ([Index].IndexName = @IndexName)
						)
				BEGIN
						SELECT     dbsDatabase.dbsDatabaseName, [Table].TableOwner, [Table].TableName, [Index].IndexName, [Index].DisableRebuildFlag
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1)
						AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
						AND ([Table].TableName = @TableName) 
						AND ([Table].TableOwner = @TableOwner)
						--AND ([Index].IndexName = @IndexName)
				END
			ELSE
				BEGIN
					PRINT 'No Reindex exceptions exist'
				END

		END
	ELSE IF @DisableRebuildFlag is null
 		BEGIN
			IF EXISTS (
						SELECT     *
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1) 
						AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
						AND ([Table].TableName = @TableName)
						AND ([Table].TableOwner = @TableOwner)
						AND ([Index].IndexName = @IndexName)
						)
				BEGIN
						SELECT     dbsDatabase.dbsDatabaseName, [Table].TableOwner, [Table].TableName, [Index].IndexName, [Index].DisableRebuildFlag
						FROM         dbsDatabase INNER JOIN
											  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
											  [Index] ON [Table].TableOwner = [Index].TableOwner AND  [Table].TableName = [Index].TableName
						WHERE     (dbsDatabase.dbsDatabaseIsActive = 1)
						AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
						AND ([Table].TableName = @TableName) 
						AND ([Table].TableOwner = @TableOwner)
						AND ([Index].IndexName = @IndexName)
				END
			ELSE
				BEGIN
					PRINT 'No Reindex exceptions exist'
				END

		END
	ELSE IF @DatabaseName is not null
			AND @TableName is not null
			AND @IndexName is not null
			AND @DisableRebuildFlag is not null
			AND @TableOwner is not null
		BEGIN
			IF NOT EXISTS (SELECT * FROM dbsDatabase WHERE dbsDatabaseName = @DatabaseName)
				BEGIN
					PRINT 'The database does not exist in dbsDatabase, please check the name and try again. Database name provided = ' + @DatabaseName
				END
			ELSE
				BEGIN
					IF NOT EXISTS (SELECT * FROM [dbo].[Table] WHERE TableOwner = @TableOwner AND TableName = @TableName)
						BEGIN
							INSERT INTO [dbo].[Table]
							SELECT @TableOwner, @TableName, dbsDatabaseUID
							FROM dbo.dbsDatabase
							WHERE dbsDatabaseName = @DatabaseName
						END
					IF NOT EXISTS (
									SELECT     dbsDatabase.dbsDatabaseName, [Table].TableName, [Index].IndexName, [Index].DisableRebuildFlag
									FROM         dbsDatabase INNER JOIN
														  [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID INNER JOIN
														  [Index] ON [Table].[TableOwner] = [Index].TableOwner AND  [Table].TableName = [Index].TableName
									WHERE     (dbsDatabase.dbsDatabaseIsActive = 1) 
									AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
									AND ([Table].TableName = @TableName)
									AND ([Table].TableOwner = @TableOwner)
									AND ([Index].IndexName = @IndexName)
									)
						BEGIN
							INSERT INTO [dbo].[Index]
							SELECT @IndexName, [Table].[TableOwner], [Table].[TableName], @DisableRebuildFlag
							FROM dbsDatabase INNER JOIN [Table] ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID
							WHERE (dbsDatabase.dbsDatabaseName = @DatabaseName) 
									AND ([Table].TableName = @TableName)
									AND ([Table].TableOwner = @TableOwner)
						END
					ELSE
						BEGIN
							UPDATE    [Index]
							SET              DisableRebuildFlag = @DisableRebuildFlag
							FROM         [Index] AS Index_1 INNER JOIN
												  [Table] ON  [Table].TableOwner = [Index_1].TableOwner AND  Index_1.TableName = [Table].TableName INNER JOIN
												  dbsDatabase ON [Table].dbsDatabaseUID = dbsDatabase.dbsDatabaseUID INNER JOIN
												  [Index] ON Index_1.IndexName = [Index].IndexName
							WHERE     (Index_1.IndexName = @IndexName) AND ([Table].TableName = @TableName) AND (dbsDatabase.dbsDatabaseName = @DatabaseName)
						END
				END
		END
	ELSE
		BEGIN
			PRINT 'Syntax error, please check your command again...'
		END

END --Begin main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ManageMainUBSMWEJob]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO


CREATE PROCEDURE [dbo].[usp_ManageMainUBSMWEJob] @Action nvarchar(255)

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_ManageMainUBSMWEJob.SQL
// 
// Purpose:
//   Enable and disable the main UBSMWE job.
//
// Notes: This stored procedure is provided for SMB weekly maint procedures.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 08/12/2004 @Author: Kevin Wagner @Version: 1.5.1 HF1 @Action: Inception...
//
/    @Date: 20/04/2006 @Author: Rakesh Bist  @version: 2.0  Added support for SQL Server 2005
/							    updated version number.
//   @Date: 18/12/2006 @Author: Kevin Wagner @Version: UBSMWE 2.5 @Action: Rebranded UBSMWE Name
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 14/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Updated main job name 
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
****************************************************************************************/

BEGIN  
	DECLARE @RC int
		,@Count int
		,@job_name nvarchar(255)
		,@enabled	TINYINT
		,@ErrorText	NVARCHAR(255)

	SET @job_name  = N'UBSMWE_Engine_(2.5.4)'

	--If we dont have good usage, go to exit with reminder
	IF LOWER(@Action) not in ('start', 'status start', 'stop', 'status stop')
		BEGIN
			SET @ErrorText = N'The command was not valid, @Action must be ''start'', ''status start'', ''stop'', ''status stop'''
			GOTO EXIT_USAGE_BAD
		END



	IF lower(@Action) in ( 'start', 'status start' )
		BEGIN --Start job
			--Log the starting action
--			EXEC usp_UpdatedbsUBSMWEHeartbeat 'usp_ManageMainUBSMWEJob is Enabling up the main "' + @job_name + '" job.', 1 --Logged as informational
			--Enable the job and wait for it to start. If not started in 5 min return error.
			IF lower(@Action) = 'start'
				BEGIN
					EXEC msdb.dbo.sp_update_job @job_name  = @job_name, @enabled = 1
				END

			SELECT @enabled = enabled    
			FROM   msdb.dbo.sysjobs    
			WHERE name = @job_name 

			IF  @enabled <> 1
				BEGIN
					SET @ErrorText = N'usp_ManageMainUBSMWEJob failed to enable the "' + @job_name + '" job.'
					GOTO EXIT_RETURN_BAD
				END

			SET @Count = 0
			SET @job_name = 'UBSMWE (2.0)'
			EXEC @RC = [DBServices].[dbo].[usp_GetJobState] @job_name
			WHILE @RC = 4 --Do while job is not running or until 5 min time limit.
				BEGIN --While @RC = 1
					WAITFOR DELAY '000:00:00:500'
					EXEC @RC = [DBServices].[dbo].[usp_GetJobState] @job_name

					IF @Count > 600 --5 Min wait time before failing the stop, checking every 0.5 seconds
						IF lower(@Action) = 'start'
							BEGIN --Set error and exit
								SET @ErrorText = N'usp_ManageMainUBSMWEJob failed to start the "' + @job_name + '" job after 5 minutes.'
								GOTO EXIT_RETURN_BAD
							END --Set error and exit
						ELSE
							BEGIN --Set error and exit
								SET @ErrorText = N'usp_ManageMainUBSMWEJob the "' + @job_name + '" job has not started after 5 minutes.'
								GOTO EXIT_RETURN_BAD
							END --Set error and exit
							
				END --While @RC = 1
			SET @ErrorText = N'usp_ManageMainUBSMWEJob the main "' + @job_name + '" job is enabled and has started.'
			GOTO EXIT_RETURN_GOOD --All is good and job is started
		END --Start job


	IF lower(@Action) in  ( 'stop', 'status stop' )
		BEGIN --Stop job, the job name will be changed at some point and this procedure will be updated and remain valid.
			IF lower(@Action) = 'stop'
				BEGIN
					EXEC msdb.dbo.sp_update_job @job_name  = @job_name , @enabled = 0
				END

			SELECT @enabled = enabled    
			FROM   msdb.dbo.sysjobs    
			WHERE name = @job_name 

			--We should never be in this situation but if we are exit with error
			IF  @enabled <> 0
				BEGIN
					SET @ErrorText = N'usp_ManageMainUBSMWEJob failed to disable the "' + @job_name + '" job.'
					GOTO EXIT_RETURN_BAD
				END	
		
			SET @Count = 0
--			SET @job_name = N'UBSMWE (2.0)'
			EXEC @RC = [DBServices].[dbo].[usp_GetJobState] @job_name
			WHILE @RC = 1 --Do while job is not at a stopped state or until 5 min time limit.
				BEGIN --While @RC = 1
					WAITFOR DELAY '000:00:02'
					EXEC @RC = [DBServices].[dbo].[usp_GetJobState] @job_name

					IF @Count > 150 --5 Min wait time before failing the stop, checking every 2 seconds
						BEGIN --Set error and exit
							IF lower(@Action) = 'stop'
								BEGIN
									SET @ErrorText = N'usp_ManageMainUBSMWEJob failed to disable and stop the "' + @job_name + '" job after 5 minutes.'
									GOTO EXIT_RETURN_BAD
								END
							ELSE
								BEGIN
									SET @ErrorText = N'usp_ManageMainUBSMWEJob failed to disable the "' + @job_name + '" job after 5 minutes.'
									GOTO EXIT_RETURN_BAD
								END

						END --Set error and exit
				END --While @RC = 1
			SET @ErrorText = N'usp_ManageMainUBSMWEJob has disabled the main "' + @job_name + '" job.'
			--All is good and job is stopped
			GOTO  EXIT_RETURN_GOOD 
		END --Stop job

--Dont have proper usage so must exit with usage reminder.
--Although the code line below is not needed it is included for clarity.

GOTO EXIT_USAGE_BAD



EXIT_USAGE_BAD:
	BEGIN --Error in command
	   -- No valid @Action
	    RAISERROR (@ErrorText, 16, 1) 
	    RETURN -1 
	END --Error in command

EXIT_RETURN_BAD:
	BEGIN --Return Bad
		EXEC usp_UpdatedbsUBSMWEHeartbeat @ErrorText, 3 --Logged as red error
		RAISERROR (@ErrorText, 16, 1) 
		RETURN -1
	END --Return Bad

EXIT_RETURN_GOOD:
	BEGIN --Return Good
		EXEC usp_UpdatedbsUBSMWEHeartbeat @ErrorText, 1 --Logged as informational
		RETURN 0
	END --Return Good
END


GO
/****** Object:  StoredProcedure [dbo].[usp_ManageWorkFlowTaskJobs]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ManageWorkFlowTaskJobs]
					@DatabaseName nvarchar(255) 
					,@JobType tinyint --1 = BUFull, 2 = BULog, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
					,@ActionFlag  tinyint --1 = create, 2 = delete, 3 = SPECIAL Case Create if not existing...	
AS

/****************************************************************************************
// @File: usp_ManageWorkFlowTaskJobs.sql
// 
// Purpose:
//   Manage jobs used to backup databases ...
//
// Notes: This stored procedure is not intended to be run by hand. 
//
// History: Dates are in DD/MM/YYYY format
//
//   @Date: 05/10/2004 @Author: Kevin Wagner @Version: 1.5.1 @Action: Inception.
//   @Date: 27/04/2006 @Author: Rakesh Bist  @Version 2.0
// 					     Added job failure error traping to raise an alert in MOM.
//					     Scheduler job step calls error logging routine when
//					     job step fails.
//					     Do not create log backup job for a model DB.
//					     Ignore MS supplied sample DB if any there.
//	@Date: 18/12/2006	@Author: Kevin Wagner @Version: UBSMWE 2.5	@Action: Rebranded 
						for UBSMWE and to accomidate longer database names in the user jobs.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 24/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4 @Action: Updated for Reindex issue
//   @Date: 18/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//   @Date: 28/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 07/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 19/01/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.21 @Action: RC forwarding bug
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week
      
DECLARE @RC int
	, @JobID uniqueidentifier
	, @dbsCommand nvarchar(255)
	, @dbsPreCommand nvarchar(2000)
	, @dbsPostCommand nvarchar(2000)
	, @dbsFullCommand nvarchar(2000)
	, @dbsStepName nvarchar(255)
	, @dbsDescription nvarchar(1000)
	, @dbsJobName nvarchar(255)
	, @Category nvarchar(255)
	, @database_name nvarchar(255)
	, @LogFileName nvarchar(255) 
	, @WFTaskID uniqueidentifier
	, @WFTaskID_txt nvarchar(50)
	, @WFTaskName nvarchar(255)
	, @WFTaskTypeName nvarchar(255)
	, @WFTaskEnabled bit
	, @WFTaskPriority smallint
	, @WFID	uniqueidentifier
	, @WFName nvarchar(255)
	, @WFPriority smallint
	, @dbsDatabaseUID uniqueidentifier
	, @CR nchar(2)
	, @ErrorMsg nvarchar(255)

---------------------------
 
SET @CR = NCHAR(13) + NCHAR(10) -- Carridge return

--------------------------------------------------------------------------
-- Determine the job parameters 

/*
@JobType: 

	1	UBSMWE_WFST_BUFull	
	2	UBSMWE_WFST_BULog	
	3	UBSMWE_WFST_DBCheck	
	4	UBSMWE_WFST_IDXReBld	
	5	UBSMWE_WFST_IDXUpdSt	
	6	UBSMWE_WFST_BUFull_CV_SQLiDA

@ActionFlag  
	1	create
	2	delete
	3	'SPECIAL' - Case create if not existing...
*/

IF @JobType = 1 -- 1 = BUFull
BEGIN
	SET @database_name = 'DBServices'
	SET @Category = N'UBSMWE_WFST_BUFull'
	SET @dbsCommand = N'EXEC @RC= DBServices.dbo.usp_BackupDatabase_JobRun ''' + @DatabaseName + ''', 1'
	SET @dbsPostCommand = ''
	SET @WFTaskPriority = 10 --Full backups have most priority - Increment by 10 for now so we can have room to tweak on an as needed basis
	SET @WFName = @Category
	SET @WFPriority = 10
END	---------------------
ELSE 
IF @JobType = 2 -- 2 = BULog
BEGIN
	SET @database_name = 'DBServices'
	SET @Category = N'UBSMWE_WFST_BULog'
	SET @dbsCommand = N'EXEC @RC= DBServices.dbo.usp_BackupDatabase_JobRun ''' + @DatabaseName + ''', 2'
	SET @WFTaskPriority = 20
	SET @WFName = @Category
	SET @WFPriority = 20
END	---------------------
ELSE 
IF @JobType = 3 -- 3 = CheckDB
BEGIN
	SET @database_name = 'DBServices'
	SET @Category = N'UBSMWE_WFST_DBCheck'
	SET @dbsCommand = N'EXEC @RC= DBServices.dbo.usp_UBSMWE_WFST_DBChek_JobRun ''' + @DatabaseName + ''''
	SET @WFTaskPriority = 30
	SET @WFName = @Category
	SET @WFPriority = 30
END	---------------------
ELSE 
IF @JobType = 4 -- 4 = DBReindex
BEGIN
	SET @database_name = @DatabaseName
	SET @Category = N'UBSMWE_WFST_IDXReBld'

	SET @dbsCommand = N'EXEC @RC= DBServices.dbo.usp_UBSMWE_WFST_IDXReBld_JobRun ''' + @DatabaseName + ''''

	SET @WFTaskPriority = 40
	SET @WFName = @Category
	SET @WFPriority = 40
END	---------------------
ELSE 
IF @JobType = 5 -- 5 =  UpdateStats
BEGIN
	SET @database_name = @DatabaseName
	SET @Category = N'UBSMWE_WFST_IDXUpdSt'
	SET @dbsCommand = N'EXEC @RC= DBServices.dbo.usp_dbUpdateStats ''' + @DatabaseName + ''''
	SET @WFTaskPriority = 50
	SET @WFName = @Category
	SET @WFPriority = 50
END	---------------------
ELSE 
IF @JobType = 6 -- 6 = BUFull_CV_SQLiDA - Dummy job for info to indicate 'grouped' DBA CV SQL iDA backups - *** TO DO ***
BEGIN
	SET @Category = N'UBSMWE_WFST_BUFull_CV_SQLiDA_Subclient_Info'
	SET @dbsCommand = 'Info: ' + @DatabaseName + ' backed up via Subclient: ' + dbo.ufn_CV_Subclient_forDB (@DatabaseName) 
	SET @dbsPostCommand = ''
	SET @WFTaskPriority = 10
	SET @WFName = @Category
	SET @WFPriority = 10
END	---------------------
ELSE
BEGIN
	-- Invalid @JobType 
	SET @dbsJobName = @Category + ' (' + @DatabaseName + ')'

	SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR: Invalid @JobType: ' + CAST(@JobType as varchar (2))
		 + ' - Unable to create job: ' + @dbsJobName
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2

	RETURN 1 
END	---------------------

--Common params
--Add the database name to the job name now.
SET @dbsStepName = @Category + ' (' + @DatabaseName + ')'
SET @dbsJobName = @Category + ' (' + @DatabaseName + ')'
SET @dbsDescription = @Category + ' for database -  ' + @DatabaseName

SET @WFTaskName = @dbsJobName
SET @WFTaskTypeName = @Category
SET @WFTaskEnabled = 1

--------------------------------------------------------------------------
-- Determine if job exists

SELECT @JobID = job_id     
FROM   msdb.dbo.sysjobs    
WHERE [name] = @dbsJobName      

------------------

-- Delete the job with the same name if not @ActionFlag = 3 'SPECIAL' 
IF @ActionFlag <> 3 AND @JobID IS NOT NULL
BEGIN  
	-- Delete the [local] job 
	EXEC msdb.dbo.sp_delete_job @job_name = @dbsJobName  

	--Disable WorkFlowTask as well to keep it from appearing in the WorkFlowManifest
	EXEC [usp_UpdateWorkFlowTask] @WFTaskName = @dbsJobName	,@WFTaskEnabled = 0
	SET @JobID = NULL
END 

IF @ActionFlag = 2 --DELETE
	RETURN 0 -- Skip
ELSE 
IF @ActionFlag = 3   -- 'SPECIAL' 
BEGIN -- Get job id for action 3
	SET @JobID = NULL

	SELECT @JobID = job_id     
	FROM msdb.dbo.sysjobs    
	WHERE [name] = @dbsJobName
END 

--------------------------------------------------------------------------
-- Case Job not found

IF @JobID IS NULL
BEGIN 
	--Add the category if it does not exist yet.
	IF (SELECT COUNT(*) 
	FROM msdb.dbo.syscategories
	WHERE [name] = @Category) < 1 

	EXEC msdb.dbo.sp_add_category @name = @Category

	-- Get log file name
	EXEC @RC = DBServices.dbo.usp_GetLogfilename @dbsJobName, @LogFileName OUTPUT
	IF @RC <> 0 
	BEGIN 
		SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR in determining the Job log folder; Unable to configure Job logs for ' 
			+ @dbsJobName
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1

		SET @LogFileName = ''
	END

	-- Need to insert the record or get it updated and return the @WFTaskID
	SELECT @dbsDatabaseUID = dbsDatabaseUID 
	FROM dbo.dbsDatabase
	WHERE dbsDatabaseName = @DatabaseName
	
	EXEC @RC = [DBServices].[dbo].[usp_UpdateWorkFlowTask] 
							   @dbsJobName
							  ,@Category
							  ,1
							  ,@WFTaskPriority
							  ,@WFTaskID OUTPUT
							  ,NULL
							  ,@dbsDatabaseUID

	SET @WFTaskID_txt = CAST(@WFTaskID as nvarchar(50))

	-- Add the job
	EXEC @RC = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT,  
							@job_name = @dbsJobName,  
							@owner_login_name = N'sa',  
							@description = @dbsDescription,  
							@category_name = @Category,  
							@enabled = 1,  
							@notify_level_email = 0,  
							@notify_level_page = 0,  
							@notify_level_netsend = 0,  
							@notify_level_eventlog = 2,  
							@delete_level= 0

	--Now set the commands for entering in the History information
	--Since formatting of the code in the job window is difficult, I have left justified the following lines...

	EXEC @RC = [DBServices].[dbo].[usp_UpdateWorkFlowTask] 
										   @dbsJobName
										  ,@Category
										  ,1
										  ,@WFTaskPriority
										  ,@WFTaskID OUTPUT
										  ,@JobID
	-- Left justified for job step output
	SET @dbsPreCommand = N'
-- Pre work flow task step
DECLARE @WFTaskHistoryID bigint, @RC int
EXEC [DBServices].[dbo].[usp_WFST_PreCommand] 
		 ''' + CAST(@dbsDatabaseUID as nvarchar(50)) + '''
		, ''' + @dbsJobName + '''
		, ''' + @WFTaskID_txt + '''
		, ''' + CAST(@WFTaskID as nvarchar(50)) + '''
		, @WFTaskHistoryID OUTPUT;
----------------------------------------------------------------------------------------------------------'

	SET @dbsPostCommand = N'----------------------------------------------------------------------------------------------------------
-- Post work flow task step
EXEC [DBServices].[dbo].[usp_WFST_PostCommand] 
		''' + @WFTaskID_txt + '''
		, @WFTaskHistoryID
		, @RC;'

	SET @dbsFullCommand = ISNULL(@dbsPreCommand, '') 
		+ @CR +  @CR + '-- Main work flow task command' +  @CR +  ISNULL(@dbsCommand, '') 
		+ @CR +  @CR + ISNULL(@dbsPostCommand, '') 

	-- Add the job steps
	EXEC @RC = msdb.dbo.sp_add_jobstep @job_id = @JobID, 
							@step_id = 1,  
							@step_name = @dbsStepName,  
							@command = @dbsFullCommand,  
							@database_name = @database_name ,  
							@server = N'',  
							@database_user_name = N'',  
							@subsystem = N'TSQL',  
							@cmdexec_success_code = 0,  
							@retry_attempts = 0,  
							@retry_interval = 1,   
							@on_success_step_id = 0,  
							@on_success_action = 1,  
							@on_fail_step_id = 0,  
							@on_fail_action = 3,
							@output_file_name = @LogFileName,
							@flags = 0

	IF @RC <> 0 
	BEGIN 
		SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR: Adding job step ' + @dbsStepName 
			+ '; @JobType: ' + CAST(@JobType as varchar (2))
			+ ' , job: ' + @dbsJobName
	
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3
		RETURN (1)
	END

	-- Add job failure step & raise alert for mom.
	SET @dbsCommand = N'EXEC usp_LogErrors ' 
		+ QUOTENAME(CAST(@JobID AS NVARCHAR(40)),'''')  
		+ ' , 0, ' 
		+ QUOTENAME(@dbsCommand,'''') + ', ' 
		+ QUOTENAME('SQL Job Execution ','''')

	EXEC @RC = msdb.dbo.sp_add_jobstep @job_id = @JobID, 
							@step_id = 2,  
							@step_name = N'Log Error', 
							@command = @dbsCommand, 
							@database_name = 'DBServices',  
							@server = N'',  
							@database_user_name = N'', 
							@subsystem = N'TSQL',  
							@cmdexec_success_code = 0,  
							@flags = 0,  
							@retry_attempts = 0, 
							@retry_interval = 1,  
							@output_file_name = N'',  
							@on_success_step_id = 0, 
							@on_success_action = 2,  
							@on_fail_step_id = 0,  
							@on_fail_action = 2

	IF @RC <> 0 
	BEGIN 
		SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR: in adding Log Error step; @JobType: ' + CAST(@JobType as varchar (2))
			+ ' , job: ' + @dbsJobName
	
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3
		RETURN (1)
	END

	EXEC @RC = msdb.dbo.sp_update_job @job_id = @JobID, @start_step_id = 1 

	-- Add the Target Servers
	EXEC @RC = msdb.dbo.sp_add_jobserver @job_id = @JobID, @server_name = N'(local)' 

	-- Need to insert the record or get it updated and return the @WFTaskID
	EXEC @RC = [DBServices].[dbo].[usp_UpdateWorkFlowTask] 
						   @dbsJobName
						  ,@Category
						  ,1
						  ,@WFTaskPriority
						  ,@WFTaskID OUTPUT
						  ,@JobID
	IF @RC <> 0 
	BEGIN 
		SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR: setting WorkFlowTask information @JobType: ' + CAST(@JobType as varchar (2))
			+ ' , job: ' + @dbsJobName
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3

		RETURN (1)
	END

	PRINT 'In PreUpdate WorkFlowManifest'
	SELECT @WFID, @WFTaskID, 1

	--Alert if the default workflow does not exist and then exit the procedure....
	SELECT @WFID = WFID 
	FROM WorkFlow
	WHERE WFName = @WFName
	
	IF @WFID IS NOT NULL
	BEGIN
		UPDATE WorkFlowJob
		SET WFJobNeedsUpdate = 1
		FROM WorkFlowJob 
		INNER JOIN WorkFlowJobManifest
			ON WorkFlowJob.WFJobID = WorkFlowJobManifest.WFJobID
		INNER JOIN WorkFlow
			ON WorkFlowJobManifest.WFID = WorkFlow.WFID
		WHERE (WorkFlow.WFID = @WFID)
	END
	ELSE
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR: Default WorkFlow does not exist for ' + @WFName
			+ ', @JobType: ' + CAST(@JobType as varchar (2))
			+ ', job: ' + @dbsJobName
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3

		RETURN (-1)
	END

	IF @WFTaskID IS NOT NULL AND @WFID IS NOT NULL
	BEGIN
		IF NOT EXISTS (SELECT * FROM WorkFlowManifest WHERE WFID = @WFID AND WFTaskID = @WFTaskID )
		BEGIN
			PRINT 'In insert to WorkFlowManifest'
			SELECT @WFID, @WFTaskID, 1

			INSERT INTO WorkFlowManifest
			VALUES (@WFID, @WFTaskID, 1)

			UPDATE WorkFlowJob
			SET WFJobNeedsUpdate = 1
			FROM WorkFlowJob
			INNER JOIN WorkFlowJobManifest
				ON WorkFlowJob.WFJobID = WorkFlowJobManifest.WFJobID
			INNER JOIN WorkFlow 
				ON WorkFlowJobManifest.WFID = WorkFlow.WFID
			WHERE (WorkFlow.WFID = @WFID)
		END
		ELSE
		BEGIN
			-- Record exists; just update the status
			UPDATE WorkFlowManifest
			SET WFManifestEnabled = 1
			WHERE WFID = @WFID AND WFTaskID = @JobID
		END
	END
	ELSE
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_ManageWorkFlowTaskJobs: ERROR: Unable to establish link for WorkFlowTask: ' + @WFTaskName
			+ ', @JobType: ' + CAST(@JobType as varchar (2))
			+ ', job: ' + @dbsJobName
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3

		RETURN (1)
	END

END -- End Case Job not found

-- Return success
RETURN (0)
       
END --End Main()

GO
/****** Object:  StoredProcedure [dbo].[usp_MarkFilebackupFixed]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_MarkFilebackupFixed] 	@ManifestID BIGINT,  @TicketNumber nvarchar(255) = NULL			
AS
/****************************************************************************************
// @File: usp_ConfigureUBSMWE.SQL
// 
// @Version 6.0.0.8
// Purpose:
//   Update Filebackup status marking as forced fixed....
//
// History: Dates are in mm/dd/yyyy format
//
//   @Date: 18/12/2006 @Author: Kevin Wagner @Version: 2.5.0 @Action: Inception.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 20/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Netbackup Rerun process change. Will now rerun under same Netbackup Manifest number.//   
//   @Date: 01/06/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.5 @Action: CommVault support  
//   @Date: 17/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
****************************************************************************************/

BEGIN  --Begin main()

SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @OriginlStatus nvarchar(255),
		@ManifestIDTest bigint,
		@dbsNetbackupRunNumber int

SET @OriginlStatus = NULL
SET @ManifestIDTest = NULL		

IF @dbsNetbackupRunNumber IS NULL
	SELECT @dbsNetbackupRunNumber = MAX(dbsNetbackupRunNumber)
	FROM dbo.dbsNetbackupStatus
	WHERE dbsNetbackupID = @ManifestID

SELECT @ManifestIDTest = dbsNetbackupID
		, @OriginlStatus = ISNULL(dbsNetbackupStatus, 'Not Valid Status')
FROM dbsNetbackupStatus
WHERE dbsNetbackupID = @ManifestID
	AND dbsNetbackupRunNumber = @dbsNetbackupRunNumber

--'Forced success - ' + dbsNetbackupStatus 
IF @ManifestIDTest IS NOT NULL
BEGIN
	UPDATE DBServices.dbo.dbsNetbackupManifest
	SET IsSuccess = 1, IsSuccessRunNumber = @dbsNetbackupRunNumber

	UPDATE DBServices.dbo.dbsNetbackupStatus
	SET dbsNetbackupStatus = 'Forced success - '
			+ substring(dbsNetbackupStatus, 0,  255 - len('Forced Success - '))
	WHERE dbsNetbackupID = @ManifestID 
		AND dbsNetbackupRunNumber = @dbsNetbackupRunNumber
	
	UPDATE DBServices.dbo.dbsNetbackup
	SET dbsNetbackupExitStatus = 'Forced Success - '
		+ substring(dbsNetbackupExitStatus, 0, 255 - len('Forced Success - '))
	WHERE dbsNetbackupID = @ManifestID

	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'NetbackupErrorCount', 0
END
ELSE
	PRINT 'Manifest Number ' + cast(@ManifestID as NVARCHAR(255))
		+ ' does not exist. Please check to make sure you have the correct manifest number and try again.'

-- Run file backup report 
EXEC DBServices.dbo.[usp_Help_FileBackup]

END --Begin main()

GO
/****** Object:  StoredProcedure [dbo].[usp_MORCS_ChangeSAPassword]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_MORCS_ChangeSAPassword] 

AS
SET DATEFORMAT ymd
SET NOCOUNT ON
/****************************************************************************************
// @File: usp_MORCS_ChangeSAPassword.SQL
// 
// Purpose:
//   Perform Full Backup of all databases
//
// Notes: This stored procedure is called from main UBSMWE. Can be run by hand if needed.
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 25/09/2007 @Author: Charley Hanania @Version: UBSMWE 2.5.2 @Action: Update dbsMSSQLCentralCommandQueue to remove SA password Details
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/


BEGIN

	DECLARE	 @VVCNewSAPassword varchar(50)
--	,
-- Call Procedure to set the new password
	EXEC [dbo].[usp_CreateGUIDPassword] @VVCNewSAPassword OUTPUT

--	PRINT @VVCNewSAPassword
	EXEC master.dbo.sp_password @new = @VVCNewSAPassword ,@loginame = 'sa'

	EXEC [dbo].[msc_updateSAPassword] @VVCNewSAPassword 

END

GO
/****** Object:  StoredProcedure [dbo].[usp_MoveFile]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_MoveFile] 
(
	@FileName nvarchar(260),
	@destination nvarchar(260),
	@MoveOrCopy char(4) = 'Move',
	@exists int = 0 output
)
AS
SET DATEFORMAT ymd
/************************************************************************************************
Name: 		usp_MoveFile.SQL
Purpose:	Move a file with execute status returned
              
Modification History:
//   @Date: 26/07/2006 @Author: Kevin Wagner @Version: driver 2.0.0 @Action: Inception to help with issue involving moving files for Netbackup
//   @Date: 17/10/2006 @Author: Kevin Wagner @Version: driver 2.0.6 @Action: Updated to accomidate a copy or move of the file for log shipping (issue#26)
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production

************************************************************************************************/
BEGIN 
   SET NOCOUNT ON

    DECLARE @command nvarchar(512)
    DECLARE @retcode int
	DECLARE @sql2 nvarchar(4000)
-- TODO: Set parameter values here.
CREATE TABLE 	#MoveResult  (result nvarchar(260))

EXECUTE @retcode = [DBServices].[dbo].[usp_FileExists] 
   @FileName
  ,@exists OUTPUT

	IF @exists = 1 
		BEGIN
			IF @MoveOrCopy = 'Move'
				BEGIN
					SELECT @sql2 = 'move /Y ' + @FileName + ' ' + @destination
				END
			ELSE
				BEGIN
					SELECT @sql2 = 'copy /Y ' + @FileName + ' ' + @destination
				END

			--PRINT @sql2
			INSERT INTO #MoveResult
			EXEC master..xp_cmdshell @sql2 

			IF EXISTS (SELECT * FROM #MoveResult WHERE result like  '%1 file(s) moved%' or result like '%1 file(s) copied%')
				BEGIN
					SET @retcode = 0
				END
			ELSE
				BEGIN
					SET @retcode = 1
				END
		END
	ELSE
		BEGIN
			SET @retcode = 1
		END

DROP TABLE #MoveResult
return @retcode
END

GO
/****** Object:  StoredProcedure [dbo].[usp_mscGetInstanceID]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_mscGetInstanceID] 
AS
/****************************************************************************************
// @File: usp_mscGetInstanceID.SQL
// 
// Purpose:
//   Get current GUID from MSSQLCentral database
//
// Notes: This stored procedure is called from main UBSMWE. Can be run by hand if needed.
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 06/02/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9.3 @Action: Bugfix - config login method ignored 
//   @Date: 06/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 24/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 Beta
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int,
	@ActiveComputerName nvarchar(128),
	@MSSQLCentralActiveLoginMethod nvarchar(20), --'Trusted', 'SQL'
	@MSSQLCentralInstanceID char(36),

	@MSSQLCentralPrimaryServer nvarchar(128),
	@MSSQLCentralPrimaryDatabase nvarchar(128),
	@MSSQLCentralPrimaryUser nvarchar(128),
	@MSSQLCentralPrimaryUserPW nvarchar(128),

	@MSSQLCentralAlternateServer1 nvarchar(128),
	@MSSQLCentralAlternateDatabase1	nvarchar(128),
	@MSSQLCentralAlternateUser1 nvarchar(128),
	@MSSQLCentralAlternateUserPW1 nvarchar(128),

	@MSSQLCentralAlternateServer2 nvarchar(128),
	@MSSQLCentralAlternateDatabase2	nvarchar(128),
	@MSSQLCentralAlternateUser2 nvarchar(128),
	@MSSQLCentralAlternateUserPW2 nvarchar(128),

	@MSSQLCentralAlternateServer3 nvarchar(128),
	@MSSQLCentralAlternateDatabase3	nvarchar(128),
	@MSSQLCentralAlternateUser3 nvarchar(128),
	@MSSQLCentralAlternateUserPW3 nvarchar(128),
	
	@MSSQLCentralActiveServer nvarchar(128),
	@MSSQLCentralActiveDatabase	nvarchar(128),
	@MSSQLCentralActiveUser nvarchar(128),
	@MSSQLCentralActiveUserPW nvarchar(128),

	@Data nvarchar(4000),
	@Error1 nvarchar(4000),
	@Error2 nvarchar(4000),
	@sqlError1 nvarchar(4000),
	@sql nvarchar(4000),
	@ConnectCounter int,
	@RowCount int,
	@IsClustered bit

------------------------------------------------------------	
SET @ConnectCounter = 0 --4 possable MSSQLCentral servers so starting at 0 for Primary server
SET @Data = 'No Connection'

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralActiveLoginMethod', @MSSQLCentralActiveLoginMethod OUTPUT 
IF @MSSQLCentralActiveLoginMethod IS NULL 
	SET @MSSQLCentralActiveLoginMethod = 'No Connection'

--Need to put in some sort of error checking
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralInstanceID', @MSSQLCentralInstanceID OUTPUT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryServer', @MSSQLCentralPrimaryServer OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryDatabase', @MSSQLCentralPrimaryDatabase OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryUser', @MSSQLCentralPrimaryUser OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryUserPW', @MSSQLCentralPrimaryUserPW OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateServer1', @MSSQLCentralAlternateServer1 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateDatabase1', @MSSQLCentralAlternateDatabase1 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateUser1', @MSSQLCentralAlternateUser1 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateUserPW1', @MSSQLCentralAlternateUserPW1 OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateServer2', @MSSQLCentralAlternateServer2 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateDatabase2', @MSSQLCentralAlternateDatabase2 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateUser2', @MSSQLCentralAlternateUser2 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateUserPW2', @MSSQLCentralAlternateUserPW2 OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateServer3', @MSSQLCentralAlternateServer3 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateDatabase3', @MSSQLCentralAlternateDatabase3 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateUser3', @MSSQLCentralAlternateUser3 OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralAlternateUserPW3', @MSSQLCentralAlternateUserPW3 OUTPUT 

-----------------
-- If cluster ensure active node details are correct 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsIsInstanceClusteredFlag', @IsClustered OUTPUT 

IF @IsClustered = 0
	AND CAST(SERVERPROPERTY('IsClustered') as bit) = 1
BEGIN
	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsIsInstanceClusteredFlag', 1 
	SET @IsClustered = 1
END

IF @IsClustered = 1
	EXEC [DBServices].[dbo].usp_UpdateActiveServerName

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT 

------------------------------------------------------------

IF OBJECT_ID('tempdb..#result') IS NOT NULL 
	DROP TABLE #result

CREATE TABLE #result(ColOrder int IDENTITY, Data nvarchar(255))

------------------------

STARTLOOP:
BEGIN --WHILE
	IF @ConnectCounter = 0
	BEGIN
		SELECT @MSSQLCentralActiveServer		= @MSSQLCentralPrimaryServer
				,@MSSQLCentralActiveDatabase	= @MSSQLCentralPrimaryDatabase
				,@MSSQLCentralActiveUser		= @MSSQLCentralPrimaryUser
				,@MSSQLCentralActiveUserPW		= @MSSQLCentralPrimaryUserPW
	END
	ELSE IF @ConnectCounter = 1
	BEGIN
		SELECT @MSSQLCentralActiveServer		= @MSSQLCentralAlternateServer1
				,@MSSQLCentralActiveDatabase	= @MSSQLCentralAlternateDatabase1
				,@MSSQLCentralActiveUser		= @MSSQLCentralAlternateUser1
				,@MSSQLCentralActiveUserPW		= @MSSQLCentralAlternateUserPW1
	END
	ELSE IF @ConnectCounter = 2
	BEGIN
		SELECT @MSSQLCentralActiveServer		= @MSSQLCentralAlternateServer2
				,@MSSQLCentralActiveDatabase	= @MSSQLCentralAlternateDatabase2
				,@MSSQLCentralActiveUser		= @MSSQLCentralAlternateUser2
				,@MSSQLCentralActiveUserPW		= @MSSQLCentralAlternateUserPW2
	END
	ELSE IF @ConnectCounter = 3
	BEGIN
		SELECT @MSSQLCentralActiveServer		= @MSSQLCentralAlternateServer3
				,@MSSQLCentralActiveDatabase	= @MSSQLCentralAlternateDatabase3
				,@MSSQLCentralActiveUser		= @MSSQLCentralAlternateUser3
				,@MSSQLCentralActiveUserPW		= @MSSQLCentralAlternateUserPW3
	END
	ELSE IF @MSSQLCentralActiveServer IS NULL
	BEGIN
		GOTO NEXTLOOP
	END
	
	------------------------------------------------------------	
	--Connection check
	
	IF @MSSQLCentralActiveLoginMethod = 'No Connection' OR @MSSQLCentralActiveLoginMethod = 'Trusted'
	BEGIN --Attempt Trusted connection

		SET @sql = 'osql -w 2000  -S '+ @MSSQLCentralActiveServer 
			+ ' -E -d ' + @MSSQLCentralActiveDatabase 
			+ ' -Q "EXEC [ubsmwe_GetInstanceID] '''
			+ CAST (ISNULL(SERVERPROPERTY('InstanceName'), 'DEFAULT') as varchar(128))
			+ ''', ''' +  CAST(ISNULL(SERVERPROPERTY('MachineName'), @ActiveComputerName) as varchar(255)) -- virtual server
			+ ''', ''' + @ActiveComputerName + '''"' -- i.e. SERVERPROPERTY('ComputerNamePhysicalNetBIOS')
		SELECT @sql
		
		TRUNCATE TABLE #result
		INSERT INTO #result	
			EXEC master..xp_cmdshell @sql

		SELECT @RowCount = COUNT(Data)
		FROM #result
		WHERE Data IS NOT NULL
		------------------------------------------------------------

		IF @RowCount = 1
		BEGIN
			-- SQL Central trusted connection established
			SELECT TOP 1 @Data = SUBSTRING( Data,  8, len( Data ) ) 
			FROM #result where Data like 'ubsmwe_%'
			ORDER BY  ColOrder
			SELECT @Data
			
			IF @Data IS NOT NULL AND @Data <> 'No Connection'
			BEGIN
				SELECT @MSSQLCentralActiveLoginMethod = 'Trusted'
				GOTO ENDIT
			END
			ELSE
			BEGIN
				-- SQL Central trusted connection error
				SELECT @Error1 = Data 
				FROM #result
				WHERE Data IS NOT NULL

				SET @sqlError1 = 'Error - Connection type: Trusted - when getting InstanceID from MSSQLCentral server '
					+ ISNULL(@MSSQLCentralActiveServer, 'No Server Info...')
					+ '. See details and correct. Details: '
					+ ISNULL(@Error1, '')
					+ ' - ' + ISNULL(@Error2, '')
					
				IF @Error1 LIKE '%Msg%'
				BEGIN
					EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1, 0, 1 --Send alert on the error
				END
				ELSE
				BEGIN
					EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1, 0, 0 --Do not send alert
				END
			END
		END ------------------------------------------------------------
		ELSE --IF @RowCount <> 1
		BEGIN
			IF @RowCount > 1
			BEGIN
				SELECT TOP 1 @Data = SUBSTRING( Data,  8, len( Data ) ) 
				FROM #result where Data like 'ubsmwe_%'
				ORDER BY  ColOrder

				SELECT @Data

				IF @Data IS NOT NULL
					AND @Data <> 'No Connection'
				BEGIN
					SET @MSSQLCentralActiveLoginMethod = 'Trusted'
					GOTO ENDIT
				END
				ELSE
				BEGIN
					SELECT TOP 1 @Error1 = Data
					FROM #result 
					WHERE Data IS NOT NULL
					ORDER BY  ColOrder

					DELETE  FROM #result
					WHERE Data = @Error1

					SELECT TOP 1 @Error2 = Data
					FROM #result 
					WHERE Data IS NOT NULL
					ORDER BY  ColOrder

					SET @sqlError1 = 'Error - Connection type: Trusted - when getting InstanceID from MSSQLCentral server '
						+ ISNULL(@MSSQLCentralActiveServer, 'No Server Info...') + '. See details and correct. Details: '
						+ ISNULL(@Error1, '') + ' - ' + ISNULL(@Error2, '')

					IF @Error1 LIKE '%Msg%'
					BEGIN
						EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1, 0, 1 --Send alert on the error
					END
					ELSE
					BEGIN
						EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1, 0, 0 --Do not send alert
					END
							
				END
			END
			ELSE
			BEGIN
				SET @sqlError1 = 'Error - Connection type: Trusted - No rows were returned and no error was encountered when getting InstanceID from MSSQLCentral server '
					+ ISNULL(@MSSQLCentralActiveServer, 'No Server Info...') 

				EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1
			END
		END
	END --Trusted connection
	------------------------------------------------------------

	IF @MSSQLCentralActiveLoginMethod = 'No Connection'
		OR @MSSQLCentralActiveLoginMethod = 'SQL'
	BEGIN --Native SQL Login

		SET @sql = 'osql -w 2000  -S '+ @MSSQLCentralActiveServer
			+ ' -U ' + @MSSQLCentralActiveUser
			+ ' -P ' + @MSSQLCentralActiveUserPW
			+ ' -d ' + @MSSQLCentralActiveDatabase
			+ ' -Q "EXEC [ubsmwe_GetInstanceID] ''' 
			+ CAST ( (ISNULL (  SERVERPROPERTY('InstanceName'), 'DEFAULT' )) as varchar(255))
			+ ''', ''' + CAST ( (ISNULL (  SERVERPROPERTY('MachineName'), @ActiveComputerName )) as varchar(255))
			+ ''', ''' + @ActiveComputerName + '''"'

		TRUNCATE TABLE #result

		INSERT INTO #result	
			EXEC master..xp_cmdshell @sql

		-- output to display
		SELECT @sql		
		SELECT * 
			FROM #result

		SELECT @RowCount = COUNT(Data) 
		FROM #result
		WHERE Data IS NOT NULL

		------------------------------------------------------------
		IF @RowCount = 1
		BEGIN
			-- SQL Central native SQL connection established
			SELECT TOP 1 @Data = SUBSTRING( Data,  8, len( Data ) ) 
			FROM #result where Data like 'ubsmwe_%'
			ORDER BY  ColOrder

			IF @Data IS NOT NULL 
			BEGIN
				SET @MSSQLCentralActiveLoginMethod = 'SQL'
				GOTO ENDIT
			END
		END
		ELSE --IF @RowCount <> 1 
		BEGIN
			IF @RowCount > 1
			BEGIN
				SELECT TOP 1 @Data = SUBSTRING( Data,  8, len( Data ) ) 
				FROM #result 
				WHERE Data like 'ubsmwe_%'
				ORDER BY  ColOrder

				SELECT @Data
				
				IF @Data IS NOT NULL AND @Data <> 'No Connection'
				BEGIN
					SET @MSSQLCentralActiveLoginMethod = 'SQL'
					GOTO ENDIT
				END -------------------
				ELSE -- Error
				BEGIN
					SELECT TOP 1 @Error1 = Data
					FROM #result 
					WHERE Data IS NOT NULL
					ORDER BY  ColOrder

					DELETE  FROM #result
					WHERE Data = @Error1

					SELECT TOP 1 @Error2 = Data
					FROM #result 
					WHERE Data IS NOT NULL
					ORDER BY  ColOrder

					SET @sqlError1 = 'Error - Connection type: SQL - when getting InstanceID from MSSQLCentral server '
						+ ISNULL(@MSSQLCentralActiveServer, 'No Server Info...') 
						+ '. See details and correct. Details: ' 
						+ ISNULL(@Error1, '') + ' - ' + ISNULL(@Error2, '')

					IF @Error1 LIKE '%Msg%'
					BEGIN
						EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1, 0, 1 --Send alert on the error
					END
					ELSE
					BEGIN
						EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1, 0, 0 --Do not send alert
					END
				END
			END
		ELSE ------------------------------------------------------------
		BEGIN
			SELECT @sqlError1 = 'Error - Connection type: SQL - No rows were returned and no error was encountered when getting InstanceID from MSSQLCentral server '
				+ ISNULL(@MSSQLCentralActiveServer, 'No Server Info...') 

			EXEC usp_LogErrors NULL ,0, N'usp_mscGetInstanceID', 'Connection Error: ',@sqlError1
		END
		
		END
	END --Native SQL Login

	IF @MSSQLCentralActiveLoginMethod <> 'No Connection'
		GOTO ENDIT

END --WHILE

NEXTLOOP:

SET @ConnectCounter = @ConnectCounter + 1

IF @ConnectCounter < 4
	GOTO STARTLOOP

------------------------------------------------------------	
ENDIT:
--Final processing...

IF @MSSQLCentralActiveLoginMethod = 'No Connection'
	OR @MSSQLCentralActiveLoginMethod IS NULL
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveLoginMethod' ,'No Connection'
	PRINT 'No Connection'
	RETURN 1
END
ELSE
IF @MSSQLCentralActiveLoginMethod IN ( 'Trusted', 'SQL' )
BEGIN
	IF @MSSQLCentralInstanceID = 'NOT SET YET' 
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveLoginMethod',	@MSSQLCentralActiveLoginMethod
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveServer',		@MSSQLCentralActiveServer
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveDatabase',	@MSSQLCentralActiveDatabase
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveUser',		@MSSQLCentralActiveUser
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveUserPW',		@MSSQLCentralActiveUserPW
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralInstanceID',		@Data
	END ----------------------------
	ELSE
	IF @MSSQLCentralInstanceID <> @Data
	BEGIN
		PRINT '@MSSQLCentralInstanceID from MSSQLCentral does not match local setting.'
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveLoginMethod',	@MSSQLCentralActiveLoginMethod
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveServer',		@MSSQLCentralActiveServer
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveDatabase',	@MSSQLCentralActiveDatabase
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveUser',		@MSSQLCentralActiveUser
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveUserPW',		@MSSQLCentralActiveUserPW
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralInstanceID',		@Data
	END ----------------------------
	ELSE 
	BEGIN
		PRINT 'Just updating the connection settings for this run of the UBSMWE.'
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveLoginMethod',	@MSSQLCentralActiveLoginMethod
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveServer',		@MSSQLCentralActiveServer
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveDatabase',	@MSSQLCentralActiveDatabase
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveUser',		@MSSQLCentralActiveUser
		EXEC @RC = [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'MSSQLCentralActiveUserPW',		@MSSQLCentralActiveUserPW
	END

END

IF OBJECT_ID('tempdb..#result') IS NOT NULL 
	DROP TABLE #result

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_PartialDatabaseBackup_fglist]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PartialDatabaseBackup_fglist] 
						@dbsDatabaseName varchar(128) 
						, @PartialBackupStringOut nvarchar(4000) OUTPUT

AS
/****************************************************************************************
// @File: usp_PartialDatabaseBackup_fglist.SQL
//
// Purpose:
//   Return string of filegroups that have been switched to read-only since last Partial Backup
//
// Notes: This stored procedure is called FROM main UBSMWE [usp_BackupDatabase_JobRun].
//
// Usage: DECLARE @ReturnValue nvarchar(4000)
//        EXEC [DBServices].[dbo].[usp_PartialDatabaseBackup_fglist] @dbsDatabaseName = '<DBNAME>', @PartialBackupStringOut = @ReturnValue  OUTPUT
//        SELECT ReturnValue=@ReturnValue
//
// History:
//
//   @Version: 6.0.0.10
//   @Author: Steve Trogub
//   @Date: 12/13/2010
//   @Action: Created
//   @Date: 12/13/2010 @Author: Steve Trogub @Version: UBSMWE 4.0 @Action: Added Partial Differential backup option
//   @Date: 07/31/2012 @Author: Steve Trogub @Version: UBSMWE 4.2 @Action: BUG Fix - misconfigured locale can be detected.
//   @Date: 17/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 BETA
//   @Date: 07/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 BETA
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd 
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @PartialBackupString as nvarchar(4000)                  
	, @LastPartialDate datetime
	, @LastModifiedDate datetime
	, @filegroup sysname
	, @readonly bit
	, @filename nvarchar(255)
	, @SQL nvarchar(4000)
	, @filefound bit
	, @dbsEuroOSDate bit
	, @cday tinyint
	, @cmonth tinyint
	, @cyear smallint
	, @fday tinyint
	, @fmonth tinyint
	, @fyear smallint
	, @FDateString varchar(10)
	, @RC int
	, @dbsInstanceFileLocation nvarchar(255)
	, @ErrorMsg nvarchar(255)

DECLARE @DirResults as TABLE (LastModified varchar(255))

IF OBJECT_ID('tempdb..#tbl_Partial_FGs') IS NOT NULL 
	DROP TABLE #tbl_Partial_FGs

CREATE TABLE #tbl_Partial_FGs ([filegroup] sysname
							, [filename] varchar(255)
							, [readonly] bit)

-----------------------------------
-- Get config

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT

SET @PartialBackupString = ''

SET @cday = DATEPART (DD, getdate()) 
SET @cmonth = DATEPART (MM, getdate())
SET @cyear = DATEPART (YYYY, getdate())

IF @cday = @cmonth
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsEuroOSDate', @dbsEuroOSDate OUTPUT

	IF @RC = 0
		GOTO ID_PARTIAL_BACKUP_DATE
	ELSE
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_PartialDatabaseBackup_fglist: Unable to determine if the SQL timelocale differs from the OS; parameter dbsEuroOSDate will need to me set manually' 

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	-- raise an error
		RETURN 1
	END
END

-----------------------------------
--Check if the SQL timelocale differs from OS  

IF RIGHT (@dbsInstanceFileLocation,1) <> '\'
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

SET @filegroup = '-'
SET @filename = @dbsInstanceFileLocation + 'localecheck'

PRINT 'Verifying if the MSSQL time locale differs from the OS'

SET @SQL = 'echo localecheck > ' + @filename 
	 + ' & for %I in (' + @dbsInstanceFileLocation + 'localecheck) do @echo %~tI'

INSERT @DirResults
EXEC master.dbo.xp_cmdshell @SQL					  
			
SELECT TOP 1 @FDateString = SUBSTRING(LTRIM(CAST(LastModified as varchar(40))) ,1,10) 
FROM @DirResults 
ORDER BY LastModified DESC									

SET @fday = CAST (SUBSTRING(@FDateString,1,2) as tinyint) 
SET @fmonth = CAST (SUBSTRING(@FDateString,4,2) as tinyint)

IF @fday = @cday 
	AND @fmonth = @cmonth 
BEGIN 
	PRINT 'OS= Euro date type DD/MM/YYYY' 
	SET @dbsEuroOSDate = 1 -- OS in Euro date format: DD/MM/YYYY
END ------------------
ELSE
IF @fday = @cmonth 
	AND @fmonth = @cday
BEGIN	
	PRINT 'OS= US date type MM/DD/YYYY'
	SET @dbsEuroOSDate = 0 -- OS in US date format: MM/DD/YYYY
END ------------------
ELSE
BEGIN -- Error
	SET @ErrorMsg = 'UBSMWE: usp_PartialDatabaseBackup_fglist: Unable to determine if the SQL timelocale differs from the OS; parameter dbsEuroOSDate will need to me set manually' 

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	-- raise an error
	RETURN 1
END ------------------

IF EXISTS (SELECT 1  
	FROM [DBServices].[dbo].dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'dbsEuroOSDate')
BEGIN
	IF (SELECT TOP 1 dbsInstanceConfigValue 
		FROM [DBServices].[dbo].dbsInstanceConfig
		WHERE dbsInstanceConfigName = 'dbsEuroOSDate') <> @dbsEuroOSDate
		EXEC DBServices.dbo.usp_ConfigureUBSMWE 'dbsEuroOSDate',@dbsEuroOSDate
END
ELSE
	EXEC DBServices.dbo.usp_ConfigureUBSMWE 'dbsEuroOSDate',@dbsEuroOSDate

EXEC DBServices.dbo.usp_DelFile	@filename

-----------------------------------
ID_PARTIAL_BACKUP_DATE:

-- Identify last Partial Backup Date
SELECT TOP 1 @LastPartialDate = backup_finish_date
FROM msdb..backupset bs WITH (NOLOCK)
INNER JOIN msdb..backupmediafamily bf WITH (NOLOCK)
	ON bs.media_set_id = bf.media_set_id
INNER JOIN msdb..backupmediaset bks WITH (NOLOCK)
	ON bs.media_set_id = bks.media_set_id
WHERE bs.database_name = @dbsDatabaseName 
	AND (type = 'P' OR type='D')
ORDER BY backup_finish_date DESC

SET @cday = DATEPART (DD, @LastPartialDate) 
SET @cmonth = DATEPART (MM, @LastPartialDate)
SET @cyear = DATEPART (YYYY, @LastPartialDate)

-----------------------------------
-- Identify all readonly filegroups

SET @SQL = 
	'INSERT INTO #tbl_Partial_FGs ([filegroup],[filename],[readonly])
	SELECT 
		  b.name as filegroup
		, a.physical_name as filename
		, b.is_read_only as readonly
	FROM ' + @dbsDatabaseName + '.sys.database_files a WITH (NOLOCK)
	INNER JOIN ' + @dbsDatabaseName + '.sys.filegroups b WITH (NOLOCK)
		ON a.data_space_id = b.data_space_id
	WHERE filegroup_guid IS NOT NULL'
EXEC (@SQL)	

DECLARE FILEGROUP_CURSOR CURSOR FORWARD_ONLY READ_ONLY 
FOR SELECT [filegroup], [filename], [readonly]
FROM #tbl_Partial_FGs
OPEN FILEGROUP_CURSOR

-- Loop through all the read-only filegroups, checking each file to see if it is older than @LastSuccessfulPartialBackupDate
FETCH NEXT FROM FILEGROUP_CURSOR
	INTO @filegroup, @filename, @readonly 
WHILE @@FETCH_STATUS = 0
BEGIN  
         
	EXEC [DBServices].[dbo].usp_FileExists @filename, @filefound OUTPUT

	IF @readonly = 1 AND @filefound = 1
	BEGIN -- RO Filegroup found

		DELETE FROM @DirResults

		SET @SQL = 'for %I in (' + @filename + ') do @echo %~tI'

		INSERT @DirResults
		EXEC master.dbo.xp_cmdshell @SQL					  		
		
		SELECT TOP 1 @FDateString = SUBSTRING(LTRIM(CAST(LastModified as varchar(40))) ,1,10)  
		FROM @DirResults
		ORDER BY LastModified DESC	

		SET @fyear = CAST (SUBSTRING(@FDateString,7,4) as smallint)

		IF @dbsEuroOSDate = 1
		BEGIN
			-- OS in Euro date format: DD/MM/YYYY
			SET @fday = CAST (SUBSTRING(@FDateString,1,2) as tinyint) 
			SET @fmonth = CAST (SUBSTRING(@FDateString,4,2) as tinyint)	
		END ---------------------------
		ELSE 
		BEGIN
			-- OS in US date format: MM/DD/YYYY
			SET @fmonth = CAST (SUBSTRING(@FDateString,1,2) as tinyint) 
			SET @fday = CAST (SUBSTRING(@FDateString,4,2) as tinyint)
		END ---------------------------
	END

	----------------------------------------------
	--Verify if filegroup was set to read-only on or after the last partial backup

	IF @fyear >= @cyear -- 	IF @LastModifiedDate >= @LastPartialDate
		AND @fmonth >= @cmonth 
		AND @fday >= @cday 
	BEGIN    
		PRINT 'Info: Filegroup: ' + @filegroup + ', File: ' + @filename
			+  ' was set to ReadOnly on: ' + @FDateString
			+ ' - which is after the last partial backup' 

		SET @PartialBackupString = @PartialBackupString 
			+ ' , FILEGROUP=' + '''' + CAST(@filegroup as  nvarchar(128)) + ''''
	END                
      
	FETCH NEXT FROM FILEGROUP_CURSOR 
	INTO @filegroup, @filename ,@readonly
END
CLOSE FILEGROUP_CURSOR
DEALLOCATE FILEGROUP_CURSOR

IF OBJECT_ID('tempdb..#tbl_Partial_FGs') IS NOT NULL 
	DROP TABLE #tbl_Partial_FGs

SET @PartialBackupString = ' READ_WRITE_FILEGROUPS '  +  @PartialBackupString  
SET @PartialBackupStringOut =  @PartialBackupString

-- Success
RETURN 0

---------------------------
DT_PARSE_ERROR:
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_PartialDatabaseBackup_fglist: DateTime parsing error for filegroup: ' + @filegroup 
		+ ' filename: ' + @filename
		+ ' whilst parsing: ' + @FDateString 
		+ ' Investigation required.' 

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	-- raise an error
	
	CLOSE FILEGROUP_CURSOR
	DEALLOCATE FILEGROUP_CURSOR
	
	IF OBJECT_ID('tempdb..#tbl_Partial_FGs') IS NOT NULL 
		DROP TABLE #tbl_Partial_FGs

	RETURN 1
END

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_PopulatedbsInstance]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PopulatedbsInstance] 	@dbsInstanceFileLocation nvarchar(255) = NULL,
						@dbsIsInstanceClusteredFlag bit = 0,
						@dbsExcludeAllUserDatabases bit = 0
AS

/****************************************************************************************
// @File: usp_PopulatedbsInstance.SQL
// 
// Purpose:
//   Populate dbsInstance with backup file location and instance name...
//
// Notes: This stored procedure is only used during initial install. 
// This will be automated at some point but for now will have to be 
// executed by hand during install.
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: 1.0.0 @Action:  Change for addition of more values.
//   @Date: 08/09/2004 @Author: Kevin Wagner @Version: 1.0.0 @Action: Updated for Netbackup 
//   @Date: 04/11/2004 @Author: Kevin Wagner @Version: 1.5.0 @Action: Updated for SMB defaults
//   @Date: 07/11/2004 @Author: Kevin Wagner @Version: 1.5.2 @Action: Updated for SMB requirements (@dbsExcludeAllUserDatabases)
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 24/02/2005 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated 'dbsRetainBackupFileDurationHrs' to hold more backups during initial install, old default was 48 hrs new = 7 days = 168 hrs.
//   @Date: 16/03/2005 @Author: Kevin Wagner @Version: 1.5.2 HF2 @Action: included dbsLocalHistoryRetainDays allowing for the purging of outdated information from the local DBServices database.
//   @Date: 16/03/2005 @Author: Kevin Wagner @Version: 1.5.2 HF2 @Action:SPECIAL NOTE, This stored proc will be depricated with the release of the new and enhanced install procedures. All defaults will come from a central site and/or xml file if central site is not configured.
//   @Date: 31/03/2005 @Author: Kevin Wagner @Version: 1.5.2 HF2 @Action: Added new config param called 'dbsLocalHistoryRetainDays'with a default of '90' days 
//   @Date: 11/05/2005 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated 'dbsRetainBackupFileDurationHrs' to hold 23 hrs of backups according to Khin Yoo.
//   @Date: 09/02/2006 @Author: Rakesh Bist  @Version: 1.5.3  @Action: Added dbsWFTasksConfigured,dbsWFStatus,dbsWFLogretention for WorkFlow.
//   @Date: 27/04/2006 @Author: Rakesh Bist  @Version: 2.0    Proc used unsupported SP - 'master.dbo.sp_MSget_file_existence'
							      Now does not exists in SS2005, replaced with new routine usp_FileExists  to check file existenance.
//   @Date: 18/10/2006 @Author: Kevin Wagner @Version: 2.0.7  @Action: Changed version info to 2.0.7
//   @Date: 19/10/2006 @Author: Kevin Wagner @Version: 2.0.8  @Action: Changed version info to 2.0.8
//   @Date: 25/10/2006 @Author: Kevin Wagner @Version: 2.0.9  @Action: Changed version info to 2.0.9 for issue#34.
//   @Date: 25/10/2006 @Author: Kevin Wagner @Version: 2.0.10  @Action: Changed version info to 2.0.10 for issue with dateformat.
//   @Date: 18/12/2006 @Author: Kevin Wagner @Version: 2.5.0  @Action: Changed version info to 2.5.0 and added default param for Netbackup and IncludeReadOnlyBackups.
//   @Date: 07/02/2007 @Author: Kevin Wagner @Version: 2.5.1  @Action: Changed version info to 2.5.1 
//   @Date: 27/02/2007 @Author: Kevin Wagner @Version: 2.5.2  @Action: Changed version info to 2.5.2 
//   @Date: 02/03/2007 @Author: Kevin Wagner @Version: 2.5.2  @Action: Changed MSSQLCentral to point to production server.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Final release to production
//   @Date: 15/02/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production - Added new settings
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//   @Date: 25/04/2008 @Author: Kevin Wagner @Version: 2.5.4 @Action: RC4 testing.
//   @Date: 25/09/2008 @Author: Kevin Wagner @Version: 2.5.4 RC5 @Action: Added config for DisableBackupInformationalMessages
//   @Date: 21/09/2009 @Author: Kevin Wagner @Version: 2.5.4.2 @Action: Updated version to 2.5.4.2
//   @Date: 06/10/2013 @Author: Steve Trogub @Version: 5.0.2 @Action: Updated version to 5.0.5
//	 @Date: 11/02/2014 @Auther Andrew Calvett @Version: 5.0.10 @Action: Added settings for Grouped Subclients
//	 @Date: 29/07/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 Beta 
//	 @Date: 20/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta 
//	 @Date: 03/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//	 @Date: 07/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta 
//	 @Date: 29/10/2014 @Author: Chris Basson @Version: 6.0.0.9 @Action: TRRv3 Beta 
//	 @Date: 10/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta 
//	 @Date: 14/11/2014 @Author: Chris Basson @Version: 6.0.0.12 @Action: TRRv3 Beta 
//	 @Date: 09/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta 
//	 @Date: 09/01/2015 @Author: Chris Basson @Version: 6.0.0.20 @Action: TRRv3 Release 
//	 @Date: 10/02/2015 @Author: Chris Basson @Version: 6.0.0.25 @Action: Feature request: add DB backup monitoring for CV TRRv3 
//	 @Date: 16/03/2015 @Author: Chris Basson @Version: 6.0.0.27 @Action: Fixed dbsExcludeAllUserDatabases 
//	 @Date: 31/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Feature request: set default DisableMSSQLCentral = 1, TRR-132 Feature: DB file backup subfolders
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
//	 @Date: 24/11/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Feature request: Long running Sunday Workflow alert (dbsMaintLongRunConcernHrs), set default IndexRetryMaxTimes = 15 (was 0)
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @newid			nvarchar(255)
	, @InstanceName		nvarchar(64)
	, @FolderName		nvarchar(128)
	, @Drive			char(1)
	, @FileExist		int
	, @AStr				nvarchar(128)

PRINT '/************************************************************************************************************/'
PRINT 'Start Running of usp_PopulatedbsInstance at ' + CONVERT ( varchar ( 255 )  , getdate() , 114  )+ ' on ' + CONVERT(sysname, SERVERPROPERTY('ServerName'))

PRINT CHAR(13) + '=> For reference DBServices.dbo.dbsInstanceConfig values PRIOR update:'
SELECT RTRIM(LTRIM(dbsInstanceConfigName)) as 'dbsInstanceConfigName'
		, RTRIM(LTRIM(dbsInstanceConfigValue)) as 'dbsInstanceConfigValue'
FROM DBServices.dbo.dbsInstanceConfig
PRINT CHAR(13) + '----------------------------------------------------------------'

IF @dbsInstanceFileLocation IS NOT NULL
BEGIN
	EXEC DBServices.dbo.usp_FileExists  @dbsInstanceFileLocation, @FileExist output

	IF @FileExist =  0
		PRINT ' Warning *** Backup directory ' + @dbsInstanceFileLocation + ' does not exists ***'
END

SET @newid = newid()

------------------
-- Engine

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsVersion')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsVersion', '6.0.0.0' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'ActiveComputerName')
BEGIN
	SET @AStr = CAST (SERVERPROPERTY ('MachineName') as nvarchar(128))
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'ActiveComputerName', @AStr
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsInstanceUID')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsInstanceUID', @newid 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsInstanceName')
BEGIN
	SET @AStr = CONVERT(sysname, SERVERPROPERTY('ServerName')) 
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsInstanceName', @AStr
END

EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'UBSMWE_Error_Status', '0'

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsIsInstanceClusteredFlag')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsIsInstanceClusteredFlag',@dbsIsInstanceClusteredFlag 
END

IF @dbsInstanceFileLocation IS NOT NULL
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsInstanceFileLocation', @dbsInstanceFileLocation 
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_WorkDirectory',  @dbsInstanceFileLocation
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsLocalHistoryRetainDays')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsLocalHistoryRetainDays', '30' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsExcludeAllUserDatabases')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsExcludeAllUserDatabases', @dbsExcludeAllUserDatabases
END

--IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'UBSMWE_Errors_retentionDays')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'UBSMWE_Errors_retentionDays', '10' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsWFStatus')
BEGIN	
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsWFStatus', '1'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsWFTasksConfigured')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsWFTasksConfigured', 'Yes'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IncludeReadOnlyBackups')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IncludeReadOnlyBackups', '1' --Default to true for the IB
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'SendAlertOnIndividualFilePurgeErrors')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'SendAlertOnIndividualFilePurgeErrors', '0' --Default to false for the IB
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MainCycleCountMinutes')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MainCycleCountMinutes', '660' --If setting does not exist, set to default of 660min (11 hrs)
END	

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'DisableBackupInformationalMessages')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'DisableBackupInformationalMessages', '1' 
END	

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'DeleteRetryCount')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'DeleteRetryCount', '10' 
END	

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'DeleteRetryIntervalSeconds')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'DeleteRetryIntervalSeconds', '5' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsJobLogPathOverride')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsJobLogPathOverride', '' 
END

------------------
-- DB Backup

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDatabaseFullBackupStartTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseFullBackupStartTime', '00:01' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDatabaseLogBackupStartTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseLogBackupStartTime', '00:10' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDatabaseLogBackupIntervalMinute')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseLogBackupIntervalMinute', '10' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDatabaseLogBackupEndTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseLogBackupEndTime', '23:59' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsRetainBackupFileDurationHrs')
BEGIN
--Updated 'dbsRetainBackupFileDurationHrs' to hold 23 hrs of backups according to Khin Yoo.
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsRetainBackupFileDurationHrs', '23' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDiffBackup')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDiffBackup', 0
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDiffnPartFullBackupAlignDay')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDiffnPartFullBackupAlignDay', 1
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDiffBackupThreshold')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDiffBackupThreshold', 47 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsBackupProcessor')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsBackupProcessor', '1' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'debug')
BEGIN
 	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'debug', '0'
END

--Control Variable for Striped Backups
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsStripeSet')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsStripeSet', '1' 
END	
	
--Filegroup Backup control variable
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsFGRPBackup')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsFGRPBackup', 0
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsUpdateStatsMaxRetryMins')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsUpdateStatsMaxRetryMins', 300
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsUpdateStatsASAP')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsUpdateStatsASAP', 0
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsFSBakMinHrs')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsFSBakMinHrs', '11' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsBakFullConcernHrs')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsBakFullConcernHrs', '180'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsBakDiffConcernHrs')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsBakDiffConcernHrs', '36' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsBakTlogConcernMins')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsBakTlogConcernMins', '30'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDBBackupChk_SleepDT')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDBBackupChk_SleepDT', NULL
END

------------------
-- Netbackup / CV FS Backup

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_BPBackup_ExecutableLocation')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_BPBackup_ExecutableLocation', 'C:\Program Files\Veritas\Netbackup\bin\bpbackup.exe'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_Enabled')
BEGIN
	--Netbackup will be off unless configured by usp_ConfigureNetbackup
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_Enabled', '0'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_WindowFlag')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_WindowFlag', '1'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_WindowStartTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_WindowStartTime', '03:00'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_WindowEndTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_WindowEndTime', '23:30'
END

SET @AStr = 'NB_Class_' + CAST(SERVERPROPERTY ('ComputerNamePhysicalNetBIOS') as nvarchar(128))
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = @AStr)
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig  @AStr, 'N/A'
END

-- Reset NetbackupErrorCount to 0
EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NetbackupErrorCount',  '0'

/*
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'NB_OKToExecuteFlag')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'NB_OKToExecuteFlag',  '0'
END
*/

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsFSDBSubfolders')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsFSDBSubfolders', 0
END

------------------
-- MS SQL Central


IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'DisableMSSQLCentral')
BEGIN	
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'DisableMSSQLCentral', 1
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralPrimaryServer')
BEGIN	
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralPrimaryServer', 'mscentral.sputnik.loadb.ubs.net'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralPrimaryDatabase')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralPrimaryDatabase', 'MSSQLCentral'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralPrimaryUser')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralPrimaryUser', 'UBSMWE_Remote'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralPrimaryUserPW')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralPrimaryUserPW', '62BD8D0D-8089-4F8E-8CAF-F5B460ADB7b3'
END

------

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateServer1')
BEGIN	
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateServer1', ''
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateDatabase1')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateDatabase1', 'MSSQLCentral'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateUserPW1')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateUser1', 'UBSMWE_Remote'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateUserPW1')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateUserPW1', ''
END

------

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateServer2')
BEGIN	
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateServer2', ''
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateDatabase2')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateDatabase2', 'MSSQLCentral'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateUserPW2')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateUser2', 'UBSMWE_Remote'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateUserPW2')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateUserPW2', ''
END

------

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateServer3')
BEGIN	
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateServer3', ''
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateDatabase3')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateDatabase3', 'MSSQLCentral'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateUserPW3')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateUser3', 'UBSMWE_Remote'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralAlternateUserPW3')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralAlternateUserPW3', ''
END

------

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MSSQLCentralInstanceID')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MSSQLCentralInstanceID', 'NOT SET YET' --Default to Not Set for 2.5.3
END

------------------
-- Thresholds / Threads

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'LiteSpeedThreads')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'LiteSpeedThreads', '3' 
END		

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MaxConcurrentBUFull')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MaxConcurrentBUFull', '4' 
END		

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MaxConcurrentBULog')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MaxConcurrentBULog', '4' 
END		

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MaxConcurrentDBCheck')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MaxConcurrentDBCheck', '3' 
END		

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MaxConcurrentIDXReBld')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MaxConcurrentIDXReBld', '2' 
END		

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MaxConcurrentIDXUpdSt')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MaxConcurrentIDXUpdSt', '5' 
END		

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MAXDOP')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MAXDOP', '0' 
END	

--Paul Davies requested making the transize value configurable via dbsintanceconfig table
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'MaxTransLogPct')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'MaxTransLogPct', '60' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsMaintLongRunConcernHrs')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsMaintLongRunConcernHrs', NULL 
END	

------------------
-- DBCC 

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDatabaseDBCCStartTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseDBCCStartTime', '02:00' 
END

--WITH_PHYSICAL_ONLY dbcc option
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'WITH_PHYSICAL_ONLY')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'WITH_PHYSICAL_ONLY', 0
END

------------------
-- Netbackup

--places .trn files before .bak file sin manifest so they ar enot deleted before their turn in queue arives
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'SEGREGATE_MANIFEST')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'SEGREGATE_MANIFEST', 0
END

--places .trn files before .bak file sin manifest so they ar enot deleted before their turn in queue arives
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'SEGREGATE_MANIFEST')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'SEGREGATE_MANIFEST', 0
END

--BUFFERCOUNT Native Backup Config variable
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsBUFFERCOUNT')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsBUFFERCOUNT', 20
END

--MAXTRANSFERSIZE Native Backup Config variable
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsMAXTRANSFERSIZE')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsMAXTRANSFERSIZE', 4194304
END

------------------
--COMMVAULT VARIABLES

EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseCVTimeoutMinutes', '1380' 

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_RootPath')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_RootPath', 'C:\Program Files\CommVault'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_BRATPath')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_BRATPath', 'C:\Program Files\CommVault\Simpana\Base\Brat\bin'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_Backup_ExecutableLocation')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_ExecutableLocation', 'C:\Program Files\CommVault\UBS\CVBackup\cvbackup.cmd'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_Enabled')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_Enabled', 0
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVbackupErrorCount')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVbackupErrorCount', 0
END

-- Suspect TRRv1 legacy junk
/*
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVPrimaryUser')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVPrimaryUser', 'ENG\svc_eng_cv_sql'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVPrimaryUserPW')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVPrimaryUserPW', '3c251e1169b17c8f6501bb117dc9e45c58620f97a8949c263'
END
	
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVLoginattempts')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVLoginattempts', 3
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVLoginDelay')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVLoginDelay', '00:00:15'
END

-- TRRv1 - no longer applicable
IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_Policy')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_Policy', 'SP_DB_01'
END
*/

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVFQDNCommCell')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVFQDNCommCell', 'not_configured'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_RET')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_RET', 'LTR'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_REGISTERED')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_REGISTERED', '0'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CVTRRurl')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CVTRRurl', 'not_configured'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_Parallel_Ops')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_Parallel_Ops', '1'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsForceCVKill')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsForceCVKill', '0'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_SubclientGroupingType')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_SubclientGroupingType', '0'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_NumSubclientGroups')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_SubclientGroupingNumGroups', '4'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_FSIncSysDB')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_FSIncSysDB',  '1'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'CV_BRATver')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'CV_BRATver', 'N/A'
END


------------------
-- Reindexing

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsDatabaseIDXReorgStartTime')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsDatabaseIDXReorgStartTime', '03:00' 
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexFragmentationLimitPercent')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexFragmentationLimitPercent', '10' 
END	

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexTblLockCheck')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexTblLockCheck', '0'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexFailovertoREORG')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexFailovertoREORG', '1'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexRetryDelay')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexRetryDelay', '00:01'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexRetryMaxTimes')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexRetryMaxTimes', '15'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexDeadline')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexDeadline', NULL
END


IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexRebuildOnline')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexRebuildOnline', '0'
END

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'IndexSortinTempDB')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'IndexSortinTempDB', '0'
END

------------------
-- Backup LUN space Mon

IF NOT EXISTS (SELECT 1 FROM DBServices.dbo.dbsInstanceConfig WHERE dbsInstanceConfigName = 'dbsBackupLUN_SpaceThresholdPerc')
BEGIN
	EXEC DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsBackupLUN_SpaceThresholdPerc', '10'
END

------------------------------------------------------------------------------------------

PRINT CHAR(13) + '----------------------------------------------------------------'
PRINT CHAR(13) + '=> For reference DBServices.dbo.dbsInstanceConfig values POST update:' 
SELECT RTRIM(LTRIM(dbsInstanceConfigName)) as 'dbsInstanceConfigName'
		, RTRIM(LTRIM(dbsInstanceConfigValue)) as 'dbsInstanceConfigValue'
FROM DBServices.dbo.dbsInstanceConfig

PRINT 'Finished Running of usp_PopulatedbsInstance at ' + CONVERT ( varchar ( 255 )  , getdate() , 114  ) + ' on ' + CONVERT(sysname, SERVERPROPERTY('ServerName'))
PRINT '/************************************************************************************************************/'

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Configurations]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Configurations]
AS
   -- Version 3
   
   SET NOCOUNT ON
   
   DECLARE @cmd     NVARCHAR(4000)
   DECLARE @version NUMERIC(2,0)
      
   SET @version = (@@MICROSOFTVERSION / 0x1000000) & 0xFF

   IF (@version = 8)
	   SET @cmd = 'SELECT comment                AS [Name], ' +
                  '       CONVERT(BIGINT, value) AS [Value] ' +
                  'FROM   master.dbo.syscurconfigs '
   ELSE
	   SET @cmd = 'SELECT name                          AS [Name], ' +
                  '       CONVERT(BIGINT, value_in_use) AS [Value] ' +
                  'FROM   sys.configurations '

   EXEC(@cmd)

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Database_Roles]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Database_Roles]
       @IncludeSystemObjects BIT
AS
   -- Version: 3
   
   SET NOCOUNT ON
   
   DECLARE @dbname   NVARCHAR(128)
   DECLARE @status   NVARCHAR(128)
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(DBName NVARCHAR(128), Status NVARCHAR(128))

   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2

   CREATE TABLE dbo.#temp2(DBName NVARCHAR(128), Role NVARCHAR(128))
    
   -- Get the list of Databases and their status
   IF (@version = 8)
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master..sysdatabases'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' WHERE name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
   ELSE
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master.sys.databases WHERE source_database_id IS NULL'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' AND name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
        
   INSERT dbo.#temp1
   EXEC(@cmd)
        
   DECLARE query_cursor CURSOR 
   FOR SELECT DBName, Status
       FROM   dbo.#temp1

   OPEN query_cursor

   FETCH NEXT FROM query_cursor INTO @dbname, @status

   WHILE @@FETCH_STATUS = 0
   BEGIN

      IF (@status = 'ONLINE')
      BEGIN
         IF (@version = 8)
            SET @cmd = 'SELECT  ''' + @dbname + ''', name ' + 
                       'FROM [' + @dbname + ']..sysusers ' +
                       'WHERE issqlrole = 1 AND name NOT IN (''public'')'
         ELSE
            SET @cmd = 'SELECT  ''' + @dbname + ''', name ' + 
                       'FROM [' + @dbname + '].sys.database_principals ' +
                       'WHERE Type = ''R'' AND name NOT IN (''public'')'
                    
         INSERT dbo.#temp2
         EXEC(@cmd)
      
      END

      FETCH NEXT FROM query_cursor INTO @dbname, @status
   END

   CLOSE query_cursor
   DEALLOCATE query_cursor
   
   SELECT DBName    AS [Database],
          Role      AS [Role] 
   FROM   dbo.#temp2
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
      
    IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2


GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Database_Space_History]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Database_Space_History]
       @IncludeSystemObjects BIT
AS
   -- Version: 3.2
   
   SET NOCOUNT ON
   
   DECLARE @dbname   NVARCHAR(128)
   DECLARE @status   NVARCHAR(128)
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(DBName NVARCHAR(128), Status NVARCHAR(128))

   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2

   CREATE TABLE dbo.#temp2(DBName NVARCHAR (255), Filegroup NVARCHAR (255), SizeMB INT, UsedMB INT)
    
   -- Get the list of Databases and their status
   IF (@version = 8)
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master..sysdatabases'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' WHERE name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
   ELSE
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master.sys.databases WHERE source_database_id IS NULL'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' AND name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
     
   INSERT dbo.#temp1
   EXEC(@cmd)
        
   DECLARE query_cursor CURSOR 
   FOR SELECT DBName, Status
       FROM   dbo.#temp1

   OPEN query_cursor

   FETCH NEXT FROM query_cursor INTO @dbname, @status

   WHILE @@FETCH_STATUS = 0
   BEGIN

      IF (@status = 'ONLINE')
      BEGIN
         IF (@version = 8)
            -- SQL 2000 not supported
            break
         ELSE
            SET @cmd = 'USE [' + @dbname + '];' +
                       'SELECT '+ ''''+ @dbname +'''' +', ' +
                               ' CASE df.type_desc 
                                    WHEN ''LOG'' 
                                    THEN ''TLOG'' 
                                    ELSE (SELECT SUBSTRING(MIN([name]), 1,30) 
                                          FROM sys.data_spaces AS ds 
                                          WHERE ds.data_space_id = df.data_space_id) 
                                 END,
                                 SizeMB = SUM(Size * 8 / 1024),
                                 UsedMB = ISNULL(SUM(FILEPROPERTY(Name,''SpaceUsed'') / 128), 0)
                                 FROM     sys.database_files AS df
                        GROUP BY df.data_space_id, df.type_desc,df.physical_name
                        ORDER BY 1'
                    
         INSERT dbo.#temp2
         EXEC(@cmd)
      
      END

      FETCH NEXT FROM query_cursor INTO @dbname, @status
   END

   CLOSE query_cursor
   DEALLOCATE query_cursor
   
   SELECT   DBName           AS [Database], 
            Filegroup        AS [Filegroup], 
	        SUM(SizeMB)      AS [SizeMB], 
	        SUM(UsedMB)      AS [UsedMB]
   FROM     dbo.#temp2
   GROUP BY DBName, Filegroup
   ORDER BY DBName, Filegroup
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
      
    IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2


GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Database_Users_To_Roles]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Database_Users_To_Roles]
       @IncludeSystemObjects BIT
AS
   -- Version: 3
   
   SET NOCOUNT ON
   
   DECLARE @dbname   NVARCHAR(128)
   DECLARE @status   NVARCHAR(128)
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(DBName NVARCHAR(128), Status NVARCHAR(128))

   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2

   CREATE TABLE dbo.#temp2(DBName NVARCHAR(128), Username NVARCHAR(128), Role NVARCHAR(128))
    
   -- Get the list of Databases and their status
   IF (@version = 8)
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master..sysdatabases'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' WHERE name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
   ELSE
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master.sys.databases WHERE source_database_id IS NULL'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' AND name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
      
   INSERT dbo.#temp1
   EXEC(@cmd)
        
   DECLARE query_cursor CURSOR 
   FOR SELECT DBName, Status
       FROM   dbo.#temp1

   OPEN query_cursor

   FETCH NEXT FROM query_cursor INTO @dbname, @status

   WHILE @@FETCH_STATUS = 0
   BEGIN

      IF (@status = 'ONLINE')
      BEGIN
         IF (@version = 8)
            SET @cmd = 'SELECT ''' + @dbname + ''', u1.name, u2.name ' +
                       'FROM   [' + @dbname + ']..sysusers u1 ' +
                       'JOIN   [' + @dbname + ']..sysmembers m ON u1.uid = m.memberuid AND u1.islogin = 1 ' +
                       'JOIN   [' + @dbname + ']..sysusers u2  ON m.groupuid = u2.uid ' +
                       'WHERE  u1.name NOT IN (''dbo'',''guest'') ' +
                       'AND    u1.name NOT LIKE ''NT AUTHORITY%'''
         ELSE
            SET @cmd = 'SELECT ''' + @dbname + ''', dp1.name ,dp2.name ' +
                       'FROM   [' + @dbname + '].sys.database_principals dp1 ' +
                       'JOIN   [' + @dbname + '].sys.database_role_members drm ON dp1.principal_id      = drm.member_principal_id ' +
                       'JOIN   [' + @dbname + '].sys.database_principals dp2   ON drm.role_principal_id = dp2.principal_id ' +
                       'WHERE  dp1.type IN (''S'',''U'',''G'') ' +
                       'AND    dp1.name NOT IN (''MS_DataCollectorInternalUser'',''dbo'',''guest'') ' +
                       'AND    dp1.name NOT LIKE ''#%'' ' +
                       'AND    dp1.name NOT LIKE ''NT AUTHORITY%'''
            
         INSERT dbo.#temp2
         EXEC(@cmd)
      END

      FETCH NEXT FROM query_cursor INTO @dbname, @status
   END

   CLOSE query_cursor
   DEALLOCATE query_cursor
   
   SELECT DBName    AS [Database],
          Username  AS [Username],
          Role      AS [Role]
   FROM   dbo.#temp2
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
      
    IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2


GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Databases]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Databases]
AS
   -- Version: 3
   
   SET NOCOUNT ON
   
   DECLARE @dbname   NVARCHAR(128)
   DECLARE @status   NVARCHAR(128)
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1 (
   DBName           NVARCHAR(128),
   Owner            NVARCHAR(128),
   Status           NVARCHAR(128), 
   ReadOnly         BIT,
   Collation        NVARCHAR(128),
   CompatLevel      INT,
   RecoveryModel    NVARCHAR(32),
   Containment      TINYINT       NULL,
   DBSnapshot       NVARCHAR(128) NULL,
   DataSizeMB       INT           NULL,
   DataUsedMB       INT           NULL,
   LogSizeMB        INT           NULL,
   LogUsedMB        INT           NULL,
   FilestreamSizeMB INT           NULL,
   FilestreamUsedMB INT           NULL,
   FulltextSizeMB   INT           NULL,
   FulltextUsedMB   INT           NULL,
   LastBackup       DATETIME      NULL)
   
   -- 2000
   IF (@version = 8)
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,SUSER_SNAME(sid)), ' +
                 'CONVERT(NVARCHAR,DATABASEPROPERTYEX(name, ''Status'')), ' +
                 'CONVERT(BIT,DATABASEPROPERTY(name,''IsReadOnly'')), ' +
		         'CONVERT(NVARCHAR,DATABASEPROPERTYEX(name, ''Collation'')), cmptlevel, ' +
		         'CONVERT(NVARCHAR,DATABASEPROPERTYEX(name, ''Recovery'')) ' +
                 'FROM   master..sysdatabases'
      INSERT dbo.#temp1(DBName, Owner, Status, ReadOnly, Collation, CompatLevel, RecoveryModel)
      EXEC(@cmd) 
   END
   
   -- 2005, 2008 and 2008 R2
   IF (@version = 9 OR @version = 10)
   BEGIN
      SET @cmd = 'SELECT name, SUSER_SNAME(owner_sid), state_desc, is_read_only, collation_name, compatibility_level, ' +
                 'recovery_model_desc, DB_NAME(source_database_id) ' +
                 'FROM   sys.databases'
      INSERT dbo.#temp1(DBName, Owner, Status, ReadOnly, Collation, CompatLevel, RecoveryModel, DBSnapshot)
      EXEC(@cmd) 
   END
   
   -- 2012 +
   IF (@version >= 11)
   BEGIN
      SET @cmd = 'SELECT name, SUSER_SNAME(owner_sid), state_desc, is_read_only, collation_name, compatibility_level, ' +
                 'recovery_model_desc, DB_NAME(source_database_id), containment ' +
                 'FROM   sys.databases'
      INSERT dbo.#temp1(DBName, Owner, Status, ReadOnly, Collation, CompatLevel, RecoveryModel, DBSnapshot, Containment)
      EXEC(@cmd) 
   END
   
   -- Set the Last Backup Time
   UPDATE T1
   SET    T1.LastBackup = B.LastBackup
   FROM   dbo.#temp1 AS T1
   JOIN   (SELECT    database_name           AS DBName, 
                     MAX(backup_finish_date) AS LastBackup
           FROM      msdb.dbo.backupset
           GROUP BY  database_name
          ) AS B ON (T1.DBName = B.DBName)
   
   DECLARE query_cursor CURSOR 
   FOR SELECT DBName, Status
       FROM   dbo.#temp1

   OPEN query_cursor

   FETCH NEXT FROM query_cursor INTO @dbname, @status

   WHILE @@FETCH_STATUS = 0
   BEGIN

      IF (@status = 'ONLINE')
      BEGIN
         IF (@version = 8)
            SET @cmd = 'USE [' + @dbname + '];' +
                       'CREATE TABLE #data(Fileid int NOT NULL, [FileGroup] int NOT NULL, TotalExtents int NOT NULL, UsedExtents int NOT NULL, [Name] sysname NOT NULL, [FileName] varchar(300) NOT NULL); ' +
                       'CREATE TABLE #log(dbname sysname NOT NULL, LogSize numeric(15,7) NOT NULL, LogUsed numeric(9,5) NOT NULL, Status int NOT NULL); ' +
                       'INSERT #data ' +
                       'EXEC(''DBCC showfilestats with no_infomsgs''); ' +
                       'INSERT #log ' +
                       'EXEC(''DBCC sqlperf(logspace) with no_infomsgs''); ' +
                       'UPDATE dbo.#temp1 ' +
                       'SET    DataSizeMB = (SELECT SUM(TotalExtents * 64 / 1024) FROM #data), ' +
                              'DataUsedMB = (SELECT SUM(UsedExtents * 64 / 1024) FROM #data), ' +
	                          'LogSizeMB  = (SELECT FLOOR(LogSize) FROM #log WHERE dbname = ''' + @dbname + '''), ' +
                              'LogUsedMB  = (SELECT FLOOR(LogSize * (LogUsed/100)) FROM #log WHERE dbname = ''' + @dbname + ''') ' +
                       'WHERE  DBName = ''' + @dbname + ''''
         ELSE
            SET @cmd = 'USE [' + @dbname + '];' +
                       'UPDATE dbo.#temp1 ' +
                       'SET    DataSizeMB       = (SELECT SUM(size * 8 / 1024) FROM [' + @dbname + '].sys.database_files WHERE type = 0), ' +
                              'DataUsedMB       = (SELECT SUM(FILEPROPERTY(name,''SpaceUsed'') / 128) FROM [' + @dbname + '].sys.database_files WHERE type = 0), ' +
	                          'LogSizeMB        = (SELECT SUM(size * 8 / 1024) FROM [' + @dbname + '].sys.database_files WHERE type = 1), ' +
                              'LogUsedMB        = (SELECT SUM(FILEPROPERTY(name,''SpaceUsed'') / 128) FROM [' + @dbname + '].sys.database_files WHERE type = 1), ' +
	                          'FilestreamSizeMB = (SELECT SUM(size * 8 / 1024) FROM [' + @dbname + '].sys.database_files WHERE type = 2), ' +
                              'FilestreamUsedMB = (SELECT SUM(FILEPROPERTY(name,''SpaceUsed'') / 128) FROM [' + @dbname + '].sys.database_files WHERE type = 2), ' +
	                          'FulltextSizeMB   = (SELECT SUM(size * 8 / 1024) FROM [' + @dbname + '].sys.database_files WHERE type = 4), ' +
                              'FulltextUsedMB   = (SELECT SUM(FILEPROPERTY(name,''SpaceUsed'') / 128) FROM [' + @dbname + '].sys.database_files WHERE type = 4) ' +
                       'WHERE  DBName = ''' + @dbname + ''''
            
			EXEC(@cmd)
      END

      FETCH NEXT FROM query_cursor INTO @dbname, @status
   END

   CLOSE query_cursor
   DEALLOCATE query_cursor
      
   SELECT DBName            AS [Database],
          Owner             AS [Owner],
          Status            AS [Status], 
          ReadOnly          AS [ReadOnly],
          Collation         AS [Collation],
          CompatLevel       AS [CompatLevel],
          RecoveryModel     AS [RecoveryModel],
          Containment       AS [Containment],
          DBSnapshot        AS [DBSnapshot],
          DataSizeMB        AS [DataSizeMB],
          DataUsedMB        AS [DataUsedMB],
          LogSizeMB         AS [LogSizeMB],
          LogUsedMB         AS [LogUsedMB],
          FilestreamSizeMB  AS [FilestreamSizeMB],
          FilestreamUsedMB  AS [FilestreamUsedMB],
          FulltextSizeMB    AS [FulltextSizeMB],
          FulltextUsedMB    AS [FulltextUsedMB],
          LastBackup        AS [LastBackup]
   FROM   dbo.#temp1
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Instances]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Instances]
   @Host NVARCHAR(128)
AS
   -- Version: 3
   
   SET NOCOUNT ON
   
   DECLARE @cmd        NVARCHAR(4000)
   DECLARE @major      NUMERIC(4,2)
   DECLARE @minor      NUMERIC(4,2)
   DECLARE @majorminor NUMERIC(4,2)
   DECLARE @res        INT
   DECLARE @mode       INT
   DECLARE @CreateDate DATETIME
   DECLARE @AAC        SMALLINT
   
   SET @major = (@@microsoftversion / 0x1000000) & 0xFF
   SET @minor = ((@@microsoftversion / 0x10000)   & 0xFF) / 100.0
   SET @majorminor = @major + @minor

   -- This command works for default and named instances
   -- 1 = Windows Authentication
   -- 2 = Mixed Mode
   EXEC @res = master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', 
                                              N'Software\Microsoft\MSSQLServer\MSSQLServer', 
                                              N'LoginMode', 
                                              @mode output
                                              
   IF (@majorminor = '8.0')
        SELECT @CreateDate = MIN(T.BuildDate)
        FROM  (SELECT createdate AS [BuildDate]
               FROM   master..syslogins
               WHERE  name = 'BUILTIN\Administrators'
               UNION
               SELECT schemadate AS [BuildDate]
               FROM   master..sysservers
               WHERE  srvid = 0
              ) AS T
   ELSE
        SELECT @CreateDate = MIN(T.BuildDate)
        FROM  (SELECT create_date AS [BuildDate]
               FROM   sys.server_principals
               WHERE  name = 'NT AUTHORITY\SYSTEM'
               UNION
               SELECT modify_date AS [BuildDate]
               FROM   sys.servers
               WHERE  server_id = 0
              ) AS T
          
   -- Check if Account Scrubber Agent is installed and whether it is enabled
   -- -1 - not installed. 0 - Disabled. 1 - Enabled           
   SELECT TOP 1 
          @AAC = enabled
   FROM   msdb.dbo.sysjobs 
   WHERE  name like 'Account Scrubber Agent%'

   IF (@AAC IS NULL)
      SET @AAC = -1
 
   SELECT @Host                                                  AS [Host],
          SERVERPROPERTY('MachineName')                          AS [SQLServer],
          ISNULL(SERVERPROPERTY('InstanceName'),'DEFAULT')       AS [Instance],
          CASE @majorminor WHEN 8.0  THEN '2000'
                           WHEN 9.0  THEN '2005'
                           WHEN 10.0 THEN '2008'
                           WHEN 10.5 THEN '2008r2'
                           WHEN 11.0 THEN '2012'
                           WHEN 12.0 THEN '2014'
                           ELSE 'OTHER'
          END                                                    AS [Version],
          SERVERPROPERTY('ProductVersion')                       AS [BuildVersion],
          CASE @mode WHEN 1 THEN 'W' 
                     WHEN 2 THEN 'M' 
                     ELSE '' 
          END                                                    AS [SecurityMode],
          CONVERT(BIT,          SERVERPROPERTY('IsClustered'))   AS [IsSQLClustered],
          CONVERT(NVARCHAR(128),SERVERPROPERTY('Collation'))     AS [Collation],
          CONVERT(NVARCHAR(128),SERVERPROPERTY('Edition'))       AS [Edition],
          CONVERT(SMALLINT,     SERVERPROPERTY('EngineEdition')) AS [EngineEdition],
          CONVERT(NVARCHAR(128),SERVERPROPERTY('ProductLevel'))  AS [ProductLevel],
          CONVERT(SMALLINT,
                  CASE CHARINDEX(N'64-bit', 
                  CONVERT(NVARCHAR(128), SERVERPROPERTY('Edition')))
                  WHEN 0 THEN '32' ELSE '64'
          END)                                                   AS [SQLServerBitSize],
          @CreateDate                                            AS [InstanceCreatedOn],
          @AAC                                                   AS [AccountScrubberAgent]

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_LinkedServers]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_LinkedServers]
AS
   -- Version 3
   
   SET NOCOUNT ON
   
   DECLARE @cmd     NVARCHAR(4000)
   DECLARE @version NUMERIC(2,0)
      
   SET @version = (@@MICROSOFTVERSION / 0x1000000) & 0xFF

   IF (@version = 8)
	   SET @cmd = 'SELECT S.srvname               AS [Name], ' +
				  '       S.datasource            AS [TargetDataSource], ' +
				  '       S.srvproduct            AS [Product], ' +
				  '       S.providername          AS [Provider], ' +
				  '       NULL                    AS [TargetLogin], ' +
				  '       0                       AS [PassthruAuth] ' +
				  'FROM   master..sysservers AS  S ' +
				  'WHERE  S.srvid > 0'
   ELSE
	   SET @cmd = 'SELECT S.Name                  AS [Name], ' +
				  '       S.data_source           AS [TargetDataSource], ' +
				  '       S.Product               AS [Product], ' +
				  '       S.Provider              AS [Provider], ' +
				  '       NULL                    AS [TargetLogin], ' +
				  '       0                       AS [PassthruAuth] ' +
				  'FROM   sys.servers       AS  S ' +
				  'WHERE  S.is_linked = 1'

   EXEC(@cmd)

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Logins]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Logins]
AS
   -- Version 3.3
   
   SET NOCOUNT ON
   
   DECLARE @cmd     NVARCHAR(4000)
   DECLARE @version NUMERIC(2,0)
      
   SET @version = (@@MICROSOFTVERSION / 0x1000000) & 0xFF

   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(Name NVARCHAR(128), Type NCHAR(1), Status NVARCHAR(10), IsPolicyChecked NCHAR(3), IsExpirationChecked NCHAR(3), DaysUntilExpiration INT NULL)
 
   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2

   CREATE TABLE dbo.#temp2(Name NVARCHAR(128), DBSECType NCHAR(1) NULL, GPN NVARCHAR(8) NULL, Fullname NVARCHAR(30) NULL, last_update DATETIME NULL, pwdate DATETIME NULL)
 
   IF OBJECT_ID('tempdb.dbo.#temp3') IS NOT NULL
      DROP TABLE dbo.#temp3

   CREATE TABLE dbo.#temp3(Name NVARCHAR(128), LastPasswordChange DATETIME, LastAccessTime DATETIME)
    
   -- Extract the Information from the SQL Server Server Principal Table
   IF (@version = 8)
      SET @cmd = 'SELECT SP.loginname, ' +
                 '       CASE SP.isntname + SP.isntgroup WHEN 0 THEN ''S'' WHEN 1 THEN ''U'' WHEN 2 THEN ''G'' END, ' +
                 '       CASE SP.denylogin  ' +
                 '          WHEN 0 THEN ''OPEN'' ' +
                 '          WHEN 1 THEN ''LOCKED'' ' +
                 '       END, ' +
                 '       ''N/A'' AS [IsPolicyChecked], ' +
                 '       ''N/A'' AS [IsExpirationChecked], ' +
                 '       -1       AS [DaysUntilExpiration] ' +
                 'FROM            master.dbo.syslogins    SP ' +
                 'WHERE           SP.name NOT LIKE ''#%'' ' +
                 'AND             SP.name NOT IN (''sa'') '
   ELSE
      SET @cmd = 'SELECT SP.name, ' +
                 '       SP.Type, ' +
                 '       CASE SP.is_disabled  ' +
                 '          WHEN 0 THEN ''OPEN'' ' +
                 '          WHEN 1 THEN ''LOCKED'' ' +
                 '       END, ' +
                 '       CASE SL.is_policy_checked     WHEN 0 THEN ''NO'' WHEN 1 THEN ''YES'' ELSE ''N/A'' END AS [IsPolicyChecked], ' +
	             '       CASE SL.is_expiration_checked WHEN 0 THEN ''NO'' WHEN 1 THEN ''YES'' ELSE ''N/A'' END AS [IsExpirationChecked], ' +
	             '       CONVERT(INT,LOGINPROPERTY(SP.name, ''daysuntilexpiration'')) ' +
                 'FROM            sys.server_principals SP ' +
                 'LEFT OUTER JOIN sys.sql_logins        AS SL ON (SP.name = SL.name) ' +
                 'WHERE           SP.TYPE in (''S'',''U'',''G'') ' +
                 'AND             SP.name NOT LIKE ''#%'' ' +
                 'AND             SP.name NOT IN (''sa'') '
   
   INSERT dbo.#temp1([Name], Type, Status, IsPolicyChecked, IsExpirationChecked, DaysUntilExpiration)
   EXEC(@cmd) 
   
   -- Extract the Information from the DBSEC Login Table
   IF OBJECT_ID (N'dbo.MSSQL_logins') IS NOT NULL   
   BEGIN
      SET @cmd = 'SELECT login_id, ' + 
                 '       Type, ' +
                 '       GPN, ' +
                 '       fullname, ' +
                 '       last_update, ' +
                 '       pwdate ' +
                 'FROM   dbo.MSSQL_logins '
      INSERT dbo.#temp2([Name], DBSECType, GPN, Fullname, last_update, pwdate)
      EXEC(@cmd) 
   END
                 
   -- Extract the Information from the Password Change table
   IF OBJECT_ID (N'dbo.aacScrubberAccounts') IS NOT NULL 
   BEGIN
      SET @cmd = 'SELECT Login, ' +
                 '       LastPasswordChange, ' +
                 '       LastAccessTime ' +
                 'FROM   dbo.aacScrubberAccounts '
      INSERT dbo.#temp3([Name], LastPasswordChange, LastAccessTime)
      EXEC(@cmd) 
   END
   
   -- Return the merged result set
   SELECT T1.Name                    AS [Login],
          T1.Type                    AS [Type],
          T2.DBSECType               AS [DBSECType],
          T2.GPN                     AS [GPN],
          T2.Fullname                AS [Fullname],
          T1.Status                  AS [Status],
          T1.IsPolicyChecked         AS [IsPolicyChecked],
          T1.IsExpirationChecked     AS [IsExpirationChecked],
          T1.DaysUntilExpiration     AS [DaysUntilExpiration],
          T2.last_update             AS [DBSECLastUpdated],
          CASE T1.Type WHEN 'S' THEN T3.LastPasswordChange ELSE NULL END AS [LastPasswordChange],
          T2.pwdate                  AS [DBSECLastPasswordChange],
          T3.LastAccessTime          AS [LastAccessTime]
   FROM            dbo.#temp1 T1
   LEFT OUTER JOIN dbo.#temp2 T2 ON (T1.Name = T2.Name)
   LEFT OUTER JOIN dbo.#temp3 T3 ON (T1.Name = T3.Name)    
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
      
   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2
      
   IF OBJECT_ID('tempdb.dbo.#temp3') IS NOT NULL
      DROP TABLE dbo.#temp3
                 

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Object_Access]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Object_Access]
       @IncludeSystemObjects BIT
AS
   -- Version: 3.1
   
   SET NOCOUNT ON
   
   DECLARE @dbname   NVARCHAR(128)
   DECLARE @status   NVARCHAR(128)
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(DBName NVARCHAR(128), Status NVARCHAR(128))

   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2

   CREATE TABLE dbo.#temp2(ObjectOwner NVARCHAR(128), Object NVARCHAR(128), GrantedTo NVARCHAR(128), GrantedBy NVARCHAR(128), Type NVARCHAR(128), Action NVARCHAR(128), ColumnName NVARCHAR(128) NULL)
 
    IF OBJECT_ID('tempdb.dbo.#temp3') IS NOT NULL
      DROP TABLE dbo.#temp3

   CREATE TABLE dbo.#temp3(DBName NVARCHAR(128), ObjectOwner NVARCHAR(128), Object NVARCHAR(128), GrantedTo NVARCHAR(128), GrantedBy NVARCHAR(128), Type NVARCHAR(128), Action NVARCHAR(128), ColumnName NVARCHAR(128) NULL)
   
   -- Get the list of Databases and their status
   IF (@version = 8)
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master..sysdatabases WHERE cmptlevel > 70 '
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' WHERE name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
   ELSE
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master.sys.databases WHERE source_database_id IS NULL AND compatibility_level > 70 '
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' AND name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
      
   INSERT dbo.#temp1(DBName, Status)
   EXEC(@cmd)
        
   DECLARE query_cursor CURSOR 
   FOR SELECT DBName, Status
       FROM   dbo.#temp1

   OPEN query_cursor

   FETCH NEXT FROM query_cursor INTO @dbname, @status

   WHILE @@FETCH_STATUS = 0
   BEGIN

      IF (@status = 'ONLINE')
      BEGIN
         SET @cmd = '[' + @dbname + '].dbo.sp_helprotect'
         INSERT dbo.#temp2 (ObjectOwner, Object, GrantedTo, GrantedBy, Type, Action, ColumnName)
         EXEC @cmd
        
         IF (@IncludeSystemObjects = 0)
         BEGIN
            INSERT dbo.#temp3 (DBName, ObjectOwner, Object, GrantedTo, GrantedBy, Type, Action, ColumnName)
            SELECT @dbname,* 
            FROM   dbo.#temp2 
            WHERE  ObjectOwner != 'sys' 
            AND    GrantedTo    = 'public'
            AND    Object NOT IN ('fn_diagramobjects','sp_alterdiagram','sp_creatediagram','sp_dropdiagram','sp_helpdiagramdefinition','sp_helpdiagrams','sp_renamediagram')
         END
         ELSE
         BEGIN
            INSERT dbo.#temp3 (DBName, ObjectOwner, Object, GrantedTo, GrantedBy, Type, Action, ColumnName)
            SELECT @dbname,* 
            FROM   dbo.#temp2 
            WHERE  GrantedTo    = 'public'
         END
         
         TRUNCATE TABLE dbo.#temp2
      END

      FETCH NEXT FROM query_cursor INTO @dbname, @status
   END

   CLOSE query_cursor
   DEALLOCATE query_cursor
   
   SELECT DBName                  AS [Database],
          ObjectOwner             AS [ObjectOwner],
          Object                  AS [Object],
          GrantedTo               AS [GrantedTo],
          GrantedBy               AS [GrantedBy],
          Type                    AS [Type],
          Action                  AS [Action],
          ISNULL(ColumnName,'.')  AS [ColumnName]
   FROM   dbo.#temp3
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
      
   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2
      
   IF OBJECT_ID('tempdb.dbo.#temp3') IS NOT NULL
      DROP TABLE dbo.#temp3

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Ownerships]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Ownerships]
       @IncludeSystemObjects BIT
AS
   -- Version: 3.5
   
   SET NOCOUNT ON
   
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(type NVARCHAR(6), dbname NVARCHAR(128), name NVARCHAR(255), owner NVARCHAR(128) NULL)
   
   IF (@version = 8)
		SET @cmd = 'SELECT ''SSIS''          AS [Type], ' +
                   '''msdb''                 AS [DBName], ' +
                   'name                     AS [Name], ' +
	               'SUSER_SNAME(owner_sid)   AS [Owner] ' +
                   'FROM   msdb.dbo.sysdtspackages'

   IF (@version = 9)
		SET @cmd = 'SELECT ''SSIS''          AS [Type], ' +
                   '''msdb''                 AS [DBName], ' +
                   'name                     AS [Name], ' +
	               'SUSER_SNAME(ownersid)    AS [Owner] ' +
                   'FROM   msdb.dbo.sysdtspackages90'

   IF (@version >= 10)
		SET @cmd = 'SELECT ''SSIS''          AS [Type], ' +
                   '''msdb''                 AS [DBName], ' +
                   'name                     AS [Name], ' +
	               'SUSER_SNAME(ownersid)    AS [Owner] ' +
                   'FROM   msdb.dbo.sysssispackages'

   INSERT dbo.#temp1
   EXEC(@cmd) 
   
   IF (@version = 8)
        SET @cmd = 'SELECT ''J''                      AS [Type], ' +
                           '''msdb''                  AS [DBName], ' +
                           'name                      AS [Name], ' +
                           'SUSER_SNAME(owner_sid)    AS [Owner] ' +
                   'FROM   msdb.dbo.sysjobs ' +
                   'UNION ' +
                   'SELECT ''MP''                     AS [Type], ' +
                           '''msdb''                  AS [DBName], ' +
                           'plan_name                 AS [Name], ' +
                           'owner                     AS [Owner] ' +
                   'FROM   msdb.dbo.sysdbmaintplans ' +
                   'UNION ' +
                   'SELECT ''T''                      AS [Type], ' +
                           '''msdb''                  AS [DBName], ' +
                           'name                      AS [Name], ' +
                           'SUSER_SNAME(ownerloginid) AS [Owner] ' +
                   'FROM   msdb.dbo.systasks '
   ELSE
        SET @cmd = 'SELECT ''J''                           AS [Type], ' +
                           '''msdb''                       AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'SUSER_SNAME(owner_sid)         AS [Owner] ' +
                   'FROM   msdb.dbo.sysjobs ' +
                   'UNION ' +
                   'SELECT ''JS''                              AS [Type], ' +
                           '''msdb''                           AS [DBName], ' +
                           'S.name + '' ('' + J.name + '')''   AS [Name], ' +
                           'SUSER_SNAME(S.owner_sid)           AS [Owner] ' +
                   'FROM   msdb.dbo.sysschedules    AS   S ' +
                   'JOIN   msdb.dbo.sysjobschedules AS JJS ON (S.schedule_id = JJS.schedule_id) ' +
                   'JOIN   msdb.dbo.sysjobs         AS   J ON (JJS.job_id    = J.job_id) ' +
                   'UNION ' +
                   'SELECT ''MP''                          AS [Type], ' +
                           '''msdb''                       AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'owner                          AS [Owner] ' +
                   'FROM   msdb.dbo.sysmaintplan_plans ' +
                   'UNION ' +
                   'SELECT ''SAP''                         AS [Type], ' +
                           '''msdb''                       AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'SUSER_SNAME(user_sid)          AS [Owner] ' +
                   'FROM   msdb.dbo.sysproxies ' +
                   'UNION ' +
                   'SELECT ''SAPL'' AS [Type], ' +
                           '''msdb''                       AS [DBName], ' +
                           'P.name                         AS [Name], ' +
                           'SUSER_SNAME(PL.sid)            AS [Owner] ' +
                   'FROM   msdb.dbo.sysproxies    AS P ' +
                   'JOIN   msdb.dbo.sysproxylogin AS PL ON (P.proxy_id = PL.proxy_id) ' +
                   'UNION ' +
                   'SELECT ''CRED''                        AS [Type], ' +
                           '''master''                     AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'credential_identity            AS [Owner] ' +
                   'FROM   master.sys.credentials ' +
                   'UNION ' +
                   'SELECT ''AKEY''                        AS [Type], ' +
                           '''master''                     AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'SUSER_SNAME(sid)               AS [Owner] ' +
                   'FROM   master.sys.asymmetric_keys ' +
                   'UNION ' +
                   'SELECT ''CERT''                        AS [Type], ' +
                           '''master''                     AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'SUSER_SNAME(sid)               AS [Owner] ' +
                   'FROM   master.sys.certificates ' +
                   'UNION ' +
                   'SELECT ''EN''                          AS [Type], ' +
                           '''master''                     AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'SUSER_SNAME(creator_sid)       AS [Owner] ' +
                   'FROM   master.sys.event_notifications	 ' +
                   'UNION ' +
                   'SELECT ''SEV''                         AS [Type], ' +
                           '''master''                     AS [DBName], ' +
                           'name                           AS [Name], ' +
                           'SUSER_SNAME(creator_sid)       AS [Owner] ' +
                   'FROM   master.sys.server_event_notifications '

   INSERT dbo.#temp1
   EXEC(@cmd)   
      
   -- The TEMP table has a Name column with 255. We only pull the first 128 chars.
   -- Some Job Schedule names are huge.
   
   IF (@IncludeSystemObjects = 0)   
       SELECT type                  AS [Type],
              dbname                AS [Database],
		      SUBSTRING(name,0,128) AS [Name],
		      owner                 AS [Owner]
       FROM   dbo.#temp1
       WHERE  owner IS NOT NULL
       AND    owner NOT IN ('sa')
       AND    owner NOT LIKE '##%'
   ELSE
       SELECT type                  AS [Type],
              dbname                AS [Database],
		      SUBSTRING(name,0,128) AS [Name],
		      owner                 AS [Owner]
       FROM   dbo.#temp1
       WHERE  owner IS NOT NULL
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
   

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Server_Roles]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Server_Roles]
AS
   -- Version: 3
   
   SET NOCOUNT ON
   
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(login NVARCHAR(128), role NVARCHAR(128))
   
   IF (@version = 8)
		SET @cmd = 'SELECT name,''sysadmin''      FROM master.dbo.syslogins WHERE sysadmin = 1      AND name IS NOT NULL AND name NOT IN (''sa'')
					UNION ALL
					SELECT name,''securityadmin'' FROM master.dbo.syslogins WHERE securityadmin = 1 AND name IS NOT NULL
					UNION ALL
					SELECT name,''serveradmin''   FROM master.dbo.syslogins WHERE serveradmin = 1   AND name IS NOT NULL
					UNION ALL
					SELECT name,''setupadmin''    FROM master.dbo.syslogins WHERE setupadmin = 1    AND name IS NOT NULL
					UNION ALL
					SELECT name,''processadmin''  FROM master.dbo.syslogins WHERE processadmin = 1  AND name IS NOT NULL
					UNION ALL
					SELECT name,''diskadmin''     FROM master.dbo.syslogins WHERE diskadmin = 1     AND name IS NOT NULL
					UNION ALL
					SELECT name,''dbcreator''     FROM master.dbo.syslogins WHERE dbcreator = 1     AND name IS NOT NULL
					UNION ALL
					SELECT name,''bulkadmin''     FROM master.dbo.syslogins WHERE bulkadmin = 1     AND name IS NOT NULL'
   ELSE
		SET @cmd = 'SELECT SP.name   AS [Login], 
						   SP2.name  AS [Role]
					FROM   sys.server_role_members AS RM
					JOIN   sys.server_principals   AS SP  ON SP.principal_id  = RM.member_principal_id
					JOIN   sys.server_principals   AS SP2 ON SP2.principal_id = RM.role_principal_id
					WHERE  SP.TYPE in (''S'',''U'',''G'') 
                    AND    SP.name NOT LIKE ''#%'' 
                    AND    SP.name NOT IN (''sa'') '
   INSERT dbo.#temp1
   EXEC(@cmd)   
      
   SELECT login     AS [Login],
          role      AS [Role]
   FROM   dbo.#temp1
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
   

GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_EXTRACT_Users]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_EXTRACT_Users]
       @IncludeSystemObjects BIT
AS
   -- Version: 3
   
   SET NOCOUNT ON
   
   DECLARE @dbname   NVARCHAR(128)
   DECLARE @status   NVARCHAR(128)
   DECLARE @cmd      NVARCHAR(4000)
   DECLARE @version  NUMERIC(2,0)

   SET @version = (@@microsoftversion / 0x1000000) & 0xFF
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1

   CREATE TABLE dbo.#temp1(DBName NVARCHAR(128), Status NVARCHAR(128))

   IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2

   CREATE TABLE dbo.#temp2(DBName NVARCHAR(128), Username NVARCHAR(128), Usertype NCHAR(1))
    
   -- Get the list of Databases and their status
   IF (@version = 8)
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master..sysdatabases'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' WHERE name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
   ELSE
   BEGIN
      SET @cmd = 'SELECT name, CONVERT(NVARCHAR,DATABASEPROPERTYEX(name,''Status'')) FROM master.sys.databases WHERE source_database_id IS NULL'
      IF (@IncludeSystemObjects = 0)
         SET @cmd = @cmd + ' AND name NOT IN (''master'',''model'',''msdb'',''tempdb'')'
   END
      
   INSERT dbo.#temp1
   EXEC(@cmd)
        
   DECLARE query_cursor CURSOR 
   FOR SELECT DBName, Status
       FROM   dbo.#temp1

   OPEN query_cursor

   FETCH NEXT FROM query_cursor INTO @dbname, @status

   WHILE @@FETCH_STATUS = 0
   BEGIN

      IF (@status = 'ONLINE')
      BEGIN
         IF (@version = 8)
            SET @cmd = 'SELECT  ''' + @dbname + ''', name, ''S'' ' +
                       'FROM [' + @dbname + ']..sysusers WHERE issqluser = 1 AND name NOT IN (''dbo'',''guest'',''INFORMATION_SCHEMA'') AND name NOT LIKE ''NT AUTHORITY%'' AND sid IS NOT NULL ' +
                       'UNION ' +
                       'SELECT  ''' + @dbname + ''', name, ''G'' ' +
                       'FROM [' + @dbname + ']..sysusers WHERE isntgroup = 1 AND name NOT IN (''dbo'',''guest'',''INFORMATION_SCHEMA'') AND name NOT LIKE ''NT AUTHORITY%'' AND sid IS NOT NULL ' +
                       'UNION ' +
                       'SELECT  ''' + @dbname + ''', name, ''U'' ' +
                       'FROM [' + @dbname + ']..sysusers WHERE isntuser = 1 AND name NOT IN (''dbo'',''guest'',''INFORMATION_SCHEMA'') AND name NOT LIKE ''NT AUTHORITY%'' AND sid IS NOT NULL '
         ELSE
            SET @cmd = 'SELECT  ''' + @dbname + ''', name, type ' + 
                       'FROM [' + @dbname + '].sys.database_principals ' +
                       'WHERE     type IN (''S'',''U'',''G'') AND name NOT IN (''dbo'',''guest'',''MS_DataCollectorInternalUser'') AND name NOT LIKE ''#%'' AND name NOT LIKE ''NT AUTHORITY%'' AND sid IS NOT NULL'
                      
         INSERT dbo.#temp2
         EXEC(@cmd)
      END

      FETCH NEXT FROM query_cursor INTO @dbname, @status
   END

   CLOSE query_cursor
   DEALLOCATE query_cursor
   
   SELECT DBName    AS [Database],
          Username  AS [Username],
          Usertype  AS [Usertype]
   FROM   dbo.#temp2
   
   IF OBJECT_ID('tempdb.dbo.#temp1') IS NOT NULL
      DROP TABLE dbo.#temp1
      
    IF OBJECT_ID('tempdb.dbo.#temp2') IS NOT NULL
      DROP TABLE dbo.#temp2


GO
/****** Object:  StoredProcedure [dbo].[usp_PPP_Version]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_PPP_Version]
AS
   SELECT 3    AS [PPP Version],
          3.7  AS [PPP Schema Version]

GO
/****** Object:  StoredProcedure [dbo].[usp_ProcessUBSMWE_Errors]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[usp_ProcessUBSMWE_Errors]

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_ProcessUBSMWE_Errors.sql.SQL
// 
// Purpose:
//   Send alerts to MOM
//
// Notes: This stored procedure is called from main UBSMWE. 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 06/01/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.0 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

--NSTM0621DAP, MSSQLCentral

BEGIN  --Begin main()
	DECLARE 	@UBSMWE_Error_id   BIGINT
				,@Source			NVARCHAR(1000)
				,@command			NVARCHAR(1000)
				,@message			VARCHAR(1000)
				,@ErrorText			NVARCHAR(4000)
				,@LogEvent			bit
				,@InitialLogTime	datetime
				,@sqlErrorID		int
				,@NeedAlertGenerated bit
				,@ErrorAlertCount	int
				,@LastErrorEnteredDate datetime
				,@RC				int


--@sql1 nvarchar(4000), @sql2 nvarchar(4000) = NULL, @sql3 nvarchar(4000) = NULL

SET NOCOUNT ON

--	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MSSQLCentralPrimaryServer', @MSSQLCentralPrimaryServer OUTPUT 

--If setting does not exist yet, enter setting default of 10 days



	DECLARE QUEUE_cur cursor for 
		SELECT [UBSMWE_Error_ID]
			,[InitialLogTime]
			,[SQLErrorID]
			,[Source]
			,[command]
			,[message]
			,[NeedAlertGenerated]
			,[ErrorAlertCount]
			,[LastErrorEnteredDate]
		FROM [UBSMWE_Errors]
		WHERE NeedAlertGenerated = 1
		ORDER BY UBSMWE_Error_ID

		-- Open Cursor
	OPEN QUEUE_cur
	-- Read Work Table
	FETCH NEXT FROM QUEUE_cur INTO @UBSMWE_Error_id
									,@InitialLogTime
									,@sqlErrorID
									,@Source
									,@command
									,@message
									,@NeedAlertGenerated
									,@ErrorAlertCount
									,@LastErrorEnteredDate




		WHILE (@@FETCH_STATUS <> -1)
			BEGIN --BEGIN WHILE
				SELECT @ErrorText = 'UBSMWE component: ' + @Source  + ' Failed command: ' + @command + ' Error: ' + @message 


				EXECUTE @RC = [DBServices].[dbo].[usp_LogEvent] @ErrorText, 3 --@LogNTEvent 3 = ERROR, 2 = WARNING, 1 = INFORMATIONAL

				IF @RC = 0
					BEGIN

						UPDATE UBSMWE_Errors
						   SET NeedAlertGenerated = 0
						-- Not implimented yet      ,LastAlertedDate = getdate()
						 WHERE UBSMWE_Error_ID = @UBSMWE_Error_id
					END



				FETCH NEXT FROM QUEUE_cur INTO @UBSMWE_Error_id
									,@InitialLogTime
									,@sqlErrorID
									,@Source
									,@command
									,@message
									,@NeedAlertGenerated
									,@ErrorAlertCount
									,@LastErrorEnteredDate

			END

	-- Close/Deallocate cursor
	CLOSE QUEUE_cur
	DEALLOCATE QUEUE_cur




SET NOCOUNT OFF
END --main()




GO
/****** Object:  StoredProcedure [dbo].[usp_PurgeMWEJobs]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE  PROCEDURE [dbo].[usp_PurgeMWEJobs] 
AS

/****************************************************************************************
// @File: usp_PurgeMWEJobs.SQL
// 
// Purpose:
//   Delete all UBSMWE jobs to remove MWE
//
// History: Date Format dd/mm/yyyy

//   @Date: 01/05/2011 @Author: Steve Trogub @Version: 4.0.1 @Action: Remove MWE
//   @Date: 02/07/2015 @Author: Chris Basson @Version: 6.0.0.34 @Action: Overhaul
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd
SET CONCAT_NULL_YIELDS_NULL OFF

DECLARE @Jobs TABLE
        (JobVal int IDENTITY,
          JobID uniqueidentifier)

DECLARE @JobID uniqueidentifier,
        @i int,
        @RetCode int

INSERT INTO @Jobs (JobID)
SELECT DISTINCT S.job_id
FROM msdb..sysjobs S
WHERE S.name IN ('UBSMWE MORCS - Change SA Password'
				, 'UBSMWE_ProcessUBSMWE_Errors'
				, 'UBSMWE_ProcessMSCCQ')		
	OR S.name LIKE 'UBSMWE_Engine%'
	OR S.name LIKE 'UBSMWE_WF%'

SET @i = 1
WHILE (@i <= (SELECT MAX(JobVal) FROM @Jobs))
BEGIN
    SELECT @JobID = JobID
	FROM @Jobs
	WHERE JobVal = @i

    EXEC @RetCode=msdb..sp_delete_job @job_id = @JobID
        IF (@RetCode <> 0)
            PRINT ' Error deleting SQL job ' + CAST (@JobID as varchar(36)) + ' from scheduler '
        SET @i = @i + 1
END

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_PurgeOldBackupFiles]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_PurgeOldBackupFiles] 
AS

/****************************************************************************************
// @File: usp_PurgeOldBackupFiles.SQL
// @Version: 6.0.0.28
// 
// Purpose:
//   Delete backup files older than configured retain date.
//
// Notes: This stored procedure is called FROM main UBSMWE. Can be run by hand if needed.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 03/11/2004 @Author: Kevin Wagner @Version: 1.5.1 @Action: Updated logging code... not as verbose in heartbeat
//   @Date: 29/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Changed the QUOTED_IDENTIFIER status to off for file path length bug.
//   @Date: 05/03/2005 @Author: Kevin Wagner @Version: 1.5.2 HF2 @Action: Changed criteria for file inclusion to look at start date and time if end date and time was null. (DBServices data corruption caused by external forces, like, machine rebooting during backup runs)
//   @Date: 31/03/2005 @Author: Kevin Wagner @Version: 1.5.2 HF2 @Action: Added code to purge local information and delete the Netbackup directories.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 22/09/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4 @Action: Updated for issue on case sensitive instance
//   @Date: 20/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Netbackup Rerun process change. Will now rerun under same Netbackup Manifest number.//
//   @Date: 18/03/2009 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Confirmed proper tsql for LogShipping on MSSQL 2005 as reported by Katya.
//   @Date: 21/09/2009 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.2 @Action: Updated for delete file issue # 71
//   @Date: 01/05/2011 @Author: Steve Trogub @Version: UBSMWE 4.0 @Action: Custom rentetion for full and partial backups using @KeepFile
//   @Date: 03/10/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.3 @Action: Fix for files not purging after they were sent to tape
//   @Date  03/10/2013 @Author: Andrew Calvett @Version: UBSMWE 5.0.4 @Action: Fix for deletion of LS files that have not been copied yet.
//	 @Date  01/13/2013 @Author: Andrew Calvett @Version: UBSMWE 5.0.8 @Action: Fix for delete retry of files that are not to be deleted anyway. 
//	 @Date  29/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//	 @Date  28/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//	 @Date  06/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta
//	 @Date  17/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.27 @Action: TRR-129
//   @Date: 19/03/2015 @Author: Chris Basson @Version: 6.0.0.28 @Action: Improved error handling
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET CONCAT_NULL_YIELDS_NULL OFF
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int,
	@dbsDatabaseUID uniqueidentifier,
	@dbsDBHID bigint, 
	@dbsDBHEndDate datetime, 
	@dbsDBHFileName nvarchar(255),
	@dbsRetainBackupFileDurationHrs int,
	@dbsLocalHistoryRetainDays int,
	@MAXdbsNetbackupID bigint,
	@MAXdbsDBHID bigint,
	@dbsNetbackupLogName nvarchar(255), 
	@dbsNetbackupFileListName nvarchar(255),
	@LS_PrimaryCount int,
	@sqlstr1 nvarchar(4000), 
	@sqlstr2 nvarchar(4000), 
	@Secondary_server_name nvarchar(128), 
	@LogShipPrimaryDatabase nvarchar(128),
	@backup_retention_period int,
	@LSExpiryDT datetime,
	@ErrMsg nvarchar(512),
	@NB_Enabled bit,
	@CV_Enabled bit,
	@dbsDBHSentToNBFlag bit,
	@IsSuccess bit,
	@dbsNetbackupID bigint,
	@MSDBPurgeDate datetime,
	@exists	bit,
	@SendAlertOnIndividualFilePurgeErrors bit,
	@AlertSeverity tinyint,
	@BackupLocationDrive nvarchar(3),
	@DeleteRetryCount int,
	@DeleteRetryIntervalSeconds int,
	@DelCount int,
	@DeleteRetryDelay char(8),
	@KeepFile bit,
	@debug tinyint,
	@CV_FSIncSysDB bit,
	@dbsBackupProcessor tinyint,
	@LSFileName nvarchar(255),
	@LSFileRDT datetime,
	@i smallint

-----------------------------------------------------------------
-- Tmp tables

DECLARE @SQLCMD_OUT TABLE (astr nvarchar(512))

IF OBJECT_ID('tempdb..#LSBackupFile') IS NOT NULL 
	DROP TABLE #LSBackupFile

CREATE TABLE #LSBackupFile (LSFileName nvarchar(255)
							,dbsDBHID bigint
							,dbsDatabaseUID uniqueidentifier
							, LSExpiryDT datetime)

DECLARE @FSExclusionDBList TABLE (dbsDatabaseUID uniqueidentifier)

-----------------------------------------------------------------
-- Set parameter values

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 

SET @CV_FSIncSysDB = 1 -- Default - backup System DB FS Dumps 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 
IF @dbsBackupProcessor IN (4,5)
BEGIN
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_FSIncSysDB', @CV_FSIncSysDB OUTPUT
	IF @RC <> 0
		SET @CV_FSIncSysDB = 0 
END

IF @CV_FSIncSysDB = 0 -- CV - always purge old system database dumps regardless of offsite CV FS iDA backups
BEGIN
	INSERT INTO @FSExclusionDBList
	SELECT DISTINCT dbsDatabaseUID
	FROM [DBServices].[dbo].[dbsDatabase] db
	WHERE dbsDatabaseIsActive = 1
		AND dbsDatabaseIsSystemObjectFlag = 1
END

--------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'SendAlertOnIndividualFilePurgeErrors', @SendAlertOnIndividualFilePurgeErrors OUTPUT 

SET @AlertSeverity = CASE ISNULL(@SendAlertOnIndividualFilePurgeErrors, 0)
						WHEN 1 THEN 2
						ELSE 1
					END

--------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsLocalHistoryRetainDays', @dbsLocalHistoryRetainDays OUTPUT
IF @RC = 0 
	SET @MSDBPurgeDate =  DATEADD(dd, - @dbsLocalHistoryRetainDays, getdate())
ELSE
BEGIN
	SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: The setting for dbsLocalHistoryRetainDays was not found in dbsInstanceConfig, setting to default of 90 days.' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, 1

	SET @dbsLocalHistoryRetainDays = 90
	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsLocalHistoryRetainDays', @dbsLocalHistoryRetainDays
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsRetainBackupFileDurationHrs', @dbsRetainBackupFileDurationHrs OUTPUT 
IF @RC <> 0
	SET @dbsRetainBackupFileDurationHrs = 72

IF @dbsRetainBackupFileDurationHrs > (@dbsLocalHistoryRetainDays * 24) 
BEGIN
	SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: WARNING: dbsLocalHistoryRetainDays: '
		+ CAST(@dbsLocalHistoryRetainDays as varchar(3)) 
		+ ' is less than the Backup file retention period of ' + CAST(@dbsRetainBackupFileDurationHrs as varchar(3)) + 'hrs.'

	SET @dbsLocalHistoryRetainDays = (@dbsRetainBackupFileDurationHrs / 24) + 1
	SET @MSDBPurgeDate =  DATEADD(dd, - @dbsLocalHistoryRetainDays, getdate())

	SET @ErrMsg = @ErrMsg + ' Using: ' + CAST(@dbsLocalHistoryRetainDays as varchar(3)) + ' days instead'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity
END

--------------------

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DeleteRetryCount', @DeleteRetryCount OUTPUT 
IF @RC <> 0 
BEGIN
	SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: DeleteRetryCount was not found in dbsInstanceConfig. Defaulting to 10' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, 1

	SET @DeleteRetryCount = 10
END		

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DeleteRetryIntervalSeconds', @DeleteRetryIntervalSeconds OUTPUT 
IF @RC <> 0
	OR @DeleteRetryIntervalSeconds > 59
BEGIN
	SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: DeleteRetryIntervalSeconds is invalid (max 59 seconds) defaulting to 5' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, 1

	SET @DeleteRetryIntervalSeconds = 5
END
ELSE
IF @DeleteRetryIntervalSeconds < 10
	SET @DeleteRetryDelay  = '00:00:0' + CAST(@DeleteRetryIntervalSeconds as char(1))
ELSE
	SET @DeleteRetryDelay  = '00:00:' + CAST(@DeleteRetryIntervalSeconds as char(2))

IF @debug >= 2
BEGIN
	PRINT '--Debug-------------------------------------------------------------'

	SELECT @CV_Enabled as 'CV_Enabled'
			,@NB_Enabled as 'NB_Enabled'
			,@CV_FSIncSysDB as 'CV_FSIncSysDB'
			,@DeleteRetryIntervalSeconds as 'DeleteRetryIntervalSeconds'
			,@DeleteRetryCount as 'DeleteRetryCount'
			,@dbsRetainBackupFileDurationHrs as 'dbsRetainBackupFileDurationHrs'
			,@dbsLocalHistoryRetainDays as 'dbsLocalHistoryRetainDays'
			,@MSDBPurgeDate as '@MSDBPurgeDate'

	PRINT '--------------------------------------------------------------------'
END

-----------------------------------------------------------------
--Check to see if any databases are set up as LS Primary
SELECT @LS_PrimaryCount = COUNT(*) 
FROM [DBServices].[dbo].dbsDatabaseBackup
WHERE dbsDBBackupType = 'LS_Primary'

--If LS Primary, get more information FROM the monitor server for the last file restored.
IF @LS_PrimaryCount IS NOT NULL 
	AND @LS_PrimaryCount >= 1
BEGIN
	DECLARE LS_File_cur CURSOR FOR
	SELECT db.dbsDatabaseName
		,lsps.secondary_server
		,lspd.backup_retention_period --int, in mins
	FROM [DBServices].[dbo].dbsDatabase db
	INNER JOIN [DBServices].[dbo].dbsDatabaseBackup dbb
		ON db.dbsDatabaseUID = dbb.dbsDatabaseUID
	INNER JOIN [msdb].[dbo].[log_shipping_primary_databases] lspd
		ON lspd.primary_database = db.dbsDatabaseName
	INNER JOIN [msdb].[dbo].[log_shipping_primary_secondaries] lsps
		ON lspd.primary_id = lsps.primary_id
	WHERE dbb.dbsDBBackupType  = 'LS_Primary'
	OPEN LS_File_cur

	FETCH NEXT FROM LS_File_cur 
		INTO @LogShipPrimaryDatabase, @Secondary_server_name, @backup_retention_period

	WHILE (@@FETCH_STATUS = 0)
	BEGIN  --begin while

		SET @RC = 0

		IF (@backup_retention_period /60) > @dbsRetainBackupFileDurationHrs
		BEGIN
			SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: INFO: Logshipping backup retention for DB [' 
							+ @LogShipPrimaryDatabase + '] = ' + CAST((@backup_retention_period /60) as varchar(3))
							+ ' hrs which is greater than UBSMWE retention of ' 
							+ CAST (@dbsRetainBackupFileDurationHrs as varchar(3)) + ' hrs' 

			PRINT @ErrMsg
			--EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, 1 -- creates too much spam
		END
		
		IF @dbsLocalHistoryRetainDays < (@backup_retention_period /1440)
		BEGIN
			SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: WARNING: The setting for dbsLocalHistoryRetainDays: '
							+ CAST(@dbsLocalHistoryRetainDays as varchar(3)) 
							+ ' is less than the Backup file retention period for the Logshipped DB ['
							+ @LogShipPrimaryDatabase + '] of ' 
							+ CAST(@backup_retention_period as varchar(6)) + 'hrs.'

			SET @dbsLocalHistoryRetainDays = (@backup_retention_period/1440) + 1
			SET @MSDBPurgeDate =  DATEADD(dd, - @dbsLocalHistoryRetainDays, getdate())

			SET @ErrMsg = @ErrMsg + ' => Resetting to: ' + CAST(@dbsLocalHistoryRetainDays as varchar(3)) + ' days'

			EXEC [DBServices].[dbo].usp_ConfigureUBSMWE 'dbsLocalHistoryRetainDays', @dbsLocalHistoryRetainDays

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity
		END

		-----------------------------------------------------------------
		-- Get LS Last file loaded 

		DELETE FROM @SQLCMD_OUT

		-- Workaround:
		SET @sqlstr1 = 'SELECT TOP 1 last_restored_file + '';'' + CAST(last_restored_date as varchar(20)) '
						+ 'FROM [msdb].[dbo].[log_shipping_monitor_secondary] '
						+ 'WHERE primary_database = ''' +  @LogShipPrimaryDatabase + ''''
						+ 'ORDER BY last_restored_date DESC'

		SET @sqlstr2 = 'sqlcmd -x -u -h-1 -r1 -R -W -S ' + @Secondary_server_name 
						+ ' -E -d ' + 'msdb'
						+ ' -Q "' + @sqlstr1 + '"'  
		BEGIN TRY
			INSERT INTO @SQLCMD_OUT
			EXEC @RC = master..xp_cmdshell @sqlstr2
		END TRY

		BEGIN CATCH
			SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: Unable to obtain log shipping secondary info: last restore file for ' + @Secondary_server_name 
					+ ' ,DB: [' + @LogShipPrimaryDatabase + ']'
					+ ' - Investigation required.'
			SET @RC = 1
			PRINT ERROR_MESSAGE()
		END CATCH		
		
		----------------

		IF @RC = 0 -- Match Last restore file with MWE backup history
		BEGIN 
			----------------
			-- Parse output

			SELECT TOP 1 @sqlstr1 = astr
			FROM @SQLCMD_OUT

			SET @i = CHARINDEX(';', @sqlstr1)

			IF ISNULL(@i, 0) > 0
			BEGIN
		 		SET	@LSFileName = [DBServices].[dbo].[ParseFileName](SUBSTRING (@sqlstr1,1 , @i - 1))

				SET @sqlstr1 = SUBSTRING (@sqlstr1, @i + 1, 20)

				IF ISDATE(@sqlstr1) = 1
					SET @LSFileRDT = CAST(@sqlstr1 as datetime)
				ELSE	
				BEGIN
					SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: Unable to validate log shipping secondary data: last restore file for '
							+ @Secondary_server_name 
							+ ' ,DB: [' + @LogShipPrimaryDatabase 
							+ '] , @LSFileName = ' + @LSFileName
							+ ' - Investigation required.'	
					SET @RC = 1
				END
			END
			ELSE
			BEGIN
				SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: Unable to obtain log shipping secondary data: last restore file for '
						+ @Secondary_server_name 
						+ ' ,DB: [' + @LogShipPrimaryDatabase 
						+ '] , @LSFileName = ' + @LSFileName
						+ ' - Investigation required.'	
				SET @RC = 1
			END

			IF @debug >= 2
			BEGIN
				PRINT @sqlstr2
				SELECT @LSFileName as '@LSFileName'
						, @LSFileRDT as '@LSFileRDT'
			END
			----------------

			IF @RC = 0
				AND EXISTS (SELECT 1
						FROM [DBServices].[dbo].dbsDatabaseBackupHistory DBH
						WHERE [DBServices].[dbo].ParseFileName(DBH.dbsDBHFileName) = @LSFileName)
			BEGIN
				--ParseFileName required otherwise you don't get a match.
				INSERT INTO #LSBackupFile 
				SELECT DISTINCT
					 @LSFileName
					, dbsDBHID
					, dbsDatabaseUID
					, DATEADD(minute, @backup_retention_period, @LSFileRDT) -- LSExpiryDT
				FROM [DBServices].[dbo].dbsDatabaseBackupHistory DBH
				WHERE CHARINDEX(@LSFileName, DBH.dbsDBHFileName) > 0  

			END -------------------
			ELSE 
			IF @RC = 0
			BEGIN
				SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: No valid Logshipping local backup history restore files match for: ' 
								+ @Secondary_server_name
								+ ' , DB: [' + @LogShipPrimaryDatabase + ']'
				SET @RC = 1
			END
		END -------------------

		IF @RC=1
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity

		FETCH NEXT FROM LS_File_cur 
			INTO @LogShipPrimaryDatabase, @Secondary_server_name, @backup_retention_period
	END-- end while

	CLOSE LS_File_cur
	DEALLOCATE LS_File_cur
END

-- Tidyup
DELETE FROM #LSBackupFile
WHERE ISNULL(LSFileName, '') = ''

---------------------------------------------------------------

--Purge old backup information FROM the MSDB tables.
EXEC msdb.dbo.sp_delete_backuphistory @MSDBPurgeDate

DECLARE dbsDatabaseFile_cur CURSOR FOR
SELECT 
	dbsDBH.dbsDatabaseUID,  
	dbsDBH.dbsDBHID, 
	ISNULL(dbsDBH.dbsDBHEndDate, dbsDBH.dbsDBHStartDate) as dbsDBHEndDate, 
	CASE
		WHEN dbsDBH.dbsDBHSentToNBFlag = 1 THEN ISNULL(NM.dbsNetbackupManifestLocation, dbsDBH.dbsDBHFileName)
		WHEN ISNULL(dbsDBH.dbsDBHSentToNBFlag, 0) = 0 THEN dbsDBH.dbsDBHFileName
	END as 'dbsDBHFileName',
	ISNULL(dbsDBH.dbsDBHSentToNBFlag, 0) as 'dbsDBHSentToNBFlag',
	IsSuccess,
	NM.dbsNetbackupID 

FROM [DBServices].[dbo].[dbsDatabaseBackupHistory] dbsDBH
LEFT OUTER JOIN [DBServices].[dbo].[dbsNetbackupManifest] NM
	ON dbsDBH.dbsDBHID = NM.dbsDBHID 

WHERE ISNULL(dbsDBH.dbsDBHEndDate, dbsDBH.dbsDBHStartDate) < DATEADD(hh, (0 - 23), getdate())
	AND dbsDBH.dbsDBHIsOnDiskFlag = 1
ORDER BY dbsDBH.dbsDatabaseUID, dbsDBH.dbsDBHID
OPEN dbsDatabaseFile_cur

FETCH NEXT FROM dbsDatabaseFile_cur 
	INTO @dbsDatabaseUID, @dbsDBHID, @dbsDBHEndDate, @dbsDBHFileName
		, @dbsDBHSentToNBFlag, @IsSuccess, @dbsNetbackupID
WHILE (@@FETCH_STATUS = 0)
BEGIN  --begin while

	--SELECT 'SELECT 1', @dbsDatabaseUID, @dbsDBHID, @dbsDBHEndDate, @dbsDBHFileName, @dbsDBHSentToNBFlag, @IsSuccess, @dbsNetbackupID			
	--See if any files to be purged are actually FROM the log shipping and have not been applied to the secondary yet. 
	--Must not delete if it has not made it to the secondary yet. It is assumed that if the file has been sent to Netbackup 
	--that it is ok to purge. This part of the logic is in the Netbackup portion.

	--Set custom retention code for full backups taken of databases WHERE [DBServices].[dbo].[dbsDatabaseException] dbRetain entry is present. (entry is in hours and overrides global rentantion period)

	-- If user DB exclusion
	IF @CV_FSIncSysDB = 0
		AND (@dbsDatabaseUID IN (SELECT dbsDatabaseUID FROM @FSExclusionDBList))
	BEGIN
		-- Force file to purge
		SET @dbsDBHSentToNBFlag = 1
		SET @KeepFile = 0
		SET @IsSuccess = 1
	END

	IF ISNULL(@dbsDBHFileName, '') <> ''
		-- Determine if file can be deleted
		EXEC [DBServices].[dbo].[usp_FileRetentionStatus]
					@FullFilePath = @dbsDBHFileName
					, @dbUID = @dbsDatabaseUID
					, @CreateDate = @dbsDBHEndDate
					, @KeepFile = @KeepFile OUTPUT
	ELSE
	BEGIN
		SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: Unhandled Exception - Empty file path passed - investigation required' 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, 2

		SET @KeepFile = 1 -- skip
	END

	---------------------------------------------------------------
	-- Verify if LS file

	IF @KeepFile = 0
		AND EXISTS (SELECT 1 
			FROM #LSBackupFile
			WHERE @dbsDatabaseUID = dbsDatabaseUID 
				AND @dbsDBHID > dbsDBHID)
	BEGIN	-- LS restore issue encountered

		IF EXISTS (SELECT 1 
			FROM #LSBackupFile
			WHERE @dbsDatabaseUID = dbsDatabaseUID 
				AND LSExpiryDT < getdate())
		BEGIN	
			SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: The logshipped file ' +  @dbsDBHFileName 
				+ ' has not successfully been restored to the secondary for - unable to delete: Investigation required'
 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity
		END

		SET @KeepFile = 1
	END --------------------------
	ELSE
	IF @KeepFile = 0
		AND @dbsDBHSentToNBFlag = 1
		AND ISNULL(@IsSuccess, 0) = 0 	--NULL STATUS = Netbackup/CommVault Error, can have duplicates in the status log.
	BEGIN
		SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: File: ' + ISNULL(@dbsDBHFileName, 'NULL') 
			+ ' is marked as sent for FS Backups for manifest: ' + ISNULL(CAST(@dbsNetbackupID as nvarchar(12)), 'NULL')
			+ ', however the FS Backup process has not indicated a completion status; '
			+ CASE
				WHEN @CV_Enabled = 1 THEN 'CV FS backups enabled' 
				WHEN @NB_Enabled = 1 THEN 'NB FS backups enabled'   
				ELSE 'FS backups currently disabled => '
					+ 'please run usp_MarkFilebackupFixed if the offsite backup is no longer required'
				END
			+ ' => Unable to purge file!'
		
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity

		SET @KeepFile = 1
	END --------------------------

	---------------------------------------------------------------
	-- Handle keep status

	IF @KeepFile = 0
		AND ((@NB_Enabled = 0 AND @CV_Enabled = 0)
			OR (@NB_Enabled = 1 AND @dbsDBHSentToNBFlag = 1 AND @IsSuccess = 1)
			OR (@CV_Enabled = 1 AND @dbsDBHSentToNBFlag = 1 AND @IsSuccess = 1)) 
	BEGIN

		SET @DelCount = 0
		----------------
		DELETEFILE: 

		--AVC, if block only included the setting of the SQL statement which meant we looped around the retry
		--even when we don't need to causing poor perf and missing delete windows.

		EXEC @RC = [DBServices].[dbo].[usp_DelFile] @Filename = @dbsDBHFileName
					
		--Since we checked the status of the file on disk, we can either send alert or go on to mark as not on disk.
		IF @RC = 0 
		BEGIN
			UPDATE [DBServices].[dbo].dbsDatabaseBackupHistory
			SET dbsDBHIsOnDiskFlag = 0
			WHERE dbsDBHID = @dbsDBHID
		END ----------------
		ELSE -- Del Failed, check to retry
		IF @DelCount <= @DeleteRetryCount
		BEGIN
			SET @DelCount = @DelCount + 1

			WAITFOR DELAY @DeleteRetryDelay 
			GOTO DELETEFILE	-- retry
		END ----------------
		ELSE -- @KeepFile = 0, File Del failed
		BEGIN 
			SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: File: ' 
				+ ISNULL(@dbsDBHFileName, 'NULL') 
				+ ' could not be purged (retry: ' + CAST(@DelCount as varchar(3)) 
				+ '/' + CAST(@DeleteRetryCount as varchar(3)) + ')'

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity
		END
	END ----------------
	ELSE -- Keep File - check if file still exists
	IF @KeepFile = 1
	BEGIN
		--See if the file actually still exists on disk.

		CHECK_FILE_EXISTS:

		SET @exists = 0
		EXEC @RC = [DBServices].[dbo].[usp_FileExists] 
			   @dbsDBHFileName
			  ,@exists OUTPUT

		IF @RC = 0 AND @exists = 0
		BEGIN
			SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: File ' +  @dbsDBHFileName
				+ ' is flagged to keep however it no longer physically exists.'
				+ CASE 
					WHEN (@NB_Enabled = 1 OR @CV_Enabled = 1)
						AND ((ISNULL(@dbsDBHSentToNBFlag, 0) = 0) OR (ISNULL(@IsSuccess, 0) = 0))
						THEN ' => UBSMWE was unable backup the file to offsite storage!'
					ELSE ''
				END

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity

			UPDATE [DBServices].[dbo].[dbsDatabaseBackupHistory]
			SET dbsDBHIsOnDiskFlag = 0
			WHERE dbsDBHID = @dbsDBHID
		END
		-- ELSE file still exists
	END ----------------
	ELSE -- Unhandled exception
	BEGIN 
		SET @ErrMsg = 'UBSMWE: usp_PurgeOldBackupFiles: Unhandled exception - File: ' +  @dbsDBHFileName 
			+ ' Manifest:' + ISNULL(CAST(@dbsNetbackupID as varchar(12)), '?')
			+ ', KeepFile:' +  ISNULL(CAST(@KeepFile as char(1)), '?')
			+ ', dbsDBHSentToNBFlag: ' + ISNULL(CAST(@dbsDBHSentToNBFlag as char(1)), '?') 
			+ ', IsSuccess:' + ISNULL(CAST(@IsSuccess as char(1)), '?')
			+ ', ' + CASE
						WHEN @CV_Enabled = 1 THEN 'CV FS backups enabled' 
						WHEN @NB_Enabled = 1 THEN 'NB FS backups enabled'   
					ELSE 'FS backups disabled'
				END
			+ ' => EXEC DBServices..usp_ResetBackupHistoryStatus'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrMsg, @AlertSeverity

		GOTO CHECK_FILE_EXISTS
	END ----------------

	IF @debug >= 2
	BEGIN
		PRINT '--Debug-------------------------------------------------------------'
		PRINT 'File status:'
		SELECT @dbsDBHFileName as 'File'
			,@KeepFile as 'KeepFile'
			,@dbsDatabaseUID as 'dbsDatabaseUID'
			,@dbsDBHEndDate as 'dbsDBHEndDate'
			,@dbsDBHSentToNBFlag as 'dbsDBHSentToNBFlag'
			,@IsSuccess as 'FS Bak IsSuccess'
	END

	FETCH NEXT FROM dbsDatabaseFile_cur 
		INTO @dbsDatabaseUID, @dbsDBHID, @dbsDBHEndDate, @dbsDBHFileName
			, @dbsDBHSentToNBFlag, @IsSuccess, @dbsNetbackupID	
END-- end while

CLOSE dbsDatabaseFile_cur
DEALLOCATE dbsDatabaseFile_cur

--------------------------------------------------------------
--Begin the purge of information FROM the local store if it has not already been pushed to central site.

BEGIN 
	--Start with the ultimate child tables FROM the Netbackup side first.
	--Order of Deletion is
	--dbo.dbsNetbackupStatus
	--dbo.dbsNetbackupManifest, including the purging of the Netbackup directories, 
	--	we can get the information of the log files to purge FROM the location of the log files 
	--in dbo.dbsNetbackup.dbsNetbackupFileListName and dbo.dbsNetbackup.dbsNetbackupLogName
	--dbo.dbsNetbackup
		
	--Need to get the MAX dbsNetbackupID before deleting FROM the child tables.
	--We will purge all records that are at or below the MAX 
	
	SELECT @MAXdbsNetbackupID = MAX(nbm.dbsNetbackupID)
		,@MAXdbsDBHID = MAX(DBH.dbsDBHID)
	FROM [DBServices].[dbo].dbsDatabaseBackupHistory DBH
	LEFT OUTER JOIN	[DBServices].[dbo].dbsNetbackupManifest nbm
		ON	DBH.dbsDBHID = nbm.dbsDBHID 
	WHERE DATEDIFF(day, DBH.dbsDBHStartDate, getdate()) >= @dbsLocalHistoryRetainDays 
		AND DBH.dbsDBHIsOnDiskFlag = 0
	GROUP BY DBH.dbsDBHID, nbm.dbsNetbackupID
	ORDER BY DBH.dbsDBHID, nbm.dbsNetbackupID

	---------------------	
	-- Remove the entry in the dbsNetbackup table and the associated Directory.
	DECLARE @ManifestDir varchar(255)
	
	DECLARE curManifest CURSOR KEYSET
	FOR SELECT dbsNetbackupLogName, dbsNetbackupFileListName 
	FROM dbo.dbsNetbackupStatus --dbo.dbsNetbackup
	WHERE dbsNetbackupID <= @MAXdbsNetbackupID
	OPEN curManifest
	
	FETCH NEXT FROM curManifest 
		INTO @dbsNetbackupLogName, @dbsNetbackupFileListName
	WHILE (@@fetch_status <> -1)
	BEGIN
		IF (@@fetch_status <> -2)
		BEGIN
			PRINT 'Deleting Manifest Log  ' + @dbsNetbackupLogName
	
			EXEC @RC = [DBServices].[dbo].[usp_DelFile] @Filename = @dbsNetbackupLogName
		END
		BEGIN
			PRINT 'Deleting Manifest FileList  ' + @dbsNetbackupFileListName
	
			EXEC @RC = [DBServices].[dbo].[usp_DelFile] @Filename = @dbsNetbackupFileListName
		END
	FETCH NEXT FROM curManifest
		INTO @dbsNetbackupLogName, @dbsNetbackupFileListName
	END
	CLOSE curManifest
	DEALLOCATE curManifest

	--Now that we have saved the MAX dbsNetbackupID we will delete all records FROM 
	--dbsNetbackupStatus that are at or below the MAX dbsNetbackupID
	--DELETE 
	DELETE
	FROM [DBServices].[dbo].dbsNetbackupStatus
	WHERE dbsNetbackupID <= @MAXdbsNetbackupID
	
	-- delete all records FROM dbsNetbackupManifest that are at or below the MAX dbsNetbackupID
	DELETE
	FROM [DBServices].[dbo].dbsNetbackupManifest
	WHERE dbsNetbackupID <= @MAXdbsNetbackupID
	
	--Now actually purge FROM the table...
	DELETE FROM [DBServices].[dbo].dbsNetbackup
	WHERE dbsNetbackupID <= @MAXdbsNetbackupID

	-- Deleting FROM dbo.dbsDatabaseBackupHistory for those elegable records that do not still have associated records in dbsNetbackupManifest
	DELETE FROM [DBServices].[dbo].dbsDatabaseBackupHistory
	FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbbh
	LEFT OUTER JOIN	[DBServices].[dbo].dbsNetbackupManifest nbm
		ON dbbh.dbsDBHID = nbm.dbsDBHID 
	WHERE dbbh .dbsDBHID <= @MAXdbsDBHID 
		AND nbm.dbsDBHID IS NULL
	
	DELETE FROM [DBServices].[dbo].WorkFlowTaskHistory
	WHERE DATEDIFF(day, WFTaskStartDate, getdate()) >= @dbsLocalHistoryRetainDays 

END

--------------------------------------------------------------

IF OBJECT_ID('tempdb..#LSBackupFile') IS NOT NULL 
	DROP TABLE #LSBackupFile 

RETURN 0 -- always return success as called from the engine

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_RegisterCVcmdshell]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_RegisterCVcmdshell] (
		@mode as tinyint	-- 0 - Unregister CLR, 1 - Register client, 2 - Add instance, 3 - TRRv3 change CV Tlog backup staging folder, 4 - Verify reg only
		, @align as nvarchar(3) = NULL 
		, @CV_SqlLogBackupStageFolder as nvarchar(255) = NULL -- TRRv3 ONLY  mandatory; root Tlog staging path
		, @CV_Segregation as nvarchar(63) = 'ALL') -- TRRv3 optional; Some environments (Simpana 10) require a data segregation configuration (case sensitive)
AS

/****************************************************************************************
// @File: register_cvcmdshell.SQL
//
// Purpose:
//   Register cv_cmdshell to run Qcommnands  [dbo].[register_cvcmdshell] 0
//
// Notes: This stored procedure is used to register client, instance and other components needed
//		  for toolkit operations. Uses CLR
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: 4.1.0 @Action: Register DBCLR.DLL to run qcommnds form T-SQL
//   @Date: 07/08/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 Beta
//   @Date: 18/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta
//   @Date: 29/08/2014 @Author: Chris Basson @Version: 6.0.0.5 @Action: TRRv3 Beta
//   @Date: 09/09/2014 @Author: Chris Basson @Version: 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 29/09/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 22/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 31/10/2014 @Author: Chris Basson @Version: 6.0.0.9 @Action: TRRv3 Beta
//   @Date: 21/11/2014 @Author: Chris Basson @Version: 6.0.0.12 @Action: TRRv3 Beta
//   @Date: 08/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 BAS wait times
//   @Date: 25/02/2015 @Author: Chris Basson @Version: 6.0.0.25 @Action: Feature request: add DB backup monitoring for CV TRRv3 
//   @Date: 31/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: default @CV_Segregation
//   @Date: 10/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Feature: DisableAdv 
//   @Date: 17/06/2015 @Author: Chris Basson @Version: 6.0.0.32 @Action: Feature: Mode 4 - Verify reg only
//   @Date: 04/09/2015 @Author: Chris Basson @Version: 6.0.0.38 @Action: Minor bugfix: skip CV staging folder check if not TRRv3
//   @Date: 01/10/2015 @Author: Chris Basson @Version: 6.0.0.39 @Action: Minor update - display config info
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE 
	@dropAssembly int
	,@o_retVal int
	,@SQLstr nvarchar(4000) 
	,@i_FullDLLPath nvarchar(4000)
	,@CVTRRurl nvarchar(256)
	,@DefaultWaitDelay char(8)
	,@RC int
	,@clu nvarchar(30)
	,@CV_BPBackup_ExecutableLocation nvarchar(255)
	,@CVClient nvarchar(128)
	,@CVFQDNCommCell nvarchar(100)
	,@CVInstance nvarchar(128) 
	,@InstanceFound int
	,@response nvarchar(4000)
	,@searchCmd nvarchar(4000)
	,@dbsBackupProcessor tinyint
	,@CV_SqlLogBackupStageFolder_out nvarchar(255) 
	,@CV_SqlLogBackupStageFolder_Derived nvarchar(255) 
	,@CV_bTLBackupToFS_out int 
	,@CV_backupFromFSForLog_out int                          
	,@ErrorMsg nvarchar(512)
	,@CV_RootPath nvarchar(255)
	,@CV_SqlLogBackupInterval_out int
	,@IsClustered bit
	,@DisableAdv bit

------------------------------------------                    
-- Init Vars

SET @DefaultWaitDelay = '00:00:10'
SET @dropAssembly = 1  -- 1 = true , 0 = false

SET @CV_Segregation = ISNULL(LTRIM(RTRIM(@CV_Segregation)), 'ALL') 
SET @CV_SqlLogBackupStageFolder = LTRIM(RTRIM(@CV_SqlLogBackupStageFolder))
SET @CV_SqlLogBackupStageFolder = CASE 
									WHEN RIGHT(@CV_SqlLogBackupStageFolder, 1) = '\' 
											THEN LEFT(@CV_SqlLogBackupStageFolder,LEN(@CV_SqlLogBackupStageFolder)-1)
									ELSE @CV_SqlLogBackupStageFolder
								  END
SET @InstanceFound = 0
SET @IsClustered = 0 


IF @mode NOT IN (0,1,2,3,4)
BEGIN
	SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Invalid @mode value - options: 0=Unregister CLR, 1=Register client, 2=Add instance, 3=TRRv3 change root CV Tlog backup staging folder, 4=Verify only'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	GOTO END_IT
END

-----------------------------------------
-- Get config

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVTRRurl', @CVTRRurl OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CVFQDNCommCell', @CVFQDNCommCell OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_RootPath', @CV_RootPath OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DisableAdv', @DisableAdv OUTPUT, @quiet = 1


-- Verifying Cluster failover status

IF CAST(SERVERPROPERTY('IsClustered') as bit) = 1
BEGIN
	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsIsInstanceClusteredFlag', 1 
	SET @IsClustered = 1
END

IF @IsClustered = 1
	EXEC [DBServices].[dbo].usp_UpdateActiveServerName


SET @CVTRRurl= LTRIM(RTRIM(@CVTRRurl))	
SET @CVFQDNCommCell = LTRIM(RTRIM(@CVFQDNCommCell))

--load configuration values
EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 
SET @clu = '&clu=' + @CVClient

PRINT 'Instance: ' + @CVInstance
PRINT 'Client: ' + @CVClient 

PRINT 'dbsBackupProcessor: ' + CAST(@dbsBackupProcessor as char(1))
PRINT 'CVTRRurl: ' + @CVTRRurl
PRINT 'CVFQDNCommCell: ' + @CVFQDNCommCell 
PRINT 'DisableAdv: ' + CAST(@DisableAdv as char(1))

-----------------------------------------
-- verify input @CV_SqlLogBackupStageFolder

IF @dbsBackupProcessor = 5 
	AND @mode NOT IN (0,4)
BEGIN
	IF (CHARINDEX (UPPER(@CVInstance), UPPER(@CV_SqlLogBackupStageFolder)) > 0)
	BEGIN
		SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Registration failed as the Instance name has been identified in the given @CV_SqlLogBackupStageFolder path which is not permitted.'
		+ ' Please note UBSMWE will create a subfolder for the given Instance as per CommVault standards.'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
		GOTO END_IT
	END --------------
	ELSE
	IF LEN (@CV_SqlLogBackupStageFolder) > 128
	BEGIN
		SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: @CV_SqlLogBackupStageFolder root path must be no longer than 128 characters in length,'
		+ ' the path provided is ' + CAST (LEN(@CV_SqlLogBackupStageFolder) as varchar(3))
		+ ' chars. Please note UBSMWE will additionally create a subfolder for the given Instance as per CommVault standards.'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
		GOTO END_IT
	END
END

-----------------------------------------
-- CLR reg handler

IF @mode = 0 
BEGIN
	--unregister CLR

	SET @SQLstr = 'USE DBServices' + CHAR(10)
	SET @SQLstr = @SQLstr + 'IF EXISTS (SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[cv_cmdshell]'') AND type IN (N''P'', N''PC'')) ' + CHAR(10)
	SET @SQLstr = @SQLstr + ' DROP PROCEDURE [dbo].[cv_cmdshell]' + CHAR(10)

	EXEC sp_executesql @SQLstr

	IF @dropAssembly = 1 
	BEGIN
		SET @SQLstr = 'USE DBServices' + CHAR(10)
		SET @SQLstr = @SQLstr + 'IF EXISTS (SELECT name FROM sys.assemblies asms WHERE asms.name = N''dbCLR'') ' + CHAR(10)
		SET @SQLstr = @SQLstr + ' DROP ASSEMBLY [dbCLR] ' + CHAR(10)

		EXEC sp_executesql @SQLstr
 
		SET @o_retVal = @@ERROR	-- 0 (success) or non-zero (failure)
		IF @o_retVal <> 0 
		BEGIN
			SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled exception: DROP ASSEMBLY [dbCLR]'
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
		END
		ELSE
			PRINT 'OK - CLR Unregistered'
			
		GOTO END_IT
	END
END

IF @mode <> 4
BEGIN
	IF ISNULL(@align, '') = ''
	BEGIN
		SET @align ='ANY'
		PRINT '@align parameter was not specified, defaulting to ANY - An optimal day will be chosen by CV for this host'
	END --------------
	ELSE
	BEGIN
		SET @align = UPPER(@align)
		IF @align NOT IN ('MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN', 'ANY') 
		BEGIN
			PRINT 'Invalid day of the week chosen for full backup alignment: ' + @align 
				+ ' options: MON, TUE, WED, THU, FRI, SAT, SUN, ANY (default)'
			GOTO END_IT
		END
	END
END

IF @mode = 3 AND @dbsBackupProcessor <> 5
BEGIN
	PRINT 'The parameter @mode = 3 is reserved for TRRv3 (dbsBackupProcessor=5) - configured dbsBackupProcessor value = ' + CAST (@dbsBackupProcessor as char(1))
	GOTO END_IT
END

IF EXISTS (SELECT 1
		FROM [DBServices].[sys].[objects]
		WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
	GOTO OK_REG

-----------------------------------------
-- ELSE - Create CLR components

--set to dynamic to supress errors on SQL2000 installs (this sp is not needed but it still errors out at install on sql2000
SET @SQLstr = 'ALTER DATABASE DBServices SET TRUSTWORTHY ON'
EXEC sp_executesql @SQLstr

SET @i_FullDLLPath = @CV_RootPath + '\Simpana\Base\dbclr.dll'	-- dbclr.dll PATH

SET @SQLstr = 'USE DBServices' + CHAR(10)
SET @SQLstr = @SQLstr + 'IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[cv_cmdshell]'') AND type IN (N''P'', N''PC'')) ' + CHAR(10)
SET @SQLstr = @SQLstr + ' DROP PROCEDURE [dbo].[cv_cmdshell]' + CHAR(10)

EXEC sp_executesql @SQLstr

SET @o_retVal = @@ERROR
IF @o_retVal <> 0 
BEGIN
	SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled exception: DROP PROCEDURE [dbo].[cv_cmdshell]'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	GOTO END_IT
END

SET @SQLstr = 'USE DBServices' + CHAR(10)
SET @SQLstr = @SQLstr + 'IF NOT EXISTS (SELECT name FROM sys.assemblies asms WHERE asms.name = N''dbCLR'') ' + CHAR(10)
SET @SQLstr = @SQLstr + 'CREATE ASSEMBLY dbCLR FROM N''' + @i_FullDLLPath + ''' WITH PERMISSION_SET = UNSAFE ' + CHAR(10)

EXEC sp_executesql @SQLstr

SET @o_retVal = @@ERROR
IF @o_retVal <> 0 
BEGIN
	SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled exception: CREATE ASSEMBLY dbCLR'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	GOTO END_IT
END

SET @SQLstr = 'CREATE PROCEDURE [dbo].[cv_cmdshell] (@input nvarchar(4000), @response nvarchar(4000) OUTPUT) ' + CHAR(10)
SET @SQLstr = @SQLstr + 'WITH EXECUTE AS CALLER ' + CHAR(10)
SET @SQLstr = @SQLstr + 'AS ' + CHAR(10)
SET @SQLstr = @SQLstr + 'EXTERNAL NAME [dbCLR].[StoredProcedures].[cv_cmdshell] ' + CHAR(10)
SET @SQLstr = 'USE DBServices' + CHAR(10) + 'EXECUTE ('' '+ @SQLstr +' '')'

EXEC sp_executesql @SQLstr 

SET @o_retVal = @@ERROR 
IF @o_retVal <> 0
BEGIN
	SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled exception: CREATE PROCEDURE [dbo].[cv_cmdshell]'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	GOTO END_IT
END

-----------------------------------------
OK_REG:

-- Check cv_cmdshell exists:
IF NOT EXISTS (SELECT 1
				FROM [DBServices].[sys].[objects]
				WHERE [type] = 'PC' AND [name] = 'cv_cmdshell')
BEGIN
	SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: CLR stored proceedure [cv_cmdshell]'
			+ ' failed registration. Please refer to troubleshooting section of the Install and User guide'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
	GOTO END_IT
END
	PRINT 'CLR stored proceedure [cv_cmdshell] check - OK'

IF @mode = 1
BEGIN
	PRINT 'Attempting to register the client via the BAS command:'

	SET @SQLstr = @CVTRRurl + '/SqlRegisterClient?' + @CVClient 
				+ '&sched=' + @align  

	IF @dbsBackupProcessor = 5
		SET  @SQLstr = @SQLstr + '&entity=' + @CV_Segregation

	PRINT @SQLstr
    EXEC @RC = [DBServices].[dbo].[usp_wget] @SQLstr

	IF @RC <> 0
	BEGIN
		-- Command failed
		SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Client registration command failed!'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info
		GOTO END_IT
	END

    --http interface takes time so need to wait for commands to propagate

    WAITFOR DELAY @DefaultWaitDelay
END

-----------------------------------------
-- Verify CV Tlog Backup Staging status if TRRv3

IF @dbsBackupProcessor = 5 -- TRRv3 
BEGIN
	IF @mode <> 4
		AND ISNULL(@CV_SqlLogBackupStageFolder,'') = '' 
	BEGIN
		PRINT 'CV Scheduling is enabled; please specify the hosts ROOT TLog staging path e.g. @CV_SqlLogBackupStageFolder = ''D:\MSSQL\Backup'''
		IF @mode <> 1
		BEGIN 
			PRINT 'Current values: ' 
			EXEC @RC = [DBServices].[dbo].usp_Help_CVTLogBakStagingStatus

			IF @RC <> 0
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled Exception calling usp_Help_CVTLogBakStagingStatus'
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- error
			END
			GOTO END_IT
		END
	END --------------
	ELSE
	BEGIN
		SET @CV_SqlLogBackupStageFolder_out = ''

		IF @mode <> 1
		BEGIN 
			EXEC @RC = [DBServices].[dbo].[usp_CVTLogBakStagingStatus] 
					@CV_SqlLogBackupStageFolder = @CV_SqlLogBackupStageFolder_out OUTPUT
					, @CV_bTLBackupToFS = @CV_bTLBackupToFS_out  OUTPUT
					, @CV_backupFromFSForLog = @CV_backupFromFSForLog_out  OUTPUT 
					, @CV_SqlLogBackupInterval = @CV_SqlLogBackupInterval_out OUTPUT 

			IF @RC <> 0
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled Exception calling usp_CVTLogBakStagingStatus'
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- error
				
				GOTO END_IT
			END

			IF @CV_bTLBackupToFS_out <> 1 OR @CV_backupFromFSForLog_out <> 1
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Error - CV Scheduled TLog backups are incorrectly configured; please contact Backup Services -'
					+ 'The following CV reg settings should be set to = 1 :' 
					+ ' bTLBackupToFS = ' + CAST (@CV_bTLBackupToFS_out as nvarchar(2)) 
					+ ' backupFromFSForLog ' + CAST (@CV_backupFromFSForLog_out as nvarchar(2))	
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3 -- error
				
				GOTO END_IT
			END
		END ----------

		SET @CV_SqlLogBackupStageFolder_out = ISNULL(@CV_SqlLogBackupStageFolder_out,'NULL')

		IF @mode = 4
			SET @CV_SqlLogBackupStageFolder = @CV_SqlLogBackupStageFolder_out

		EXEC DBServices.dbo.usp_FileExists 
			@FileName = @CV_SqlLogBackupStageFolder
			, @exists = @RC OUTPUT

		IF @RC = 0
		BEGIN
			PRINT 'ERROR: folder ' + @CV_SqlLogBackupStageFolder + ' could not be located!'
				+ ' - Please verify and ensure both the MSSQL Service account and ''NT Authority\System'' has FULL permissions'
			GOTO END_IT
		END
		
		IF @mode = 2
		BEGIN
			PRINT 'Requesting a root CV Scheduled TLog backup staging folder change for the host:'
			PRINT 'Original value: ' + @CV_SqlLogBackupStageFolder_out
			PRINT 'New value: ' + @CV_SqlLogBackupStageFolder
		END
	END
END

-----------------------------------------
-- Client CommCell Reg handler

IF @mode = 1 
	GOTO Reg_Instance_DO

WHILE @InstanceFound <> 1
BEGIN
	PRINT 'Verifying CV client registration....'

	SET @response=NULL
	SET @searchCmd = N'.\Brat\bin\cvcfglist -type mssql -instance ' 
				+ '-clientName ' + @CVClient + ' -cs ' + @CVFQDNCommCell 

	EXEC @RC = [DBServices].[dbo].[cv_cmdshell]
				@input = @searchCmd,
				@response = @response OUTPUT

	PRINT '=> CV Response: ' + CHAR(13) + @response

	IF CHARINDEX(@CVInstance, @response) > 0
		SET @InstanceFound = 1
	ELSE --------------
	IF @mode = 2 
		GOTO Reg_Instance_DO
	ELSE --------------
		SET @InstanceFound = @InstanceFound - 1
	
	IF @InstanceFound = -2 -- Retry once
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: '
			+ 'The host does not appear to have been registered with CV; please verify the input parameters or register the instance using @mode=2' 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info

		GOTO END_IT
	END
END

-----------------------------------------
-- Reg Instance DO

Reg_Instance_DO:

IF @mode IN (1,2) 
	AND @InstanceFound = 0
BEGIN
	PRINT 'Attempting to register the instance via the BAS command:'

	SET @SQLstr = @CVTRRurl + '/SqlAddInstance?inst=' + @CVInstance + @clu

	IF @dbsBackupProcessor = 5
	BEGIN
		SET @SQLstr = @SQLstr + '&fs=' + @CV_SqlLogBackupStageFolder 

		SET  @SQLstr = @SQLstr + '&entity=' + @CV_Segregation
	END

	PRINT @SQLstr
	EXEC @RC = [DBServices].[dbo].usp_wget @SQLstr

	IF @RC <> 0
	BEGIN
		-- Command failed
		SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Add instance command failed!'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- info

		GOTO END_IT
	END --------------
	ELSE
		SET @InstanceFound = 1
END --------------
ELSE
IF @mode = 3 
	AND @InstanceFound = 1
	AND @dbsBackupProcessor = 5
BEGIN

	PRINT 'Attempting to change the CV TLog backup staging folder via the BAS command:'

	SET @SQLstr = @CVTRRurl + '/SqlChgInstance?inst=' + @CVInstance 
		+ @clu + '&fs=' + @CV_SqlLogBackupStageFolder 

	SET  @SQLstr = @SQLstr + '&entity=' + @CV_Segregation

	PRINT @SQLstr
    EXEC @RC = [DBServices].[dbo].[usp_wget] @SQLstr

	IF @RC <> 0
	BEGIN
		-- Command failed
		SET @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Change instance command failed!'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning
		GOTO END_IT
	END --------------
	ELSE
		SET @InstanceFound = 1
END

-----------------------------------------
--Instance - ok

INSTANCE_OK:

IF @mode = 4
BEGIN
	IF @dbsBackupProcessor = 5
	BEGIN
		EXEC @RC = [DBServices].[dbo].usp_Help_CVTLogBakStagingStatus

		EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'dbsInstanceFileLocation'
	END

	GOTO INSTANCE_FOUND -- Skip CV propagation step
END

-----------------------------------------
--http interface takes time so need to wait for commands to propagate

PRINT CHAR(13) + '-----------------------------------------' + CHAR(13)
PRINT CHAR(13) + 'BAS request returned successful' 

IF @dbsBackupProcessor = 5 
	AND @mode <> 4
BEGIN

	IF @DisableAdv = 1
	BEGIN
		--Advanced feature set disabled

		EXEC [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'CV_REGISTERED', '1' -- assume successful...

		PRINT CHAR(13) + '********************************************************************************'
		PRINT 'UBSMWE: usp_RegisterCVcmdshell: DisableAdv = 1 - advanced feature set disabled'
		PRINT '- consequently unable to identify if the registration was successful, thus:'
		PRINT CHAR(13) + 'IMPORTANT!'
		PRINT '1) Wait a couple of minutes'
		PRINT '2) Manually restart the CV client services for the registration to take effect'
		PRINT '3) Restart the main UBSMWE_Engine job for the toolkit to identify the changes'
		PRINT '4) Verify the staging folder has been picked up by running:'
		PRINT '		EXEC DBServices..usp_ConfigureUBSMWE ''dbsInstanceFileLocation'''
		PRINT '=> Repeat from step 1 if the path has not been identified'
		PRINT CHAR(13) + '********************************************************************************'

		RETURN 0
	END

	SET @InstanceFound = 0

	PRINT CHAR(13) + '-----------------------------------------' + CHAR(13)
	PRINT 'CommServe to Client propagation stage:'
	PRINT '=> Restarting CommVault Services for the changes to take effect'+ CHAR(13)
	PRINT 'Please note this is slow process which will take a few minutes...'

	-----------------------------------------
	VERIFY_CV_SqlLogBackupStageFolder:

	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay

	EXEC @RC = [DBServices].[dbo].[usp_CVKickService] 2 -- Stop CV services
	IF @RC <> 0
	BEGIN
		SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Failed to stop CV services'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 -- info

		GOTO CHK_IT
	END
	--------------
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	
	EXEC @RC = [DBServices].[dbo].[usp_CVKickService] 3 -- Start CV services
	IF @RC <> 0
	BEGIN
		SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Failed to restart CV services'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning

		GOTO CHK_IT
	END
	--------------
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay

	PRINT CHAR(13) + '-----------------------------------------' + CHAR(13)
	
	EXEC @RC = [DBServices].[dbo].[usp_CVKickService] 1 -- Query CV services

	-- wait 60s
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay
	WAITFOR DELAY @DefaultWaitDelay

	-----------------------------------------
	-- Verify CV Tlog Backup Staging folder status

	SET @CV_SqlLogBackupStageFolder_out = NULL

	EXEC @RC = [DBServices].[dbo].[usp_CVTLogBakStagingStatus] 
			@CV_SqlLogBackupStageFolder = @CV_SqlLogBackupStageFolder_out OUTPUT
			, @CV_bTLBackupToFS = @CV_bTLBackupToFS_out  OUTPUT
			, @CV_backupFromFSForLog = @CV_backupFromFSForLog_out  OUTPUT 
			, @CV_SqlLogBackupInterval = @CV_SqlLogBackupInterval_out OUTPUT 
	
	CHK_IT:

	IF @RC = 0 AND LOWER(@CV_SqlLogBackupStageFolder_out) = LOWER(@CV_SqlLogBackupStageFolder)
	BEGIN
		PRINT '*************************************************************************************************************'
		PRINT CHAR(13) + 'Please Note:' 
		PRINT 'All STANDALONE MSSQL instances on this host registered for CV Scheduled Backups will also need to be updated accordingly;'
		PRINT 'i.e. Run:'
		PRINT CHAR(13) + CHAR(9) + 'DECLARE @CV_SqlLogBackupStageFolder as nvarchar(255)'
		PRINT CHAR(9) + 'SET @CV_SqlLogBackupStageFolder = ''' + @CV_SqlLogBackupStageFolder
					+ ''' + ''\'' + CASE @@SERVICENAME
									WHEN ''MSSQLSERVER'' THEN LOWER(CAST(SERVERPROPERTY (''MachineName'') as nvarchar(128)))
									ELSE LOWER(CAST(SERVERPROPERTY (''MachineName'') as nvarchar(128))) + ''_'' + @@SERVICENAME
								 END'
		PRINT CHAR(13) + CHAR(9) + 'EXEC DBServices..usp_ConfigureUBSMWE ''NB_WorkDirectory'', @CV_SqlLogBackupStageFolder'
		PRINT CHAR(9) + 'EXEC DBServices..usp_ConfigureUBSMWE ''dbsInstanceFileLocation'', @CV_SqlLogBackupStageFolder'
		PRINT CHAR(9) + 'GO' + CHAR(13)
		PRINT '*************************************************************************************************************'
		PRINT CHAR(13) + '! CLUSTERED MSSQL instances however need to be individually registered using usp_RegisterCVcmdshell !' + CHAR(13)
		PRINT '*************************************************************************************************************'

		PRINT CHAR(13) + '=> Updating local dbsInstanceConfig data accordingly...'

		SET @InstanceFound = 1

		SET @CV_SqlLogBackupStageFolder_Derived = @CV_SqlLogBackupStageFolder 
					+ '\' + REPLACE (@CVInstance, '\', '_')

		-- Update UBSMWE paths
		EXEC @RC = DBServices.dbo.usp_ConfigureUBSMWE 'dbsInstanceFileLocation', @CV_SqlLogBackupStageFolder_Derived
		IF @RC <> 0
		BEGIN
			SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: Unhandled exception: UBSMWE configuraton option dbsInstanceFileLocation'
					+ ' could not be set with the path: ' + @CV_SqlLogBackupStageFolder
					+ ' - Investigation required. Recommend the local CommVault Services are restarted before retrying.'

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning
			GOTO END_IT		
		END
		ELSE
			EXEC @RC = DBServices.dbo.usp_ConfigureUBSMWE 'NB_WorkDirectory', @CV_SqlLogBackupStageFolder_Derived 
	END --------------
	ELSE
	BEGIN
		IF @InstanceFound = -2 
		BEGIN
			SET  @ErrorMsg = 'UBSMWE: usp_RegisterCVcmdshell: ERROR: CommServe update request response has timed out.'
				+ ' Unable to confirm if the requested CV TLog backup staging folder has taken affect.'
				+ ' Current CV config: ' + @CV_SqlLogBackupStageFolder_out 
				+ ' Requested path: ' + @CV_SqlLogBackupStageFolder
				+ ' Recommend the local CommVault Services are restarted before retrying.'

			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning
			GOTO END_IT
		END --------------
		ELSE
		BEGIN
			-- Wait for one more go
			SET @InstanceFound = @InstanceFound - 1
			
			PRINT 'The CommServe client configuration push has still not occured, retrying....' 
		
			WAITFOR DELAY @DefaultWaitDelay
			WAITFOR DELAY @DefaultWaitDelay
			WAITFOR DELAY @DefaultWaitDelay

			GOTO VERIFY_CV_SqlLogBackupStageFolder
		END
	END
END

-----------------------------------------
-- Return status

INSTANCE_FOUND:

PRINT '-----------------------------------------'

IF @InstanceFound = 1
BEGIN
	PRINT '=> OK ' + @CVInstance + ' is registered'
	EXEC [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'CV_REGISTERED', '1'

	RETURN 0
END --------------
ELSE
	PRINT '=> ERROR: Unable to identify instance ' + @CVInstance + ' registration'

END_IT:

RETURN 1
      
END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ResetBackupHistoryStatus]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_ResetBackupHistoryStatus] @Commit bit = 0, @truncate bit = 0
AS

/****************************************************************************************
// @File: usp_ResetBackupHistoryStatus.sql
// 
// Purpose: User initiated sp which resets dbsDatabaseBackupHistory in the event of data corruption
//			
//
// Notes: Use with care! - responsibility of the user to ensure files have been backed up offsite 
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 19/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.29 @Action: Creation
//   @Date: 24/09/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.38 @Action: Added truncate option
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week
SET NOCOUNT ON

DECLARE @BackupLocationDrive varchar(255)
	,@sql1 varchar(1024)


IF @truncate = 1
BEGIN

	PRINT '=> Truncating table dbsDatabaseBackupHistory'

	-- Drop constraints
	IF EXISTS (SELECT 1 FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_dbsNetbackupManifest_dbsDatabaseBackupHistory]') AND parent_object_id = OBJECT_ID(N'[dbo].[dbsNetbackupManifest]'))
		ALTER TABLE [dbo].[dbsNetbackupManifest] DROP CONSTRAINT [FK_dbsNetbackupManifest_dbsDatabaseBackupHistory]

	IF EXISTS (SELECT 1 FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[dbsDatabaseBackupHistory]') AND name = N'PK_dbsDatabaseBackupHeaderDetail')
		ALTER TABLE [dbo].[dbsDatabaseBackupHistory] DROP CONSTRAINT [PK_dbsDatabaseBackupHeaderDetail]

	IF EXISTS (SELECT 1 FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_dbsDatabaseBackupHistory_dbsDatabase]') AND parent_object_id = OBJECT_ID(N'[dbo].[dbsDatabaseBackupHistory]'))
		ALTER TABLE [dbo].[dbsDatabaseBackupHistory] DROP CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabase]

	IF EXISTS (SELECT 1 FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N'[dbo].[FK_dbsDatabaseBackupHistory_dbsDatabaseBackupProcessor]') AND parent_object_id = OBJECT_ID(N'[dbo].[dbsDatabaseBackupHistory]'))
		ALTER TABLE [dbo].[dbsDatabaseBackupHistory] DROP CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabaseBackupProcessor]

	IF EXISTS (SELECT 1 FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[dbsDatabaseBackupHistory]') AND name = N'IX_dbsDatabaseBackupHistory_dbsDatabaseUID')
		DROP INDEX [IX_dbsDatabaseBackupHistory_dbsDatabaseUID] ON [dbo].[dbsDatabaseBackupHistory] WITH ( ONLINE = OFF )

	--------------
	-- Truncate 

	TRUNCATE TABLE DBServices.dbo.dbsDatabaseBackupHistory

	--------------
	-- Recreate constraints

	ALTER TABLE [dbo].[dbsDatabaseBackupHistory] ADD  CONSTRAINT [PK_dbsDatabaseBackupHeaderDetail] PRIMARY KEY CLUSTERED 
	(
		[dbsDBHID] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	
	ALTER TABLE [dbo].[dbsDatabaseBackupHistory]  WITH CHECK ADD CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabase] FOREIGN KEY([dbsDatabaseUID])
	REFERENCES [dbo].[dbsDatabase] ([dbsDatabaseUID])
	
	ALTER TABLE [dbo].[dbsDatabaseBackupHistory] CHECK CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabase]
	
	ALTER TABLE [dbo].[dbsDatabaseBackupHistory]  WITH NOCHECK ADD  CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabaseBackupProcessor] FOREIGN KEY([dbsDBackupProcessorID])
	REFERENCES [dbo].[dbsDatabaseBackupProcessor] ([dbsDatabaseBackupProcessorID]) NOT FOR REPLICATION 
	
	ALTER TABLE [dbo].[dbsDatabaseBackupHistory] NOCHECK CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabaseBackupProcessor]
	
	ALTER TABLE [dbo].[dbsNetbackupManifest]  WITH NOCHECK ADD CONSTRAINT [FK_dbsNetbackupManifest_dbsDatabaseBackupHistory] FOREIGN KEY([dbsDBHID])
	REFERENCES [dbo].[dbsDatabaseBackupHistory] ([dbsDBHID])

	ALTER TABLE [dbo].[dbsNetbackupManifest] CHECK CONSTRAINT [FK_dbsNetbackupManifest_dbsDatabaseBackupHistory]

	RETURN 0
END
-- ELSE

-------------------------------------------------
-- Build physical backup filelist

IF object_id('tempdb..#files_tbl') IS NOT NULL
	DROP TABLE #files_tbl

CREATE TABLE #files_tbl (filename varchar(255))

DECLARE BackupLocationDrive_cur CURSOR FORWARD_ONLY FOR
SELECT DISTINCT SUBSTRING(dbsDBHFileName, 1, 3)
FROM DBServices.dbo.dbsDatabaseBackupHistory
OPEN BackupLocationDrive_cur

FETCH NEXT FROM BackupLocationDrive_cur
	INTO @BackupLocationDrive

WHILE (@@FETCH_STATUS = 0)
BEGIN  --begin while

	SET @sql1 = 'dir ' + @BackupLocationDrive + '*.bak /s /b'

	INSERT INTO #files_tbl
	EXEC master..xp_cmdshell @sql1

	SET @sql1 = 'dir ' + @BackupLocationDrive + '*.trn /s /b'

	INSERT INTO #files_tbl
	EXEC master..xp_cmdshell @sql1

	FETCH NEXT FROM BackupLocationDrive_cur 
		INTO @BackupLocationDrive
END-- end while

CLOSE BackupLocationDrive_cur
DEALLOCATE BackupLocationDrive_cur

-------------------------------------------------
SET NOCOUNT OFF

SET @Commit = ISNULL(@Commit, 0) 

PRINT CHAR(13) + '-------------------------------------------------'
PRINT '* Case files marked as being on disk when they are physically missing'
PRINT 'Indicates issues with the underlying sync between DBServices status and the actual files on disk'
		+ CHAR(13)

SELECT dbsDBHFileName
	,bh.dbsDBHStartDate
	,bh.dbsDBHEndDate
	,bh.dbsDBHIsOnDiskFlag
	,bh.dbsDBHSentToNBFlag 
FROM DBServices.dbo.dbsDatabaseBackupHistory bh
LEFT OUTER JOIN #files_tbl fl
	ON UPPER(bh.dbsDBHFileName) = UPPER(fl.[filename])
WHERE ISNULL(fl.[filename],'') = ''
	AND bh.dbsDBHIsOnDiskFlag = 1

IF @Commit = 1
BEGIN
	PRINT CHAR(13) + '=> Committing...'

	UPDATE DBServices.dbo.dbsDatabaseBackupHistory
	SET dbsDBHIsOnDiskFlag = 0
	WHERE dbsDBHID IN (
		SELECT bh.dbsDBHID
		FROM DBServices.dbo.dbsDatabaseBackupHistory bh
		LEFT OUTER JOIN #files_tbl fl
			ON UPPER(bh.dbsDBHFileName) = UPPER(fl.[filename])
		WHERE ISNULL(fl.[filename],'') = ''
			AND bh.dbsDBHIsOnDiskFlag = 1
		)
END

----------------------
PRINT CHAR(13) + '-------------------------------------------------'
PRINT '* Case files marked as not being on disk when they physically exist'
PRINT 'Indicates issues with the underlying sync between DBServices status and the actual files on disk'
		+ CHAR(13)

SELECT dbsDBHFileName
	,bh.dbsDBHStartDate
	,bh.dbsDBHEndDate
	,bh.dbsDBHIsOnDiskFlag
	,bh.dbsDBHSentToNBFlag 
FROM DBServices.dbo.dbsDatabaseBackupHistory bh
INNER JOIN #files_tbl
	ON UPPER(bh.dbsDBHFileName) = UPPER([#files_tbl].[filename])
WHERE bh.dbsDBHIsOnDiskFlag = 0

IF @Commit = 1
BEGIN
	PRINT CHAR(13) + '=> Committing...'

	UPDATE DBServices.dbo.dbsDatabaseBackupHistory
	SET dbsDBHIsOnDiskFlag = 1
	FROM DBServices.dbo.dbsDatabaseBackupHistory bh
	INNER JOIN #files_tbl
		ON UPPER(bh.dbsDBHFileName) = UPPER([#files_tbl].[filename])
	WHERE bh.dbsDBHIsOnDiskFlag = 0
END

----------------------
PRINT CHAR(13) + '-------------------------------------------------'
PRINT '* Case files marked as being on disk and sent to FS backup but data missing in local tables'
PRINT 'These files are subject to purge issues'
		+ CHAR(13)

SELECT dbsDBHFileName
	,bh.dbsDBHStartDate
	,bh.dbsDBHEndDate
	,bh.dbsDBHIsOnDiskFlag
	,bh.dbsDBHSentToNBFlag 
FROM DBServices.dbo.dbsDatabaseBackupHistory bh
LEFT OUTER JOIN DBServices.dbo.dbsNetbackupManifest nbm
	ON bh.dbsDBHID = nbm.dbsDBHID
WHERE nbm.dbsNetbackupID IS NULL
	AND bh.dbsDBHIsOnDiskFlag = 1
	AND bh.dbsDBHSentToNBFlag = 1
ORDER BY dbsDBHStartDate ASC

IF @Commit = 1
BEGIN
	PRINT CHAR(13) + '=> Committing...'

	UPDATE DBServices.dbo.dbsDatabaseBackupHistory
	SET dbsDBHSentToNBFlag = 0
	WHERE dbsDBHIsOnDiskFlag = 1
		AND	dbsDBHID IN (
			SELECT bh.dbsDBHID
			FROM DBServices.dbo.dbsDatabaseBackupHistory bh
			LEFT OUTER JOIN DBServices.dbo.dbsNetbackupManifest nbm
				ON bh.dbsDBHID = nbm.dbsDBHID
			WHERE nbm.dbsNetbackupID IS NULL
				AND bh.dbsDBHIsOnDiskFlag = 1
				AND bh.dbsDBHSentToNBFlag = 1
			)
END
-------------------------------------------------

PRINT CHAR(13) + '-------------------------------------------------'

PRINT CASE @Commit
			WHEN 0 THEN 'Please verify the files have been backed up offsite before committing (i.e. @Commit = 1)'
			WHEN 1 THEN 'Actioned!'
		END

SET NOCOUNT ON
IF object_id('tempdb..#files_tbl') IS NOT NULL
	DROP TABLE #files_tbl

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_Restore_Login_Defaults]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_Restore_Login_Defaults]
   @Target_Database NVARCHAR(128) = NULL
AS

   DECLARE @Login  NVARCHAR(128)
   DECLARE @DBName NVARCHAR(128)
   DECLARE @CMD    NVARCHAR(1000)
   DECLARE @ERR    INT
   
   SET @ERR = 0
   
   PRINT 'Processing Logins in table TransferLogins.DefaultDatabases'
   PRINT ' '
   
   DECLARE    login_curs 
   CURSOR FOR
   SELECT     Login,
              DBName
   FROM       TransferLogins.DefaultDatabases 
   WHERE      DBName = ISNULL(@Target_Database, DBName)

   -- Open the cursor and fetch each login
   OPEN login_curs

   FETCH NEXT FROM login_curs INTO @Login, @DBName

   WHILE (@@fetch_status <> -1)
   BEGIN
      IF (@@fetch_status <> -2)
      BEGIN
         PRINT ' '
         PRINT 'Setting Default Database for Login ' + @Login + ' to Database ' + @DBName
         
         BEGIN TRY
			 SET @CMD = 'ALTER LOGIN [' + @Login + '] WITH DEFAULT_DATABASE = [' + @DBName + ']'
			 EXEC(@CMD)
         END TRY
         BEGIN CATCH
            PRINT '!!!!! Error: '    + ERROR_MESSAGE()    
            SET @ERR = 1     
         END CATCH
         
      END

      -- Get the next login 
      FETCH NEXT FROM login_curs INTO @Login, @DBName

   END

   -- Tidyup
   CLOSE login_curs
   DEALLOCATE login_curs

   -- Check to see if there were errors
   if (@ERR = 1)
   BEGIN
      PRINT ' '
      PRINT '---------------------------------------------------'
      PRINT 'There are Errors Reported above, Please Investigate'
      PRINT '---------------------------------------------------'
   END
   
   RETURN 0


GO
/****** Object:  StoredProcedure [dbo].[usp_RestoreDatabase]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_RestoreDatabase] 
	@databasename nvarchar(128),
	@todate datetime = null,
	@StopBeforeMark nvarchar(128) = null,
	@StopAtMark nvarchar(128) = null,
	@ForceRestore bit = 0

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_RestoreDatabase.SQL
// 
// Purpose:
//   Perform Full Backup of all databases
//
// Notes: This stored procedure is run by hand as needed.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 26/08/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Updated for LiteSpeed and LogMark restore function
//   @Date: 20/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1: Updated for Integration with Netbackup
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
//
****************************************************************************************/

BEGIN  --Begin main()
	DECLARE @DBOnly bit,
		@DbOnlydbsDBHID bigint,
		@FirstLogdbsDBHID bigint,
		@LastLogdbsDBHID bigint,
		@dbsDBHID BIGINT, 
		@dbsDatabaseName nvarchar(128), 
		@dbsDBHFileName nvarchar(255), 
		@dbsDBHIsLogFlag bit,
		@sql1 nvarchar(4000),
		@dbsDBackupProcessorID int,
		@dbsDatabaseUID uniqueidentifier,
		@StopMark nvarchar(128),
		@debug int,
		@dbsInstanceConfigValue nvarchar(255)

/*
// Set current status in heartbeat
*/

EXECUTE [usp_GetdbsInstanceConfig] 'debug'  ,@dbsInstanceConfigValue OUTPUT
	SELECT @debug = cast(@dbsInstanceConfigValue as int)

	SELECT @DBOnly = 1
 
	EXEC usp_UpdatedbsUBSMWEHeartbeat 'start usp_RestoreDatabase'

	--Get the UID for the database
	SELECT @dbsDatabaseUID = dbsDatabaseUID 
	FROM dbo.dbsDatabase
	WHERE dbsDatabaseName = @databasename

	IF @dbsDatabaseUID is null 
			BEGIN
				IF @debug = 1 PRINT 'DEBUG CODE -- Database not found...'
				Print 'Can not find information for ' + @databasename + ' with the given information. Please check that you have the proper information for the database, consider using usp_HelpRestore for more information.'
				RETURN -1
			END



	IF @todate IS NULL and @StopBeforeMark IS NULL and @StopAtMark IS NULL --Do full restore to last backup of record

		BEGIN --@todate IS NULL and @StopBeforeMark IS NULL and @StopAtMark IS NULL

			IF @debug = 1 PRINT 'DEBUG CODE -- @todate IS NULL and @StopBeforeMark IS NULL and @StopAtMark IS NULL'

						--Get the latest Full database backup ID (MAX) for this database
						SELECT @DbOnlydbsDBHID =  MAX(dbsDBH.dbsDBHID) 
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						WHERE dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 0  
						AND dbsDBH.dbsDBHParentID IS NULL
			IF @debug = 1 SELECT @DbOnlydbsDBHID as '@DbOnlydbsDBHID'

						--Get the First log ID (MIN) belonging to this database
						SELECT @FirstLogdbsDBHID = MIN(dbsDBH.dbsDBHID)
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						WHERE dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 1  
						AND dbsDBH.dbsDBHParentID = @DbOnlydbsDBHID
			IF @debug = 1 select @FirstLogdbsDBHID as '@FirstLogdbsDBHID'

						--Get the Last log ID (MAX) belonging to this database
						SELECT @LastLogdbsDBHID =  MAX(dbsDBH.dbsDBHID)
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						WHERE dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 1  
						AND dbsDBH.dbsDBHParentID = @DbOnlydbsDBHID
			IF @debug = 1 select @LastLogdbsDBHID as '@LastLogdbsDBHID'
						
		END --@todate IS NULL and @StopBeforeMark IS NULL and @StopAtMark IS NULL


	ELSE IF  (@StopBeforeMark IS NULL and @StopAtMark IS NULL) AND  @todate IS NOT NULL
		BEGIN --IF  (@StopBeforeMark IS NULL and @StopAtMark IS NULL) AND  @todate IS NOT NULL

				IF @debug = 1 PRINT 'DEBUG CODE -- @StopBeforeMark IS NULL and @StopAtMark IS NULL) AND  @todate IS NOT NULL'	

						--Get the latest Full backup ID with a start date less than specified date for this database
						SELECT @DbOnlydbsDBHID =  MAX(dbsDBH.dbsDBHID) 
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						WHERE dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 0  
						AND dbsDBH.dbsDBHParentID IS NULL
						AND dbsDBHStartDate <= @todate

						--Get the first log backup ID (MIN) with a start date less than or = to specified date for this database			
						SELECT @FirstLogdbsDBHID = MIN(dbsDBH.dbsDBHID)
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						WHERE dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 1  
						AND dbsDBH.dbsDBHParentID = @DbOnlydbsDBHID
						AND dbsDBHStartDate <= @todate

						--Get the last log backup ID (MAX) with a start date less than or = to specified date for this database			
						SELECT @LastLogdbsDBHID =  MAX(dbsDBH.dbsDBHID)
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						WHERE dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 1  
						AND dbsDBH.dbsDBHParentID = @DbOnlydbsDBHID
						AND dbsDBHStartDate <= @todate
						
		END --IF  (@StopBeforeMark IS NULL and @StopAtMark IS NULL) AND  @todate IS NOT NULL



	ELSE IF  (@StopBeforeMark IS NOT NULL OR @StopAtMark IS NOT NULL) AND  @todate IS NULL
	
		BEGIN --IF  (@StopBeforeMark IS NOT NULL OR @StopAtMark IS NOT NULL) AND  @todate IS NULL

				IF @debug = 1 PRINT 'DEBUG CODE -- IF  (@StopBeforeMark IS NOT NULL OR @StopAtMark IS NOT NULL) AND  @todate IS NULL'

						IF @StopBeforeMark IS NOT NULL 
							BEGIN --IF @StopBeforeMark IS NOT NULL 
								SET  @StopMark = @StopBeforeMark
							END --IF @StopBeforeMark IS NOT NULL 
						ELSE IF @StopAtMark IS NOT NULL 
							BEGIN --IF @StopAtMark IS NOT NULL 
								SET @StopMark = @StopAtMark
							END --IF @StopAtMark IS NOT NULL 

						--Get the latest Full backup ID (MAX) with a start date less than or = to the logmarkhistory.mark_time for the  specified logmark and database
						SELECT @DbOnlydbsDBHID =  MAX(dbsDBH.dbsDBHID) 
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						JOIN msdb.dbo.logmarkhistory lmh
						ON	dbsDBH.dbsDBHStartDate <= lmh.mark_time
						AND lmh.database_name = @databasename
						AND dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 0 
						AND dbsDBH.dbsDBHParentID IS NULL
						WHERE lmh.mark_name = @StopMark

						--Get the first Log backup ID (MIN) with a start date less than or = to the logmarkhistory.mark_time for the  specified logmark and database
						SELECT @FirstLogdbsDBHID = MIN(dbsDBH.dbsDBHID)
						FROM dbo.dbsDatabaseBackupHistory dbsDBH
						JOIN msdb.dbo.logmarkhistory lmh
						ON	dbsDBH.dbsDBHStartDate <= lmh.mark_time
						AND lmh.database_name = @databasename
						AND dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 1 
						AND dbsDBH.dbsDBHParentID = @DbOnlydbsDBHID
						WHERE lmh.mark_name = @StopMark

						--Get the last Log backup ID (MIN) with a start date less than or = to the logmarkhistory.mark_time for the  specified logmark and database
						SELECT @LastLogdbsDBHID =  MAX(dbsDBH.dbsDBHID)
						FROM dbo.dbsDatabaseBackupHistory dbsDBH 
						where dbsDatabaseUID = @dbsDatabaseUID
						AND dbsDBH.dbsDBHIsLogFlag = 1  
						AND dbsDBH.dbsDBHParentID = @DbOnlydbsDBHID
						AND dbsDBH.dbsDBHFileName in 
						--There may be better ways to do this but here is where the magic comes in to play
						--We need to get the last log that holds this logmark and the only way to do that is 
						--with the lsn information held in the msdb backup tables. The file name is the only 
						--key we have between the DBServices information and the system information.
						--This will be changed to hold all information  in the DBServices database
						--and not need to go to the system tables, at a later time.
						( SELECT     bmf.physical_device_name
							FROM	msdb.dbo.backupmediafamily bmf 
							INNER JOIN msdb.dbo.backupset bs 
								ON bmf.media_set_id = bs.media_set_id 
							INNER JOIN msdb.dbo.logmarkhistory lmh 
								ON bs.first_lsn <= lmh.lsn AND bs.last_lsn >= lmh.lsn
							WHERE     (lmh.mark_name = @StopBeforeMark))

					
		END --IF  (@StopBeforeMark IS NOT NULL OR @StopAtMark IS NOT NULL) AND  @todate IS NULL

	ELSE 
				
			BEGIN
				IF @debug = 1 PRINT 'DEBUG CODE -- Should never get to this point...'
				Print 'Can not find information for ' + @databasename + ' with the given information. Please check that you have the proper information for the database, consider using usp_HelpRestore for more information.'
				RETURN -1
			END

	IF @FirstLogdbsDBHID IS NOT NULL and @dbsDatabaseUID is not null
		BEGIN
			SELECT @DBOnly = 0
		END


	--Now, set the flag indicating this database is in restore mode.
	UPDATE dbo.dbsDatabaseBackup
	SET dbsDBIsInRestoreProcess = 1
	WHERE dbsDatabaseUID in (SELECT dbsDatabaseUID FROM dbo.dbsDatabase WHERE dbsDatabaseName = @databasename )

	IF @debug = 1 
		BEGIN 
		--todo  change location of file name depending on new switch in the backuphistory, if it is set to be sent to Netbackup, get file location from Netbackup tables.	
		Select dbsDBH.dbsDBHID as 'FileExists',  dbsDBH.dbsDBHIsOnDiskFlag 
					from  dbo.dbsDatabase dbsD
					join dbo.dbsDatabaseBackup dbsDB
					on dbsD.dbsDatabaseUID = dbsDB.dbsDatabaseUID
					join dbo.dbsDatabaseBackupHistory dbsDBH
					on dbsDB.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
 					LEFT OUTER JOIN dbo.dbsNetbackupManifest NM
 					on dbsDBH.dbsDBHID = NM.dbsDBHID
 					where  ( dbsD.dbsDatabaseName = @databasename and  dbsDBH.dbsDBHID = @DbOnlydbsDBHID )
 					OR ( dbsD.dbsDatabaseName = @databasename and  dbsDBHIsLogFlag = 1 and dbsDBH.dbsDBHID >= @FirstLogdbsDBHID AND dbsDBH.dbsDBHID <= @LastLogdbsDBHID )
		END			

	IF NOT EXISTS (Select dbsDBH.dbsDBHID from  dbo.dbsDatabase dbsD
			join dbo.dbsDatabaseBackup dbsDB
			on dbsD.dbsDatabaseUID = dbsDB.dbsDatabaseUID
			join dbo.dbsDatabaseBackupHistory dbsDBH
			on dbsDB.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
 			LEFT OUTER JOIN dbo.dbsNetbackupManifest NM
 			on dbsDBH.dbsDBHID = NM.dbsDBHID
 			where  ( dbsD.dbsDatabaseName = @databasename and  dbsDBH.dbsDBHID = @DbOnlydbsDBHID and dbsDBH.dbsDBHIsOnDiskFlag = 1)
 			OR ( dbsD.dbsDatabaseName = @databasename and  dbsDBHIsLogFlag = 1 and dbsDBH.dbsDBHID >= @FirstLogdbsDBHID AND dbsDBH.dbsDBHID <= @LastLogdbsDBHID and dbsDBH.dbsDBHIsOnDiskFlag = 1)
			)

	BEGIN
			IF @ForceRestore = 0 
				BEGIN
					PRINT 'There are files needed by this restore where the data indicates they are not on disk, please run usp_HelpRestoreDatabase to get a list of files needed for the restore.'
					RETURN -1
				END
	END

		DECLARE dbsDatabase_cur CURSOR FOR
			select dbsDBH.dbsDBHID, 
				dbsD.dbsDatabaseName,
				CASE
					WHEN dbsDBH.dbsDBHSentToNBFlag = 1 THEN NM.dbsNetbackupManifestLocation
					WHEN dbsDBH.dbsDBHSentToNBFlag = 0 OR dbsDBH.dbsDBHSentToNBFlag IS NULL THEN dbsDBH.dbsDBHFileName
					
				END as 'dbsDBHFileName', 
				dbsDBH.dbsDBHIsLogFlag, 
				dbsDBH.dbsDBackupProcessorID
			from dbo.dbsDatabase dbsD
			join dbo.dbsDatabaseBackup dbsDB
			on dbsD.dbsDatabaseUID = dbsDB.dbsDatabaseUID
			join dbo.dbsDatabaseBackupHistory dbsDBH
			on dbsDB.dbsDatabaseUID = dbsDBH.dbsDatabaseUID
 			LEFT OUTER JOIN dbo.dbsNetbackupManifest NM
 			on dbsDBH.dbsDBHID = NM.dbsDBHID
 			where  ( dbsD.dbsDatabaseName = @databasename and  dbsDBH.dbsDBHID = @DbOnlydbsDBHID )
 			OR ( dbsD.dbsDatabaseName = @databasename and  dbsDBHIsLogFlag = 1 and dbsDBH.dbsDBHID >= @FirstLogdbsDBHID AND dbsDBH.dbsDBHID <= @LastLogdbsDBHID)
			order by  dbsDBH.dbsDBHID



		OPEN dbsDatabase_cur
	
		FETCH NEXT FROM dbsDatabase_cur INTO @dbsDBHID, @dbsDatabaseName, @dbsDBHFileName, @dbsDBHIsLogFlag, @dbsDBackupProcessorID 
	
	
	
		WHILE (@@FETCH_STATUS = 0)
			BEGIN  --begin while
			
--select @dbsDBHID, @dbsDatabaseName, @dbsDBHFileName, @dbsDBHIsLogFlag 
				IF 	@dbsDBHID = @DbOnlydbsDBHID  --Recover full database, if @DBOnly = 0 then with no recovery else with recovery
					BEGIN
						IF @dbsDBackupProcessorID = 1
							BEGIN
								EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
								EXEC [DBServices].[dbo].[usp_RestoreDatabase_Full_Base] @dbsDatabaseName = @databasename, @dbsDBHFileName = @dbsDBHFileName, @todate = @todate, @StopBeforeMark = @StopBeforeMark, @StopAtMark = @StopAtMark, @WithRecovery = @DBOnly --@WithRecovery
							END
						ELSE IF @dbsDBackupProcessorID = 2
							BEGIN
								EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
								EXEC [DBServices].[dbo].[usp_RestoreDatabase_Full_LiteSpeed] @dbsDatabaseName = @dbsDatabaseName, @dbsDBHFileName = @dbsDBHFileName, @todate = @todate, @StopBeforeMark = @StopBeforeMark, @StopAtMark = @StopAtMark, @WithRecovery = @DBOnly --@WithRecovery
							END

					END
				ELSE
					IF	@dbsDBHID = @LastLogdbsDBHID
	
						BEGIN
							IF @debug = 1 PRINT 'WithRestore'
							IF @dbsDBackupProcessorID = 1
								BEGIN
									EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
									EXEC [DBServices].[dbo].[usp_RestoreDatabase_Log_Base] @dbsDatabaseName = @databasename , @dbsDBHFileName = @dbsDBHFileName, @todate = @todate, @StopBeforeMark = @StopBeforeMark, @StopAtMark = @StopAtMark, @WithRecovery = 1 --@WithRecovery
								END
							ELSE IF @dbsDBackupProcessorID = 2
								BEGIN
									EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
									EXEC [DBServices].[dbo].[usp_RestoreDatabase_Log_LiteSpeed] @dbsDatabaseName = @dbsDatabaseName, @dbsDBHFileName = @dbsDBHFileName, @todate = @todate, @StopBeforeMark = @StopBeforeMark, @StopAtMark = @StopAtMark, @WithRecovery = 1 --@WithRecovery
								END

						END
					ELSE
					
						BEGIN
							IF @debug = 1 PRINT 'WithNoRestore'
							IF @dbsDBackupProcessorID = 1
								BEGIN
									EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
									EXEC [DBServices].[dbo].[usp_RestoreDatabase_Log_Base] @dbsDatabaseName = @databasename , @dbsDBHFileName = @dbsDBHFileName, @todate = @todate, @StopBeforeMark = @StopBeforeMark, @StopAtMark = @StopAtMark, @WithRecovery = 0 --@WithRecovery
								END
							ELSE IF @dbsDBackupProcessorID = 2
								BEGIN
									EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
									EXEC [DBServices].[dbo].[usp_RestoreDatabase_Log_LiteSpeed] @dbsDatabaseName = @dbsDatabaseName, @dbsDBHFileName = @dbsDBHFileName, @todate = @todate, @StopBeforeMark = @StopBeforeMark, @StopAtMark = @StopAtMark, @WithRecovery = 0 --@WithRecovery
								END

						END


				
--				EXEC DBServices.dbo.usp_ShutDownDBUsers @DBName = @dbsDatabaseName --, @postshutdowncmd = @sql1
				


					FETCH NEXT FROM dbsDatabase_cur INTO @dbsDBHID, @dbsDatabaseName, @dbsDBHFileName, @dbsDBHIsLogFlag, @dbsDBackupProcessorID 
				
			END-- end while
	
		CLOSE dbsDatabase_cur
		DEALLOCATE dbsDatabase_cur



UPDATE dbo.dbsDatabaseBackup
SET dbsDBIsInRestoreProcess = 0
WHERE dbsDatabaseUID in (SELECT dbsDatabaseUID FROM dbo.dbsDatabase WHERE dbsDatabaseName = @databasename )





END --End main()



GO
/****** Object:  StoredProcedure [dbo].[usp_RestoreDatabase_Full_Base]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_RestoreDatabase_Full_Base] 
	@dbsDatabaseName nvarchar(128), 
	@dbsDBHFileName nvarchar(255),
	@todate datetime = null,
	@StopBeforeMark nvarchar(128) = null,
	@StopAtMark nvarchar(128) = null,
	@WithRecovery int = 0 --Force the with no recovery unless told otherwise

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_RestoreDatabase_Full_Base.SQL
// 
// Purpose:
//   Perform Full restore of named database using Native syntax
//
// Notes: This stored procedure is called from main usp_RestoreDatabase. 
//
// History:
//
//   @Version: Beta General
//   @Author: Kevin Wagner 
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//
****************************************************************************************/


BEGIN  --Begin main()

	DECLARE @sql1 nvarchar(4000)


select 'usp_RestoreDatabase_Full_Base'




	SET @sql1 = 'RESTORE DATABASE ['
	+ @dbsDatabaseName
	+'] FROM  DISK = N'''
	+ @dbsDBHFileName
	
	IF @WithRecovery = 0
		BEGIN
			SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  NORECOVERY'
		END
	ELSE
		BEGIN
			SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  RECOVERY'
		END	
	
	EXEC (@sql1)


END --End main()



GO
/****** Object:  StoredProcedure [dbo].[usp_RestoreDatabase_Full_LiteSpeed]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_RestoreDatabase_Full_LiteSpeed] 
	@dbsDatabaseName nvarchar(128), 
	@dbsDBHFileName nvarchar(255),
	@todate datetime = null,
	@StopBeforeMark nvarchar(128) = null,
	@StopAtMark nvarchar(128) = null,
	@WithRecovery int = 0 --Force the with no recovery unless told otherwise

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_BackupDatabase_FULL_LiteSpeed.SQL
// 
// Purpose:
//   Perform Full restore of named database using LiteSpeed syntax
//
// Notes: This stored procedure is called from main usp_RestoreDatabase. 
//
// History:
//
//   @Version: Beta General
//   @Author: Kevin Wagner 
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//
****************************************************************************************/


BEGIN  --Begin main()
-- =============================================
-- Execute SQL LiteSpeed Full Database Backup 
-- =============================================
select 'usp_RestoreDatabase_Full_LiteSpeed'



IF @WithRecovery = 1 
	BEGIN

		EXEC master.dbo.xp_restore_database    
		      	  @database = @dbsDatabaseName
		    	, @FileName = @dbsDBHFileName 
			, @with='RECOVERY' 

	END
ELSE
	BEGIN

		EXEC master.dbo.xp_restore_database    
		      	  @database = @dbsDatabaseName
		    	, @FileName = @dbsDBHFileName 
			, @with='NORECOVERY' 

	END




END --End main()



GO
/****** Object:  StoredProcedure [dbo].[usp_RestoreDatabase_Log_Base]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_RestoreDatabase_Log_Base] 
	@dbsDatabaseName nvarchar(128), 
	@dbsDBHFileName nvarchar(255),
	@todate datetime = null,
	@StopBeforeMark nvarchar(128) = null,
	@StopAtMark nvarchar(128) = null,
	@WithRecovery int = 0 --Force the with no recovery unless told otherwise

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_RestoreDatabase_Log_Base.SQL
// 
// Purpose:
//   Perform Full restore of named database using LiteSpeed syntax
//
// Notes: This stored procedure is called from main usp_RestoreDatabase. 
//
// History:
//
//   @Version: Beta General
//   @Author: Kevin Wagner 
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//
****************************************************************************************/


BEGIN  --Begin main()
--select 'usp_RestoreDatabase_Log_Base - Not Implimented Yet', @dbsDatabaseName, 
--	@dbsDBHFileName,
--	@todate,
--	@StopBeforeMark,
--	@StopAtMark,
--	@WithRecovery

	DECLARE @sql1 nvarchar(4000)

	set @sql1 = 'RESTORE LOG ['
	+ @dbsDatabaseName
	+'] FROM  DISK = N'''
	+ @dbsDBHFileName
	
	IF @WithRecovery = 0

		BEGIN
			SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  NORECOVERY'
		END

	ELSE IF @todate IS NOT NULL

		BEGIN
			--SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  RECOVERY'
			SET @sql1 = @sql1 + ''' WITH RECOVERY, STOPAT = ''' + convert(varchar(255), @todate) + ''''
		END	
	
	ELSE IF @StopBeforeMark  IS NOT NULL

		BEGIN
			--SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  RECOVERY'
			SET @sql1 = @sql1 + ''' WITH RECOVERY, STOPBEFOREMARK = ''' + @StopBeforeMark + ''''
		END	

	ELSE IF @StopAtMark   IS NOT NULL

		BEGIN
			--SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  RECOVERY'
			SET @sql1 = @sql1 + ''' WITH RECOVERY, STOPATMARK = ''' + @StopAtMark + ''''
		END	

	ELSE --Full database restore

		BEGIN
			SET @sql1 = @sql1 + ''' WITH FILE = 1,  NOUNLOAD ,  STATS = 10,  RECOVERY'
		END	
	
	EXEC (@sql1)

/*

	set @sql1 = 'RESTORE LOG ['
	+ @dbsDatabaseName
	+'] FROM  DISK = N'''
	+ @dbsDBHFileName
	+ ''' WITH RECOVERY, STOPAT = ''' + convert(varchar(255), @todate) + ''''

	EXEC @sql1
*/
END --End main()



GO
/****** Object:  StoredProcedure [dbo].[usp_RestoreDatabase_Log_LiteSpeed]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_RestoreDatabase_Log_LiteSpeed] 
	@dbsDatabaseName nvarchar(128), 
	@dbsDBHFileName nvarchar(255),
	@todate nvarchar(50) = null,
	@StopBeforeMark nvarchar(128) = null,
	@StopAtMark nvarchar(128) = null,
	@WithRecovery int = 0 --Force the with no recovery unless told otherwise

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_RestoreDatabase_Full_LiteSpeed.SQL
// 
// Purpose:
//   Perform Full restore of named database using LiteSpeed syntax
//
// Notes: This stored procedure is called from main usp_RestoreDatabase. 
//
// History:
//
//   @Version: Beta General
//   @Author: Kevin Wagner 
//   @Date: 08/26/2004
//   @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//
****************************************************************************************/


BEGIN  --Begin main()
-- =============================================
-- Execute SQL LiteSpeed Full Database Backup 
-- =============================================
DECLARE @sql NVARCHAR(4000)

select 'usp_RestoreDatabase_Log_LiteSpeed', @dbsDBHFileName

IF @WithRecovery = 0 
	BEGIN
		EXEC master.dbo.xp_restore_log 
			 @database =   @dbsDatabaseName
			, @FileName = @dbsDBHFileName
			, @with=  'NORECOVERY'
	END
ELSE IF @WithRecovery = 1

	IF @todate IS NOT NULL
		BEGIN
			SET @sql = 'STOPAT = "' + @todate + '"'
			EXEC master.dbo.xp_restore_log 
				 @database =   @dbsDatabaseName
				, @FileName = @dbsDBHFileName
				, @with=  'RECOVERY'
				, @with = @sql

		END

	ELSE IF  @StopBeforeMark IS NOT NULL
		BEGIN
			SET @sql = 'STOPBEFOREMARK = "' + @StopBeforeMark + '"'
			EXEC master.dbo.xp_restore_log 
				 @database =   @dbsDatabaseName
				, @FileName = @dbsDBHFileName
				, @with=  'RECOVERY'
				, @with = @sql
			
		END
		
	ELSE IF  @StopAtMark IS NOT NULL
		BEGIN
			SET @sql = 'STOPATMARK = "' + @StopAtMark + '"'
			EXEC master.dbo.xp_restore_log 
				@database = @dbsDatabaseName
				, @FileName = @dbsDBHFileName
				, @with=  'RECOVERY'
				, @with = @sql
			
		END		
	ELSE
		BEGIN
			EXEC master.dbo.xp_restore_log 
				 @database =   @dbsDatabaseName
				, @FileName = @dbsDBHFileName
				, @with=  'RECOVERY'
		END




















END --End main()



GO
/****** Object:  StoredProcedure [dbo].[usp_Revoke_Builtin_Admin_login]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

create proc [dbo].[usp_Revoke_Builtin_Admin_login]
as
/*
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//	 @Date: 23/06/2015 @Author: Chris Basson @Version: 6.0.0.33 @Action: MS AO - @@SERVERNAME bug workaround
*/

SET DATEFORMAT ymd
declare @cluster_user nvarchar(50),
	@sql_user nvarchar(50),
	@cmd nvarchar(100),
	@DBName nvarchar(60)

select	@cluster_user='UBSW\svc_nldnc'+substring(CONVERT(sysname, SERVERPROPERTY('ServerName')),6,3),
	@sql_user ='UBSW\svc_nldnc'+substring(CONVERT(sysname, SERVERPROPERTY('ServerName')),6,3)+'_sql'



-- create logins for NT Authority, DBServices, cluster user and sql user
EXEC sp_grantlogin 'NT Authority\System'
EXEC sp_grantlogin @cluster_user
EXEC sp_grantlogin @sql_user
EXEC sp_grantlogin 'UBSW\Admin - Database Services (Global)'

-- grant sa rights
EXEC sp_addsrvrolemember 'NT Authority\System', 'sysadmin'
EXEC sp_addsrvrolemember @cluster_user, 'sysadmin'
EXEC sp_addsrvrolemember @sql_user, 'sysadmin'
EXEC sp_addsrvrolemember 'UBSW\Admin - Database Services (Global)', 'sysadmin'


--grant db access for DBServices

select @cmd = '
USE ?
EXEC sp_grantdbaccess ''UBSW\Admin - Database Services (Global)'''

exec dbo.sp_MSforeachdb @command1=@cmd

select @cmd = '
USE ?
EXEC sp_addrolemember ''db_owner'', ''UBSW\Admin - Database Services (Global)'''

exec dbo.sp_MSforeachdb @command1=@cmd


EXEC sp_revokelogin [BUILTIN\Administrators]


GO
/****** Object:  StoredProcedure [dbo].[usp_RunFilebackup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_RunFilebackup] 
AS
/****************************************************************************************
// @File: usp_RunFilebackup_.SQL
// @Version: 6.0.0.22
// 
// Purpose:
//   Perform FS backups to offsite storage
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase. 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 14/10/2004 @Author: Kevin Wagner @Version: Beta General @Action: Created
//   @Date: 17/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 04/05/2006 @Author: Rakesh Bist  @Version: 2.0 @Action: Added error logging to raise an alert on MOM.
//   @Date: 17/10/2006 @Author: Kevin Wagner @Version: 2.0.6 @Action: Updated to accomidate a copy or move of the file for log shipping (issue#26)
//   @Date: 27/02/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Updated for issue #
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//   @Date: 16/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Rerunning manifest changes. 
//   @Date: 16/10/2008 @Author: Steve Trogub @Version: UBSMWE 4.0.1 @Action: Added segregation feature to allow users configure placing full backups at the end of netbackup
//   @Date: 03/10/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.3 @Action: Fix for files not purging after they were sent to tape
//   @Date: 03/10/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.8 @Action: Check for CVBACKUP.CMD exit codes indicating success
//   @Date: 17/03/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9.1 @Action: Bugfix - single hosts treated as clusters, clusters as single hosts!
//   @Date: 16/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//   @Date: 28/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.5 @Action: TRRv3 Beta
//   @Date: 01/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 12/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 28/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 Beta
//   @Date: 08/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.14 @Action: TRRv3 Beta
//   @Date: 26/01/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.22 @Action: TRR-118 - Filebackup Job fails with Netbackup

****************************************************************************************/

BEGIN  --Begin main()

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@sql1 nvarchar(4000)
	,@sql2 nvarchar(4000)
	,@bak_type nvarchar(3)
	,@FSbackupCommand nvarchar(2000)
	,@NB_Class nvarchar(255)
	,@NB_BPBackup_ExecutableLocation nvarchar(255)
	,@CV_ExecutableLocation nvarchar(255)
	,@NB_Enabled bit
	,@CV_Enabled bit
	,@RC int
	,@IsClustered bit
	,@dbsInstanceFileLocation nvarchar(255)
	,@ActiveComputerName nvarchar(255)
	,@dbsInstanceFileLocation_FIX nvarchar(255) --Fix for $ in path name
	,@OkToContinueFlag int --Fix for DR situation on SMB...
	,@dbsNetbackupRequestStartDate datetime
	,@dbsNetbackupRequestEndDate datetime
	,@dbsFSbackupFileListName nvarchar(255)
	,@dbsFSbackupLogName nvarchar(255)
	,@dbsNetbackupID bigint
	,@dbsNetbackupIDtemp varchar(10)
	,@dbsNetbackupIDtext nchar(10)
	,@dbsDBHID_MAX bigint
	,@dbsDBHID bigint
	,@dbsDBHFileName nvarchar(255)
	,@NB_ManifestDirectory nvarchar(255)
	,@dbsNetbackupExitStatus nvarchar(512)
	,@message nvarchar(384)
	,@exists int
	,@dbsDatabaseUID uniqueidentifier
	,@dbsDBIsInFullBackupProcess bit
	,@dbsDBIsInLogBackupProcess  bit
	,@NetbackupErrorLimit tinyint
	,@NetbackupErrorCount tinyint
	,@NetbackupErrorRerunDelayMinutes int
	,@NetbackupErrorRerunDelayMinutes_Run int
	,@Error int
	,@dbsDBHIsLogFlag int
	,@Command nvarchar(50)
	,@WritelineText nvarchar(2000)
	,@DelayLength char(8) --'00:00:00'
	,@DelayLengthHr int
	,@DelayLengthMin int
	,@dbsNetbackupRunNumber int
	,@NetbackupFileRunInfo nvarchar(6)
	,@HelpMsg nvarchar(255) 
	,@Segregate bit
	,@InstanceCommand nvarchar(128)
	,@ClusterCommand nvarchar(128)
	,@dbsBackupProcessor tinyint
	,@CV_FSIncSysDB bit
	,@ForceSuccess bit
	,@CVFSBackupSet varchar(128)
	,@CVFSSubclient varchar(128)
	,@CVClient nvarchar(128)
	,@CVInstance nvarchar(128)
	,@i smallint
	,@RetryTime datetime

DECLARE @DB_Exclusion_List TABLE (dbsDatabaseUID uniqueidentifier)

----------------------------------------------------------
-- Init output vars

SELECT @Segregate = 0
	,@NB_Class=''
	,@NetbackupErrorCount=0
	,@NetbackupErrorLimit=0
	,@NetbackupErrorRerunDelayMinutes=0
	,@Error = 0
	,@OkToContinueFlag = 0 --Not ok to continue by default
	,@CV_FSIncSysDB = 0 
	,@dbsNetbackupRequestStartDate = getdate()
	,@ForceSuccess = 0
	,@CVFSBackupSet = null
	,@CVFSSubclient = null

----------------------------------------------------------
-- Determine config 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'SEGREGATE_MANIFEST', @Segregate OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation',  @dbsInstanceFileLocation OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'ActiveComputerName', @ActiveComputerName OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_BPBackup_ExecutableLocation', @NB_BPBackup_ExecutableLocation OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_ExecutableLocation', @CV_ExecutableLocation OUTPUT
				
----------------------------------------------------------
-- Verify config

IF NOT (@NB_Enabled = 1 OR @CV_Enabled = 1)
BEGIN
	PRINT 'UBSMWE: usp_RunFilebackup: Neither CommVault File System Backups nor Netbackup have been configured on this host...usp_RunFilebackup is exiting.'
	RETURN 1 -- Exit with failure 
END -------------------------
ELSE
IF @NB_Enabled = 1 AND @CV_Enabled = 0
BEGIN
	-- Netbackup configured
	SET @NB_Class = 'NB_Class_' + @ActiveComputerName
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] @NB_Class, @NB_Class OUTPUT

	IF ISNULL(@NB_Class,'') = '' 
	BEGIN
		--ERROR: Netbackup node class cannot be found 
		SET @message = 'UBSMWE: usp_RunFilebackup: A Netbackup class for node ' 
			+ @ActiveComputerName
			+ ' has been defined. Filebackup operations will not continue on this node. '

		EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ',@message, 1 --actually raise an error to cause the job to fail...
		
		RETURN 1 -- Exit with failure
	END
END -------------------------

----------------------------------------------------------
-- Determine Net/CV FS backup details

EXEC [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
										,@CVInstance = @CVInstance OUTPUT 
										
 -- Remove client name from CV Instance name for BRAT cmd
SET @CVInstance = LOWER(ISNULL(RIGHT(@CVInstance,LEN(@CVInstance) - CHARINDEX(N'\',@CVInstance)), @CVClient))
IF @CVInstance = @CVClient
    SET @InstanceCommand = ''
ELSE
	SET @InstanceCommand = ' -i ' + @CVInstance

SET @IsClustered=CAST(SERVERPROPERTY('IsClustered') as bit)
IF @IsClustered=1 
	SET @ClusterCommand = ' -c ' + @CVClient
ELSE
    SET @ClusterCommand = ' -c ' + 'STANDALONE'	-- skip cvbackup.cmd cluster check - as unreliable

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorCount',  @NetbackupErrorCount OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorLimit',  @NetbackupErrorLimit OUTPUT 
IF @RC <> 0 
BEGIN
    EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'NetbackupErrorLimit',  3  -- reset to default
	SET @NetbackupErrorLimit = 3
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorRerunDelayMinutes',  @NetbackupErrorRerunDelayMinutes OUTPUT 
IF @RC<> 0 
BEGIN
    EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'NetbackupErrorRerunDelayMinutes',  3 -- reset to default
    SET @NetbackupErrorRerunDelayMinutes = 3
END
        
IF @NetbackupErrorCount IS NULL
	SET @NetbackupErrorCount = 0

SET @NetbackupFileRunInfo = 'Run_' + CAST(@NetbackupErrorCount as nvarchar(2)) 

		
----------------------------------------------------------
-- Determine delay time

--Can not set more than a 24 hr delay...
IF @NetbackupErrorRerunDelayMinutes > 1439
	SET @NetbackupErrorRerunDelayMinutes = 1439

SET @DelayLengthHr = @NetbackupErrorRerunDelayMinutes / 60
SET @DelayLengthMin = @NetbackupErrorRerunDelayMinutes - (@DelayLengthHr * 60)

IF  LEN(@DelayLengthHr) = 0 AND LEN(@DelayLengthMin) = 0
    SET @DelayLength = '00:00' 
ELSE
IF  LEN(@DelayLengthHr) = 0 AND LEN(@DelayLengthMin) = 1
    SET @DelayLength = '00:' + CAST(@DelayLengthMin as char(1))
ELSE
IF  LEN(@DelayLengthHr) = 0 AND LEN(@DelayLengthMin) = 2
    SET @DelayLength = CAST(@DelayLengthHr as char(2)) + ':00'
ELSE
IF  LEN(@DelayLengthHr) = 1 AND LEN(@DelayLengthMin) = 0
    SET @DelayLength = '0' + CAST(@DelayLengthHr as char(1)) + ':00'
ELSE
IF  LEN(@DelayLengthHr) = 1 AND LEN(@DelayLengthMin) = 1
    SET @DelayLength = '0' + CAST(@DelayLengthHr as char(1)) + ':0' + CAST(@DelayLengthMin as char(1))
ELSE
IF  LEN(@DelayLengthHr) = 1 AND LEN(@DelayLengthMin) = 2
    SET @DelayLength = '0' + CAST(@DelayLengthHr as char(1)) + ':' + CAST(@DelayLengthMin as char(2))
ELSE
IF  LEN(@DelayLengthHr) = 2 AND LEN(@DelayLengthMin) = 0
    SET @DelayLength = CAST(@DelayLengthHr as char(2)) + ':00'
ELSE
IF  LEN(@DelayLengthHr) = 2 AND LEN(@DelayLengthMin) = 1
    SET @DelayLength = CAST(@DelayLengthHr as char(2)) + ':0' + CAST(@DelayLengthMin as char(1))
ELSE
IF  LEN(@DelayLengthHr) = 2 AND LEN(@DelayLengthMin) = 2
    SET @DelayLength = CAST(@DelayLengthHr as char(2)) + ':' + CAST(@DelayLengthMin as char(2))

----------------------------------------------------------
-- Determine DB FS backup Exclusions

-- CV - exclude local system database dumps             
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_FSIncSysDB', @CV_FSIncSysDB OUTPUT 
IF @CV_FSIncSysDB = 0 
BEGIN
	-- Exclude System DBs
	INSERT INTO @DB_Exclusion_List
	SELECT DISTINCT dbsDatabaseUID
	FROM [DBServices].[dbo].[dbsDatabase] db
	WHERE dbsDatabaseIsActive = 1
		AND dbsDatabaseIsSystemObjectFlag = 1
END

-- Determine User FS exclusions
INSERT INTO @DB_Exclusion_List
SELECT DISTINCT dbsDatabaseUID
FROM [DBServices].[dbo].dbsDatabaseException dbe
WHERE dbsDatabaseExceptionType = 'filesystem'
	AND dbsExceptionActive = 1

----------------------------------------------------------

--See if there is any work to do, if not, just exit.
IF NOT EXISTS (SELECT 1
        FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbh
        INNER JOIN [DBServices].[dbo].dbsDatabaseBackup dbb
			ON dbh.dbsDatabaseUID = dbb.dbsDatabaseUID
        WHERE ( ((dbh.dbsDBHSentToNBFlag = 0 OR dbh.dbsDBHSentToNBFlag IS NULL)--dbh.dbsDBHID > @dbsDBHID_MAX
				AND dbh.dbsDBHIsOnDiskFlag = 1  --Fix for error when Netbackup runs and file is still being backed up.Also need to fix in the sproc calling the Netbackup run.
				AND dbb.dbsDBIsInFullBackupProcess = 0
				AND dbb.dbsDBIsInLogBackupProcess = 0
				AND (dbb.dbsDBExternalBackupFlag = 0 OR dbb.dbsDBBackupType ='LS_Primary'))
			OR @NetbackupErrorCount > 0 )
			AND dbh.dbsDatabaseUID NOT IN (SELECT dbsDatabaseUID FROM @DB_Exclusion_List))
BEGIN
	SET @message = 'UBSMWE: usp_RunFilebackup: Nothing to backup - exiting'
	PRINT @message

	SET @dbsNetbackupExitStatus = @message
	SET @RC = 0

	GOTO UPDATE_EXIT_STATUS
END
ELSE
BEGIN -- CV FS / Netbackup DO
	--seed the max value to get the list of files to include in this manifest 

	SELECT @dbsDBHID_MAX = ISNULL(MAX(dbsDBHID), 0)
	FROM [DBServices].[dbo].dbsNetbackupManifest
	
	IF @dbsDBHID_MAX = 0 -- Manifest table is empty, reset @NetbackupErrorCount
    BEGIN
		SET @NetbackupErrorCount = 0
		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'NetbackupErrorCount', '0'
		SET @NetbackupFileRunInfo = 'Run_0' 
    END
    
	--If we dont have an error then create new entry in dbsNetbackup                                                
	IF @NetbackupErrorCount = 0 
	BEGIN
		--Add the header information to the dbsNetbackup table for this run
		INSERT INTO [DBServices].[dbo].[dbsNetbackup]([dbsNetbackupRequestStartDate])
		VALUES (@dbsNetbackupRequestStartDate)

		--OK, now we need the ID of the row just inserted...                        
		SET @dbsNetbackupID = IDENT_CURRENT('[DBServices].[dbo].[dbsNetbackup]')
		SET @dbsNetbackupIDtemp = CONVERT(varchar(10), @dbsNetbackupID)
	END
	ELSE
	BEGIN
		SELECT @dbsNetbackupID = MAX(dbsNetbackupID)
		FROM [DBServices].[dbo].[dbsNetbackup]

		SET @dbsNetbackupIDtemp = CONVERT(varchar(10), @dbsNetbackupID)
	END

	IF @dbsNetbackupID IS NULL
	BEGIN
		SET @message = 'UBSMWE: usp_RunFilebackup: Unhandled Exception: @dbsNetbackupID IS NULL; verify then run usp_Help_FileBackup/usp_MarkFilebackupFixed. Filebackup operations will not continue on this node.'
		EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ',@message, 1 --actually raise an error to cause the job to fail...
		RETURN 1 -- Exit with failure
	END

	--Create consistant file and directory length for readability and sorting.
	SELECT @dbsNetbackupIDtext = CASE
			WHEN LEN(@dbsNetbackupIDtemp) = 1 THEN '000000000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 2 THEN '00000000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 3 THEN '0000000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 4 THEN '000000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 5 THEN '00000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 6 THEN '0000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 7 THEN '000' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 8 THEN '00' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 9 THEN '0' + @dbsNetbackupIDtemp
			WHEN LEN(@dbsNetbackupIDtemp) = 10 THEN  @dbsNetbackupIDtemp
		END

	----------------------------------------------------------
	--Determine the @NB_ManifestDirectory information

	IF RIGHT(@dbsInstanceFileLocation,1) <> '\'
		SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

	IF @CV_Enabled = 1
	BEGIN
		SET @NB_ManifestDirectory = @dbsInstanceFileLocation + 'CVbackup'
		SET @dbsFSbackupFileListName = @NB_ManifestDirectory
				+ '\CVManifest_' + @dbsNetbackupIDtext + '_' + @NetbackupFileRunInfo + '_FileList.txt'
		SET @dbsFSbackupLogName = @NB_ManifestDirectory
				+ '\CVManifest_' + @dbsNetbackupIDtext + '_' + @NetbackupFileRunInfo + '_Log.txt'
	END
	ELSE -- IF @NB_Enabled = 1
	BEGIN
		SET @NB_ManifestDirectory = @dbsInstanceFileLocation + 'Netbackup'
		SET @dbsFSbackupFileListName = @NB_ManifestDirectory
				+ '\NBManifest_' + @dbsNetbackupIDtext + '_' + @NetbackupFileRunInfo + '_FileList.txt'
		SET @dbsFSbackupLogName = @NB_ManifestDirectory
				+ '\NBManifest_' + @dbsNetbackupIDtext + '_' + @NetbackupFileRunInfo + '_Log.txt'
	END 

	IF ISNULL(@NB_ManifestDirectory,'')=''
	BEGIN
		SET @message = 'UBSMWE: usp_RunFilebackup: Unhandled Exception: @NB_ManifestDirectory IS NULL. Filebackup operations will not continue on this node.'
		EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ',@message, 1 --actually raise an error to cause the job to fail...
		RETURN 1 -- Exit with failure
	END

	-- Ensure the Manifest Directory exists
	SET @sql2 = 'if not exist ' + @NB_ManifestDirectory
		+ ' md '  + @NB_ManifestDirectory
	EXEC master..xp_cmdshell @sql2

	----------------------------------------------------------
	--Update the header information to the dbsNetbackup table for this run
	--Insert new entry and get @dbsNetbackupRunNumber
	
	SELECT @dbsNetbackupRunNumber = MAX(dbsNetbackupRunNumber) + 1 
	FROM [DBServices].[dbo].dbsNetbackupStatus
	WHERE dbsNetbackupID = @dbsNetbackupID

	IF @dbsNetbackupRunNumber IS NULL 
		SET @dbsNetbackupRunNumber = 0
		
	INSERT INTO [DBServices].[dbo].[dbsNetbackupStatus]
		([dbsNetbackupRunNumber]
		,[dbsNetbackupID]
		,[dbsNetbackupClass]
		,[dbsNetbackupFileListName]
		,[dbsNetbackupLogName])
	VALUES (@dbsNetbackupRunNumber
		,@dbsNetbackupID
		,@NB_Class
		,@dbsFSbackupFileListName
		,@dbsFSbackupLogName)
	                                                                    
	----------------------------------------------------------
	-- Compile the FS backup cmd

	IF @CV_Enabled = 1 -- CV FS iDA
	BEGIN 
		SET @FSbackupCommand = '"' + @CV_ExecutableLocation + '"'
			+ ' -L ' + @dbsFSbackupLogName
			+ ' -f ' + @dbsFSbackupFileListName + @InstanceCommand + @ClusterCommand 

		EXEC @RC = [DBServices].[dbo].[usp_CVFSBackupSet] @CVFSBackupSet OUTPUT, @CVFSSubclient OUTPUT, @Init=1

		IF @RC <> 0
			SET @FSbackupCommand = NULL	-- Error occured - fail the sp
		ELSE
		IF @dbsBackupProcessor = 5 -- TRRv3 Logshipped Tlog FS dumps or exceptions
		BEGIN
			IF EXISTS(	-- IF MWE handles LS TLog backups
				SELECT 1	
				FROM [DBServices].[dbo].dbsDatabaseBackup dbb
				INNER JOIN [DBServices].[dbo].dbsDatabase db
					ON dbb.dbsDatabaseUID = db.dbsDatabaseUID
				WHERE db.dbsDatabaseIsSystemObjectFlag = 0
					AND db.dbsDatabaseIsActive = 1
					AND dbb.dbsDBBackupType = 'LS_Primary'
					AND db.dbsDatabaseUID NOT IN (SELECT dbsDatabaseUID FROM @DB_Exclusion_List)
					)
				OR EXISTS( -- IF there are any external backup exceptions
				SELECT 1	
				FROM [DBServices].[dbo].dbsDatabaseException dbe
				INNER JOIN [DBServices].[dbo].dbsDatabase db
					ON db.dbsDatabaseUID = dbe.dbsDatabaseUID
				WHERE dbe.dbsDatabaseExceptionType = 'backup'
					AND dbe.dbsDatabaseExceptionSubType = 'external'
					AND dbe.dbsExceptionActive = 1
					AND db.dbsDatabaseIsActive = 1
					AND db.dbsDatabaseUID NOT IN (SELECT dbsDatabaseUID FROM @DB_Exclusion_List)
					)
			BEGIN			
				SET @FSbackupCommand = @FSbackupCommand 
					+ ' -b ' + @CVFSBackupSet 
					+ ' -s ' + @CVFSSubclient
			END  ----------------------------------
			ELSE
			BEGIN
				SET @message = 'UBSMWE: usp_RunFilebackup: CVScheduled backups; No primary logshipped DBs identified - skipping FS'
				PRINT @message
				RETURN 0
			END
		END  ----------------------------------
		ELSE
		BEGIN
			-- Backup set override
			SET @FSbackupCommand = @FSbackupCommand 
					+ ' -b ' + @CVFSBackupSet 
					+ ' -s ' + @CVFSSubclient
		END
	END ----------------------------------
	ELSE
	BEGIN -- Netbackup cmd
		SET @FSbackupCommand = '"' + @NB_BPBackup_ExecutableLocation
			+ '" -p ' + @NB_Class
			+ ' -L ' + @dbsFSbackupLogName
			+ ' -w  -f ' + @dbsFSbackupFileListName
	END          

	IF ISNULL(@FSbackupCommand,'')=''
	BEGIN
		SET @message = 'UBSMWE: usp_RunFilebackup: Unhandled Exception: @FSbackupCommand IS NULL. Filebackup operations will not continue on this node.'
		EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ',@message, 1 --actually raise an error to cause the job to fail...
		RETURN 1 -- Exit with failure
	END
	ELSE
		PRINT @FSbackupCommand

	----------------------------------------------------------
	--Now, need to build the manifest file for the Netbackup call and create the Manifest directory
	--Only get filenames for those files in the manifest

	--Enter in the Command used to kick off this run of Netbackup
	EXEC @RC = [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, '..........................................................................................................'
	IF @RC <> 0 
	BEGIN
		SET @message = 'UBSMWE: usp_RunFilebackup: ERROR writing to ' + @dbsFSbackupLogName 
			+ ' - Filebackup operations will not continue on this node.'
		EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ',@message, 1 --actually raise an error to cause the job to fail...

		RETURN 1 -- Exit with failure
	END

	EXEC @RC = [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @FSbackupCommand
	
	IF @NetbackupErrorCount > 0
	BEGIN
		EXEC @RC = [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, '..........................................................................................................'

		SET @WritelineText = 'Since we have an error condition we are delaying the start of the retry of the file backup by '
				+ CAST(@NetbackupErrorRerunDelayMinutes as nvarchar(3)) + ' minutes.'
		EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @WritelineText

		SET @WritelineText = 'Starting retry delay at: '
			+ CAST(getdate() as nvarchar(30)) 
		EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @WritelineText

		WAITFOR DELAY @DelayLength

		SET @WritelineText = 'Ending retry delay at: '
			+ CAST(getdate() as nvarchar(30)) 
		EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @WritelineText
	END
	
	EXEC @RC = [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, '..........................................................................................................' 

	----------------------------------------------------------
	-- Determine manifest

	IF @NetbackupErrorCount = 0
	BEGIN -- No errors:
		IF @Segregate = 1
		BEGIN
			DECLARE manifest_cur CURSOR
			FOR SELECT dbh.dbsDBHID, 
				dbh.dbsDatabaseUID, 
				dbh.dbsDBHFileName,
				dbh.dbsDBHIsLogFlag,
				RIGHT(dbh.dbsDBHFileName, 3) as backup_type
			FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbh
			INNER JOIN [DBServices].[dbo].dbsDatabaseBackup dbb
				ON dbh.dbsDatabaseUID = dbb.dbsDatabaseUID
			WHERE ((dbh.dbsDBHSentToNBFlag = 0 OR dbh.dbsDBHSentToNBFlag IS NULL)--dbh.dbsDBHID > @dbsDBHID_MAX
						AND dbh.dbsDBHIsOnDiskFlag = 1  --Fix for error when Netbackup runs and file is still being backed up.
						AND dbb.dbsDBIsInFullBackupProcess = 0
						AND dbb.dbsDBIsInLogBackupProcess = 0
						AND (dbb.dbsDBExternalBackupFlag = 0 OR dbb.dbsDBBackupType ='LS_Primary'))
					AND dbh.dbsDatabaseUID NOT IN (SELECT dbsDatabaseUID FROM @DB_Exclusion_List)
			ORDER BY backup_type DESC
		END ----------------------------------
		ELSE  
		BEGIN -- @Segregate <> 1 
			DECLARE manifest_cur CURSOR
			FOR SELECT  dbh.dbsDBHID, 
				 dbh.dbsDatabaseUID, 
				 dbh.dbsDBHFileName,
				 dbh.dbsDBHIsLogFlag,
				 RIGHT(dbh.dbsDBHFileName, 3) as backup_type
			FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbh
			INNER JOIN [DBServices].[dbo].dbsDatabaseBackup dbb
				ON dbh.dbsDatabaseUID = dbb.dbsDatabaseUID
			WHERE ((dbh.dbsDBHSentToNBFlag = 0 OR dbh.dbsDBHSentToNBFlag IS NULL)--dbh.dbsDBHID > @dbsDBHID_MAX
						AND dbh.dbsDBHIsOnDiskFlag = 1  --Fix for error when Netbackup runs and file is still being backed up.
						AND dbb.dbsDBIsInFullBackupProcess = 0
						AND dbb.dbsDBIsInLogBackupProcess = 0
						AND (dbb.dbsDBExternalBackupFlag = 0 OR dbb.dbsDBBackupType ='LS_Primary'))
					AND dbh.dbsDatabaseUID NOT IN (SELECT dbsDatabaseUID FROM @DB_Exclusion_List)
		END
	END
	ELSE ----------------------------------
	BEGIN -- @NetbackupErrorCount > 0 - retry manifest
		IF @Segregate = 1
		BEGIN
			DECLARE manifest_cur CURSOR
			FOR SELECT  dbh.dbsDBHID, 
				dbh.dbsDatabaseUID, 
				dbh.dbsDBHFileName,
				dbh.dbsDBHIsLogFlag,
				RIGHT(dbh.dbsDBHFileName, 3) as backup_type
			FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbh
			INNER JOIN [DBServices].[dbo].dbsNetbackupManifest dnm
				ON dbh.dbsDBHID = dnm.dbsDBHID
			WHERE dnm.IsSuccess = 0
				AND dnm.dbsNetbackupID = @dbsNetbackupID
			ORDER BY backup_type DESC
		END ----------------------------------
		ELSE  
		BEGIN -- @Segregate <> 1 
			DECLARE manifest_cur CURSOR
			FOR SELECT  dbh.dbsDBHID, 
				dbh.dbsDatabaseUID, 
				dbh.dbsDBHFileName,
				dbh.dbsDBHIsLogFlag,
				RIGHT(dbh.dbsDBHFileName, 3) as backup_type
			FROM [DBServices].[dbo].dbsDatabaseBackupHistory dbh
			INNER JOIN [DBServices].[dbo].dbsNetbackupManifest dnm
				ON dbh.dbsDBHID = dnm.dbsDBHID
			WHERE dnm.IsSuccess = 0
				AND dnm.dbsNetbackupID = @dbsNetbackupID
		END
	END  ----------------------------------

	OPEN manifest_cur
	
	FETCH NEXT FROM manifest_cur
	INTO @dbsDBHID, @dbsDatabaseUID, @dbsDBHFileName, @dbsDBHIsLogFlag, @bak_type

	IF (@@fetch_status <> 0)
	BEGIN
		SET @message = 'UBSMWE: usp_RunFilebackup: Nothing to backup - exiting'
		EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @message
		PRINT @message
		
		-- tidy up
		CLOSE manifest_cur
		DEALLOCATE manifest_cur
		
		SET @dbsNetbackupExitStatus = @message
		SET @RC = 0

		GOTO UPDATE_EXIT_STATUS
	END
	ELSE  ----------------------------------
	BEGIN
						
		WHILE (@@fetch_status <> -1)
		BEGIN --Begin1
			IF (@@fetch_status <> -2)
			BEGIN --Begin2

				SET @exists = 0
				EXEC @RC = [DBServices].[dbo].[usp_FileExists] @dbsDBHFileName, @exists OUTPUT

				--Move the file first, if the file can not be moved 
				--then do not enter it into the Netbackup list,
				--if the file does not exist then clear the ondisk flag and enter a error
				--in the log file indicating the issue as a non critical issue.

				IF @exists = 1 
				BEGIN --Begin3                        
					--Insert current file name into manifest file. This information is only used for documentation and not in the program.
					--Will consider using the ole automated procedures once they are fully tested and find no memory issues.

					IF @CV_Enabled = 1 -- CV filesystem iDA
						SET @sql2 =  @dbsDBHFileName
					ELSE -- Netbackup
						SET @sql2 =  CONVERT(varchar(3), LEN(@dbsDBHFileName)) + ' ' + @dbsDBHFileName
					
					EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupFileListName, @sql2
						
					--Assume fail unless we get good exit code. If we get good exit code then mark as success.
					IF @NetbackupErrorCount = 0
					BEGIN -- success
						INSERT INTO [DBServices].[dbo].dbsNetbackupManifest
						SELECT @dbsNetbackupID, @dbsDBHID, @dbsDBHFileName, 0, @dbsNetbackupRunNumber

						UPDATE [DBServices].[dbo].dbsDatabaseBackupHistory
							SET dbsDBHSentToNBFlag = 1
						WHERE CURRENT OF manifest_cur 
					END
					ELSE -- error
					BEGIN
						UPDATE [DBServices].[dbo].dbsNetbackupManifest
						SET IsSuccessRunNumber = @dbsNetbackupRunNumber, IsSuccess = 0
						WHERE CURRENT OF manifest_cur 
					END

					--Update MSSQLCentral
					EXEC [DBServices].[dbo].msc_UpdatedbsDatabaseBackupHistory @dbsDBHID = @dbsDBHID
						, @dbsDatabaseUID = @dbsDatabaseUID
						, @dbsDBHSentToNBFlag = 1
				END ----------------------------------
				ELSE
				BEGIN -- File not found
					UPDATE [DBServices].[dbo].dbsDatabaseBackupHistory
					SET dbsDBHSentToNBFlag = 0, dbsDBHIsOnDiskFlag = 0
					WHERE CURRENT OF manifest_cur 

					SET @message = 'The dump file ' + @dbsDBHFileName 
						+ ' for database ' +  @dbsDBHFileName 
						+ ' could not be located consequently an offsite backup is not possible.'
					SET @Command =  'Manifest# '+ CAST(@dbsNetbackupIDtemp as nvarchar(20))

					EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup ',@Command ,@message, 0, 1
				END --End3 
			END --End2

			FETCH NEXT FROM manifest_cur
			INTO @dbsDBHID, @dbsDatabaseUID, @dbsDBHFileName, @dbsDBHIsLogFlag, @bak_type
		END --End1

	END
	CLOSE manifest_cur
	DEALLOCATE manifest_cur

	EXEC @RC = [DBServices].[dbo].[usp_FileExists] @dbsFSbackupFileListName, @exists OUTPUT
	IF @exists = 0
	BEGIN
		SET @message = CHAR(13) + 'UBSMWE: usp_RunFilebackup: Conditions resulted in an empty filelist - nothing to backup'
		EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @message
		PRINT @message

		SET @dbsNetbackupExitStatus = @message
		SET @RC = 0

		GOTO UPDATE_EXIT_STATUS
	END

	----------------------------------------------------------
	-- Execute the backup command...

	IF OBJECT_ID('tempdb..#NBExitStatus') IS NOT NULL     
		DROP TABLE #NBExitStatus

	CREATE TABLE #NBExitStatus (NBExitText nvarchar(512))

	----------------------
	-- Execute DO
	
	INSERT INTO #NBExitStatus
		EXEC master..xp_cmdshell @FSbackupCommand 
		
	SET @RC = @@ERROR
	IF @RC <> 0
		PRINT 'UBSMWE: usp_RunFilebackup: Backup command RC: ' + CAST(@RC as varchar(4))

	WAITFOR DELAY '00:00:02' -- allow for buffers to flush
	
	----------------------------------------------------------
	-- Determine outcome

	SET @RC = NULL
	
	SELECT TOP 1 @dbsNetbackupExitStatus = LTRIM(RTRIM(NBExitText))  
	FROM #NBExitStatus
	WHERE UPPER(NBExitText) LIKE '%SERVER STATUS%'
		OR UPPER(NBExitText) LIKE '%NOT RECOGNIZED%'
		OR UPPER(NBExitText) LIKE '%EXIT_STATUS%'
	
	IF ISNULL(@dbsNetbackupExitStatus,'') = ''
	BEGIN
		-- cmd output buffer issue - attempt to read log file instead
		SET @FSbackupCommand = 'type "' + @dbsFSbackupLogName + '"'	

		TRUNCATE TABLE #NBExitStatus
		INSERT INTO #NBExitStatus
			EXEC master..xp_cmdshell @FSbackupCommand 

		SELECT TOP 1 @dbsNetbackupExitStatus = LTRIM(RTRIM(NBExitText))  
		FROM #NBExitStatus
		WHERE UPPER(NBExitText) LIKE '%SERVER STATUS%'
			OR UPPER(NBExitText) LIKE '%NOT RECOGNIZED%'
			OR UPPER(NBExitText) LIKE '%EXIT_STATUS%'
	END

	PRINT '@dbsNetbackupExitStatus: ' + ISNULL(@dbsNetbackupExitStatus, 'NULL')

	IF ISNULL(@dbsNetbackupExitStatus,'') = ''
	BEGIN
		SET @dbsNetbackupExitStatus = 'ERROR: unable to identify the exit status'
		SET @RC = -999
	END
	ELSE
	IF @CV_Enabled = 0
		AND @NB_Enabled = 1
		AND LOWER(@dbsNetbackupExitStatus) LIKE '%netbackup job exited with no exit_status returned%'
	BEGIN
		SET @RC = 0
		GOTO UPDATE_EXIT_STATUS
	END 
	ELSE
	IF LOWER(@dbsNetbackupExitStatus) LIKE '%not recognized as an internal or external command%'
		SET  @RC = -999 	                                                  
 
	SET @i = CHARINDEX('STATUS', UPPER(@dbsNetbackupExitStatus)) 
	IF @i > 0
		AND @RC IS NULL
	BEGIN
		SET @sql1 = SUBSTRING(@dbsNetbackupExitStatus, @i+6, @i+15)
		SET @sql1 = STUFF(@sql1, 1, PATINDEX('%[0-9-]%', @sql1)-1, '') -- remove leading non-numeric chars

		IF PATINDEX('%[^0-9-]%', @sql1) > 0
			SET @sql1 = STUFF(@sql1, PATINDEX('%[^0-9-]%', @sql1), LEN(@sql1), '') -- remove trailing non-numeric chars

		IF ISNUMERIC(@sql1)=1 
			SET @RC = CAST(@sql1 as smallint)
		ELSE
		BEGIN
			SET @dbsNetbackupExitStatus = 'ERROR: unable to identify the exit status' 
			SET @RC = -999 -- Unknown Error
		END
	END
	ELSE 
		SET @RC = -999 -- Unknown Error
		
	SET @HelpMsg = 'To check the status of this File backup run; EXEC DBServices..usp_Help_FileBackup ' 
		+ CAST(@dbsNetbackupID as nvarchar(15)) 
		+ ', ' + CAST(@dbsNetbackupRunNumber as nvarchar(15))  
		
	IF OBJECT_ID('tempdb..#NBExitStatus') IS NOT NULL     
		DROP TABLE #NBExitStatus
	
	PRINT 'FS ReturnCode = ' + CAST(@RC as varchar(4))

	IF @RC NOT IN (0, 105) -- indicates a failure
	BEGIN 
		--------------------------------
	    -- Attempt to retry on error
	                                 
		SET @NetbackupErrorCount = @NetbackupErrorCount + 1

		IF @NetbackupErrorCount > @NetbackupErrorLimit
		BEGIN -- Fail

			SET @dbsNetbackupExitStatus = 'FAILED: Need DBA Attention. Manifest='
				+ ISNULL(CAST(@dbsNetbackupID as nvarchar(10)), 'Null dbsNetbackupID') 
				+ ' RunNumber:' + ISNULL(CAST(@dbsNetbackupRunNumber as nvarchar(2)), 'Null dbsNetbackupRunNumber')
				+ ' FilebackupErrorCount: ' + ISNULL(CAST(@NetbackupErrorCount as nvarchar(2)), 'Null NetbackupErrorCount')
				+ ' FilebackupErrorLimit:' + ISNULL(CAST(@NetbackupErrorLimit as nvarchar(2)), 'Null NetbackupErrorLimit')
				+ ' FilebackupExitStatus: ' + ISNULL(@dbsNetbackupExitStatus, 'Null dbsNetbackupExitStatus')

			SET @RC = -1
		END --------------------------------
		ELSE
		BEGIN -- Retry
			SET @dbsNetbackupExitStatus = 'RETRY: Retry on next run. Manifest='
				+ ISNULL(CAST(@dbsNetbackupID as nvarchar(10)), 'Null dbsNetbackupID') 
				+ ' RunNumber:' + ISNULL(CAST(@dbsNetbackupRunNumber as nvarchar(2)), 'Null dbsNetbackupRunNumber') 
				+ ' FilebackupErrorCount: ' + ISNULL(CAST(@NetbackupErrorCount as nvarchar(2)), 'Null NetbackupErrorCount')
				+ ' FilebackupErrorLimit:' + ISNULL(CAST(@NetbackupErrorLimit as nvarchar(2)), 'Null NetbackupErrorLimit')
				+ ' FilebackupExitStatus: ' + ISNULL(@dbsNetbackupExitStatus, 'Null dbsNetbackupExitStatus')

			SET @RC = 0
		END
		
		SET @message = @dbsNetbackupExitStatus + ' ' + @HelpMsg
		SET @WritelineText = 'File backup job ended with exit status: ' + @message

		EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @WritelineText

		UPDATE [DBServices].[dbo].[dbsNetbackup]        
		SET [dbsNetbackupRequestEndDate] = getdate()
			,[dbsNetbackupExitStatus] = @dbsNetbackupExitStatus
		WHERE dbsNetbackupID = @dbsNetbackupID

		EXEC [DBServices].[dbo].[usp_CheckNetbackupStatusDetail] @dbsNetbackupID, 1, @dbsNetbackupRunNumber, 1
		
		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'NetbackupErrorCount', @NetbackupErrorCount
		
		IF @RC = 0
		BEGIN  -- Retry in @NetbackupErrorRerunDelayMinutes mins

			SET @RetryTime = DATEADD(minute, @NetbackupErrorRerunDelayMinutes, getdate())			
			PRINT 'UBSMWE: usp_RunFilebackup: Retrying at: ' + CAST(@RetryTime as varchar(30))

			WAITFOR TIME @RetryTime

			EXEC [DBServices].[dbo].[usp_RunFilebackup]
		END
		ELSE --actually raise an error to cause the job to fail...
			EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ', @message, 1 
	END	----------------------------------------------------------
	ELSE
	BEGIN -- @RC = 0,105 : Successfully completed
	
		UPDATE_EXIT_STATUS:
		
		EXEC @RC = [DBServices].[dbo].[usp_CheckNetbackupStatusDetail] @dbsNetbackupID , 1, @dbsNetbackupRunNumber, 1		
		IF @RC <> 0
		BEGIN
			SET @message = 'UBSMWE: usp_RunFilebackup: ERROR usp_CheckNetbackupStatusDetail returned ' + CAST(@RC as varchar(4))
			PRINT @message
			EXEC [DBServices].[dbo].usp_WriteLineToFile @dbsFSbackupLogName, @message
				
			SET @NetbackupErrorCount = @NetbackupErrorCount + 1

			UPDATE [DBServices].[dbo].[dbsNetbackup]        
			SET [dbsNetbackupRequestEndDate] = getdate()
				,[dbsNetbackupExitStatus] = @dbsNetbackupExitStatus
			WHERE dbsNetbackupID = @dbsNetbackupID

			EXEC [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'NetbackupErrorCount',  @NetbackupErrorCount

			IF @NetbackupErrorCount <= @NetbackupErrorLimit
			BEGIN  -- Retry in @NetbackupErrorRerunDelayMinutes mins

				SET @RetryTime = DATEADD(minute, @NetbackupErrorRerunDelayMinutes, getdate())			
				PRINT 'UBSMWE: usp_RunFilebackup: Retrying at: ' + CAST(@RetryTime as varchar(30))

				WAITFOR TIME @RetryTime

				EXEC [DBServices].[dbo].[usp_RunFilebackup]
			END
			ELSE --actually raise an error to cause the job to fail...
				EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_RunFilebackup', 'SQL Job Execution ', @message, 1 

		END --------------------------------
		ELSE
		BEGIN -- Success

			UPDATE [DBServices].[dbo].[dbsNetbackup]        
			SET [dbsNetbackupRequestEndDate] = getdate()
				,[dbsNetbackupExitStatus] = @dbsNetbackupExitStatus + ISNULL(@HelpMsg, '')
			WHERE dbsNetbackupID = @dbsNetbackupID

			IF @dbsNetbackupRunNumber > 0
			BEGIN
				UPDATE [DBServices].[dbo].dbsNetbackupManifest
				SET IsSuccess = 1
				WHERE dbsNetbackupID = @dbsNetbackupID
					AND IsSuccessRunNumber = @dbsNetbackupRunNumber
			END

			EXEC [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'NetbackupErrorCount',  0
		END --------------------------------
	END
END 

----------------------------------------------------------

IF OBJECT_ID('tempdb..#NBExitStatus') IS NOT NULL     
	DROP TABLE #NBExitStatus

RETURN @RC

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_ShutDownDBUsers]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO




CREATE PROCEDURE [dbo].[usp_ShutDownDBUsers]
  @DBName sysname, -- Name of database to shut down (Required)
  @postshutdowncmd nvarchar(256)=''  -- Optional command to execute after last kill
AS
SET DATEFORMAT ymd

/****************************************************************************************
// @File: usp_ShutDownDBUsers.SQL
// 
// Purpose:
//   This stored procedure will close all user connections to a database and then execute the optionally specified command.
//
// Notes: This stored procedure is called from main UBSMWE usp_BackupDatabase. 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production 
//
****************************************************************************************/

BEGIN
  DECLARE @killcmd nvarchar(128)
  DECLARE @spid int
   DECLARE killcursor CURSOR FOR
  SELECT DISTINCT spid from master.dbo.sysprocesses 
   WHERE dbid -- Only select SPID > 10 to avoid killing any system processes
      in (SELECT dbid from master.dbo.sysdatabases WHERE name = @DBName) and spid >= 10
  OPEN killcursor
  FETCH killcursor into @spid
  WHILE @@FETCH_STATUS <> -1
    BEGIN
      SET @killcmd = 'kill ' + convert(varchar(10),@spid)
      PRINT @killcmd
      EXECUTE master..sp_executesql @killcmd
      FETCH killcursor into @spid
    END
  CLOSE killcursor
  DEALLOCATE killcursor
  IF @postshutdowncmd <> '' 
    EXECUTE master..sp_executesql @postshutdowncmd
END


GO
/****** Object:  StoredProcedure [dbo].[usp_SysFolders_Chk]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_SysFolders_Chk]
AS

/****************************************************************************************
// @File: usp_SysFolders_Chk.SQL
// @Version 6.0.0.25
//
// Purpose:
//  Verifies dbsInstanceFileLocation and UBSMWE folder dependancies 
//	syncs/alerts accordingly
//
// History:
//
//   @DateFormat DD/MM/YYYY
//   @Date: 06/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 29/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta
//   @Date: 14/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.11 @Action: TRRv3 release
//	 @Date: 23/02/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.25 @Action: Backup monitor feature request
****************************************************************************************/

BEGIN --main

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int
	,@AStr nvarchar(384)
	,@dbsInstanceFileLocation_out nvarchar(255) 
	,@CV_bTLBackupToFS_out int 
	,@CV_backupFromFSForLog_out int     
	,@CV_SqlLogBackupInterval_out int   
	,@CVClient nvarchar(128) 
	,@CVInstance nvarchar(128)                   
	,@ErrorMsg nvarchar(512)
	,@dbsInstanceFileLocation nvarchar(255)
	,@NB_WorkDirectory nvarchar(255)
	,@dbsBackupProcessor tinyint
	,@dbsBakTlogConcernMins int

SET @ErrorMsg = 'UBSMWE: usp_SysFolders_Chk: '
SET @RC = 0

-----------------------------------------------
-- Get CV TLog config

EXEC @RC = [DBServices].[dbo].[usp_CVClient] @CVClient = @CVClient OUTPUT
											,@CVInstance = @CVInstance OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig]'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig]'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 

IF @dbsBackupProcessor = 5
BEGIN
	SET @dbsInstanceFileLocation_out = NULL

	EXEC @RC = [DBServices].[dbo].[usp_CVTLogBakStagingStatus] 
			@CV_SqlLogBackupStageFolder = @dbsInstanceFileLocation_out OUTPUT
			,@CV_bTLBackupToFS = @CV_bTLBackupToFS_out  OUTPUT
			,@CV_backupFromFSForLog = @CV_backupFromFSForLog_out  OUTPUT 
			,@CV_SqlLogBackupInterval = @CV_SqlLogBackupInterval_out OUTPUT

	IF ISNULL(@dbsInstanceFileLocation_out,'') = '' 
	BEGIN
		SET @ErrorMsg = @ErrorMsg + 'WARNING: CV TLog backup staging folder is NULL consequently TLog backups will fail - Investigation required; please contact Backup Services'
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
		
		SET @RC = 1
		GOTO END_IT
	END
	ELSE -- Root folder identified; append instance Subfolder 
		SET @dbsInstanceFileLocation_out = @dbsInstanceFileLocation_out 
			+ '\' + REPLACE (@CVInstance, '\', '_')
END
ELSE -- @dbsBackupProcessor < 5
	SET @dbsInstanceFileLocation_out = @dbsInstanceFileLocation

IF LEN(@dbsInstanceFileLocation_out) > 192
BEGIN
	SET @ErrorMsg = @ErrorMsg + 'WARNING: dbsInstanceFileLocation is > 192 characters in length which may result in UBSMWE failures - Investigation required'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	-- raise event but continue as warning only
END

-----------------------------------------------
-- Verify folder exists
EXEC DBServices.dbo.usp_FileExists 
	@FileName = @dbsInstanceFileLocation_out
	, @exists = @RC OUTPUT

IF @RC = 0 -- Folder does not exist or does not have correct permissions for the MSSQL service account
BEGIN
	SET @AStr = N'mkdir ' + @dbsInstanceFileLocation_out
	EXEC @RC = master..xp_cmdshell @AStr, no_output

	IF @RC <> 0
	BEGIN
		SET @ErrorMsg = 'ERROR: Folder ' + @dbsInstanceFileLocation_out + ' could not be located or created'
			+ ' - Please verify both the MSSQL Service account and ''NT Authority\System'' have FULL permissions and contact Backup Services accordingly'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3 -- error

		SET @RC = 1
		GOTO END_IT
	END
END

IF @dbsBackupProcessor = 5
BEGIN
	-- Folder exists, compare with UBSMWE config
	IF LOWER(@dbsInstanceFileLocation) <> LOWER(@dbsInstanceFileLocation_out)
	BEGIN
		SET @ErrorMsg = @ErrorMsg + 'INFO: CV TLog backup staging folder has been updated at the CommServe; updating UBSMWE accordingly from ' 
			+ @dbsInstanceFileLocation + ' to ' + @dbsInstanceFileLocation_out

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1	-- Info

		EXEC @RC = DBServices.dbo.usp_ConfigureUBSMWE 'dbsInstanceFileLocation', @dbsInstanceFileLocation_out	
		EXEC @RC = DBServices.dbo.usp_ConfigureUBSMWE 'NB_WorkDirectory', @dbsInstanceFileLocation_out 

	END

	-----------------------------------------------
	-- Verify CV config

	IF @CV_bTLBackupToFS_out <> 1 
		OR @CV_backupFromFSForLog_out <> 1
	BEGIN
		SET @ErrorMsg = 'ERROR: CV Scheduled TLog backups are incorrectly configured; Please contact Backup Services - '
			+ 'The following CV reg settings should be set to = 1 :' 
			+ ' bTLBackupToFS = ' + CAST (@CV_bTLBackupToFS_out as varchar(2)) 
			+ ' backupFromFSForLog ' + CAST (@CV_backupFromFSForLog_out as varchar(2))	
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3 -- error

		SET @RC = 1
		GOTO END_IT
	END

	-- Update dbsinstance config for CV scheduled interval
	IF ISNUMERIC(@CV_SqlLogBackupInterval_out) = 1
		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'CV_SchedTlogBakMins', @CV_SqlLogBackupInterval_out
	ELSE
	BEGIN
		SET @ErrorMsg = 'ERROR: CV Scheduled TLog backups are incorrectly configured; Please contact Backup Services: '
			+ 'SqlLogBackupInterval = ' + CAST (@CV_SqlLogBackupInterval_out as varchar(5)) 
		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3 -- error

		SET @RC = 1
		GOTO END_IT
	END

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig]'dbsBakTlogConcernMins', @dbsBakTlogConcernMins OUTPUT, @quiet=1  
	
	SET @CV_SqlLogBackupInterval_out = (ISNULL(@CV_SqlLogBackupInterval_out, 15) * 2) + 1

	IF @CV_SqlLogBackupInterval_out > @dbsBakTlogConcernMins
		OR @dbsBakTlogConcernMins IS NULL 
		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsBakTlogConcernMins', @CV_SqlLogBackupInterval_out
END

-----------------------------------------------
-- Verify Subfolders

-- JobLog
-- NA - Handled by usp_ConfigureUBSMWE call

--------------
-- CVbackup
SET  @AStr = @dbsInstanceFileLocation_out + '\CVbackup'

EXEC DBServices.dbo.usp_FileExists 
	@FileName = @AStr
	, @exists = @RC OUTPUT

IF @RC = 0 -- not exists
BEGIN
	SET @AStr = N'mkdir ' + @AStr
	EXEC @RC = master..xp_cmdshell @AStr, no_output

	IF @RC <> 0
	BEGIN
		SET @ErrorMsg = 'ERROR: Folder ' + @dbsInstanceFileLocation_out + '\CVbackup' + ' could not be located or created'
			+ ' - Please verify both the MSSQL Service account and ''NT Authority\System'' have FULL permissions and contact Backup Services accordingly'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3 -- error

		SET @RC = 1
		GOTO END_IT
	END 
END
ELSE 
	SET @RC = 0 -- successful - final return code: 0

-----------------------------------------------

END_IT:

RETURN @RC

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_TopQueries]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_TopQueries] (@top tinyint = 10)
AS

/********************************************
// @File: usp_TopQueries.sql
// 
// Purpose:
//   For troubleshooting; Lists the top 10 Queries 
//
// Notes: This sp is for DBA use and only executed manually 
//
// History: Dates are in mm/dd/yyyy format
//
// @Date: 14/10/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Creation
********************************************/

BEGIN --main

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @sqlstr as varchar(4000)

-------------------------

SET @sqlstr = 'SELECT TOP ' + CAST(@top as varchar(3))
		+ ' db.name as [DBName]
			,SUBSTRING(st.text, (qs.statement_start_offset/2) + 1,
				((CASE statement_end_offset 
					WHEN -1 THEN DATALENGTH(st.text)
					ELSE qs.statement_end_offset
				END - qs.statement_start_offset)/2) + 1 ) as [Querytxt]
			,qs.last_execution_time as [LastExec]
			,(qs.total_logical_reads + qs.total_physical_reads) / qs.execution_count as [AvgRcnt]
			,(qs.total_logical_writes / qs.execution_count) as [AvgWcnt]
			,CAST((qs.total_worker_time / qs.execution_count) / 1000000.0 as numeric(10,3)) as [AvgWorkerSecs]
			,CAST((qs.total_elapsed_time / qs.execution_count) / 1000000.0 as numeric(10,3)) as [AvgElapsedSecs]
			,CAST((qs.total_clr_time / qs.execution_count)  / 1000000.0 as numeric(10,3)) as [AvgCLRSecs]
			,qs.execution_count as [ExecCount]
			,qp.query_plan as [QueryPlan]

	FROM sys.dm_exec_query_stats qs
	CROSS APPLY sys.dm_exec_sql_text(qs.plan_handle) st
	CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
	LEFT OUTER JOIN sys.databases db WITH (NOLOCK)
		ON qp.dbid = db.database_id

	WHERE db.database_id > 4 -- exclude system DBs 
		AND LOWER(db.name) NOT IN (''dbservices'', ''distribution'')
	ORDER BY qs.total_elapsed_time / qs.execution_count DESC'

EXEC (@sqlstr)

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_UBSMWE_Engine]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UBSMWE_Engine] 
AS

/****************************************************************************************
// @File: usp_UBSMWE_Engine.sql
//
// Purpose:
//   DBServices Main UBSMWE stored proc
//
// History:
//
//   @DateFormat DD/MM/YYYY
//   @Date: 05/12/2006 @Author: Kevin Wagner @Version: 2.5.0	@Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production 
//   @Date: 13/10/2008 @Author: Kevin Wagner @Version: 2.5.4.1 @Action: Updated to allow for shutting down the UBSMWE by setting the Error level to 4. 
//   @Date: 03/02/2014 @Author: Chris Basson @Version: 5.0.9 @Action: Bug fix update which adds call to [dbo].[usp_UpdatedbsDatabaseException]
//   @Date: 30/07/2014 @Author: Chris Basson @Version: 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 12/08/2014 @Author: Chris Basson @Version: 6.0.0.1 @Action: TRRv3 Beta
//   @Date: 15/08/2014 @Author: Chris Basson @Version: 6.0.0.3 @Action: TRRv3 Beta
//   @Date: 21/08/2014 @Author: Chris Basson @Version: 6.0.0.4 @Action: TRRv3 Beta
//   @Date: 03/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 07/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 11/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 13/11/2014 @Author: Chris Basson @Version: 6.0.0.11 @Action: TRRv3 Beta
//   @Date: 27/11/2014 @Author: Chris Basson @Version: 6.0.0.13 @Action: TRRv3 Beta
//   @Date: 04/12/2014 @Author: Chris Basson @Version: 6.0.0.14 @Action: TRRv3 Beta
//   @Date: 04/02/2015 @Author: Chris Basson @Version: 6.0.0.23 @Action: Feature request option to disable BackupMethod alerting
//   @Date: 26/02/2015 @Author: Chris Basson @Version: 6.0.0.25 @Action: Feature request: add DB backup monitoring for CV TRRv3, option to disable MSSQLCentral
//	 @Date: 20/03/2015 @Author: Chris Basson @Version: 6.0.0.28 @Action: Bugfix for dbsDatabaseFullBackupStartTime - to set WF job time
//	 @Date: 29/05/2015 @Author: Chris Basson @Version: 6.0.0.30 @Action: Bugfix - Bulk-logged recovery, AO AG
//	 @Date: 10/06/2015 @Author: Chris Basson @Version: 6.0.0.31 @Action: Bugfix DisableMSSQLCentral
//	 @Date: 06/07/2015 @Author: Chris Basson @Version: 6.0.0.35 @Action: Bugfix DisableMSSQLCentral = 1 still attempts to verify SQL Central connection details
//	 @Date: 15/10/2015 @Author: Chris Basson @Version: 6.0.0.40 @Action: Feature request: Long running Sunday Workflow alert (dbsMaintLongRunConcernHrs)

****************************************************************************************/

BEGIN --Main execution

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @UBSMWE_Error_Status tinyint
		,@ErrorMsg nvarchar (500)
		,@RC int
		,@UBSMWE_Errors_retentionDays int
		,@MSCCQProcessEnabled bit
		,@MainCycleCountMinutes int
		,@DisableBackupInformationalMessages int
		,@dbsBackupProcessor tinyint
		,@IsClustered bit
		,@SubCycleCnt tinyint
		,@SkipCnt tinyint
		,@dbsDatabaseFullBackupStartTime char(5)
		,@LastScheduleTime char(5)
		,@debug tinyint
		,@BackupAlerts bit
		,@SkipBy tinyint
		,@CVTLogBakMon_awake bit
		,@dbsDBBackupChk_SleepDT varchar(19)
		,@DBName varchar(128) 
		,@LastTLogEndDT datetime
		,@dbsBakTlogConcernMins varchar(5)
		,@dbsBakTlogConcernCVOnly bit
		,@AOnode bit
		,@AOPrim bit
		,@DisableMSSQLCentral bit
		,@dbsMaintLongRunConcernHrs tinyint
		,@MaintLongRunAlertRaised bit

------------------------------------------------
-- Init vars

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsIsInstanceClusteredFlag', @IsClustered OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsMaintLongRunConcernHrs', @dbsMaintLongRunConcernHrs OUTPUT

EXEC [DBServices].[dbo].usp_UpdateActiveServerName

SET @SubCycleCnt = 0
SET @SkipBy = 11 -- 11 subcycles = 2hrs

EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'dbsBakTlogConcernCVOnly', @dbsBakTlogConcernCVOnly OUTPUT, @quiet=1
SET @dbsBakTlogConcernCVOnly = ISNULL(@dbsBakTlogConcernCVOnly, 1)

EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'dbsBakTlogConcernMins', @dbsBakTlogConcernMins OUTPUT, @quiet=1
SET @dbsBakTlogConcernMins = ISNULL(@dbsBakTlogConcernMins, 30)

EXEC [DBServices].[dbo].usp_GetdbsInstanceConfig 'DisableBMAlerts', @BackupAlerts OUTPUT, @quiet=1
SET @BackupAlerts = CASE ISNULL(@BackupAlerts, 0)
								WHEN 1 THEN 0
								ELSE 1
							END

-------------------------
-- MSSQLCentral handler

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DisableMSSQLCentral', @DisableMSSQLCentral OUTPUT, @quiet=1
SET @DisableMSSQLCentral = ISNULL(@DisableMSSQLCentral, 0)

SET @MSCCQProcessEnabled = CASE @DisableMSSQLCentral
								WHEN 1 THEN 0
								ELSE 1
							END

EXEC msdb.dbo.sp_update_job @job_name = N'UBSMWE_ProcessMSCCQ', @enabled = @MSCCQProcessEnabled

------------------------------------------------
StartMainCycle:

-- Check every 11 hrs (660 min, or, 660 iterations of the main loop)
-- Note can change the main cycle poll time via MainCycleCountMinutes

-- Determine vars
SET @MaintLongRunAlertRaised = 0

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MainCycleCountMinutes', @MainCycleCountMinutes OUTPUT 
IF @RC <> 0 
BEGIN
	--If setting does not exist, default to 660min (11 hrs)
	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'MainCycleCountMinutes', '660'
	SET @MainCycleCountMinutes = 660
END	

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'DisableBackupInformationalMessages', @DisableBackupInformationalMessages OUTPUT 
IF @RC = 0 
BEGIN
	IF @DisableBackupInformationalMessages = 1 
		--True so we do not show backup messages in the MSSQL Error log.
		DBCC TRACEON (3226, -1)	
	ELSE
		--False so we do show backup messages in the MSSQL Error log.
		DBCC TRACEOFF (3226, -1)	
END	
ELSE
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine: The setting for DisableBackupInformationalMessages was not found in dbsInstanceConfig' 
	EXEC [DBServices].[dbo].usp_LogErrors NULL ,0, N'usp_UBSMWE_Engine', 'Missing setting',@ErrorMsg
END	

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'UBSMWE_Errors_retentionDays', @UBSMWE_Errors_retentionDays OUTPUT 
IF @RC <> 0 
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine: The setting for UBSMWE_Errors_retentionDays was not found in dbsInstanceConfig; defaulting to 14 days' 
	PRINT @ErrorMsg

	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'UBSMWE_Errors_retentionDays', '14'
	SET @UBSMWE_Errors_retentionDays = 14
END	

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime OUTPUT 

------------------------------------------------

IF @debug >= 2
	PRINT '-------------------- Running usp_LogErrorsCleanup --------------------'
EXEC [DBServices].[dbo].usp_LogErrorsCleanup @UBSMWE_Errors_retentionDays

--UBSMWE_Error_Status - Status possibilities: 0 = No Error; 1 = Error; 2 = Recovered from Error, 3 = Unknown error, call engineering. 
--Need this to actually clear the error status of a job and mark it as a success. When status = 2, job will run through once and quit 
--reporting success after setting error to 0. When error is 0, job will keep running until the next error condition is caught.
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'UBSMWE_Error_Status', @UBSMWE_Error_Status OUTPUT 
IF @RC <> 0 
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine: The setting for UBSMWE_Error_Status was not found in dbsInstanceConfig' 
	EXEC usp_LogErrors NULL ,0, N'usp_UBSMWE_Engine', 'Setting not exist: ',@ErrorMsg
	GOTO STOPUBSMWE
END		
IF @UBSMWE_Error_Status = 4 --4 = shutdown, no further processing
	GOTO STOPUBSMWE

------------------------------------------------
BEGIN --MainCycle steps

	IF @debug >= 2
		PRINT '/************************************************ Pause MSCCQ *******************************************************/'
 
	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'MSCCQProcessEnabled', '0'

	IF @debug >= 2
		PRINT '-------------------- Running usp_SysFolders_Chk --------------------'
	EXEC [DBServices].[dbo].[usp_SysFolders_Chk]

	IF @DisableMSSQLCentral = 0
	BEGIN
		IF @debug >= 2
			PRINT '-------------------- Running usp_mscGetInstanceID --------------------'
		EXEC [DBServices].[dbo].usp_mscGetInstanceID
	END

	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsUBSMWEHeartbeat --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsUBSMWEHeartbeat  'Main Heartbeat', 0

	IF @debug >= 2
		PRINT '-------------------- Clearing out invalid backup flags from dbsDatabaseBackup --------------------'
	UPDATE [DBServices].[dbo].dbsDatabaseBackup
	SET dbsDBIsInRestoreProcess = 0
		,dbsDBIsInFullBackupProcess = 0
		,dbsDBIsInLogBackupProcess = 0

	IF @DisableMSSQLCentral = 0
	BEGIN
		IF @debug >= 2
			PRINT '-------------------- Resync MSSQLCentral --------------------'
		DELETE FROM [DBServices].[dbo].dbsMSSQLCentralCommandQueueExtendedError
		DELETE FROM [DBServices].[dbo].dbsMSSQLCentralCommandQueue

		DBCC CHECKIDENT ("dbo.dbsMSSQLCentralCommandQueue", RESEED, 0);
	END

	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsDatabase --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsDatabase @Init = 1
	
	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsDatabaseBackup --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsDatabaseBackup -- do not initialise

	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsDatabaseException --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsDatabaseException

	IF @DisableMSSQLCentral = 0
	BEGIN
		IF @debug >= 2
			PRINT '-------------------- Running msc_UpdatedbsDatabase --------------------'
		EXEC [DBServices].[dbo].msc_UpdatedbsDatabase

		IF @debug >= 2
			PRINT '-------------------- Running msc_UpdatedbsDatabaseBackupHistoryINIT  --------------------'
		EXEC [DBServices].[dbo].msc_UpdatedbsDatabaseBackupHistoryINIT
	END

	PRINT '/************************************************ Continue MSCCQ *******************************************************/'

	EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'MSCCQProcessEnabled', @MSCCQProcessEnabled

	-------------------- Running TRR CV checks --------------------

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT

	IF @dbsBackupProcessor IN (4,5)  -- CommVault Backups
	BEGIN
		IF @debug >= 2
			PRINT '-------------------- Performing CV related checks --------------------'
		
		EXEC @RC = [DBServices].[dbo].[usp_CVBRATchk] @dbsBackupProcessor = @dbsBackupProcessor, @init = 1

		-- Ensure Verify DB Subclient and ensure; Subclient and CV Schedule data is upto date
		
		EXEC @RC = [DBServices].[dbo].[usp_Help_BackupMethod] @GenAlert = @BackupAlerts

		-- IF TRRv3 - update dbsInstanceConfig.dbsDatabaseFullBackupStartTime = last CVSchedulePolicy time for the day
		-- in order to ensure updatestats executes after all DBs have been backed up
		IF @dbsBackupProcessor = 5
		BEGIN
			EXEC @RC = [DBServices].[dbo].[usp_CVSchedulePolicyLastToday] @LastScheduleTime = @LastScheduleTime OUTPUT

			IF @RC = 0 
				AND @LastScheduleTime <> @dbsDatabaseFullBackupStartTime
			BEGIN
				SET @dbsDatabaseFullBackupStartTime = @LastScheduleTime

				EXEC @RC = [DBServices].[dbo].usp_ConfigureUBSMWE 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime 
			END
		END
	END

	-------------------- Running usp_UpdatedbsUBSMWEHeartbeat --------------------

	EXEC [DBServices].[dbo].usp_UpdatedbsUBSMWEHeartbeat  'Start main Engine Loop', 0
END --MainCycle steps

------------------------------------------------
 -- Subcycle Steps

SET @SubCycleCnt = 0
SET @SkipCnt = 0

StartSubCycle:

IF @debug >= 2
	PRINT '-------------------- Running usp_LogErrorsCleanup --------------------'
EXEC [DBServices].[dbo].usp_LogErrorsCleanup @UBSMWE_Errors_retentionDays

--UBSMWE_Error_Status - Status possibilities: 0 = No Error; 1 = Error; 2 = Recovered from Error, 3 = Unknown error, call engineering. 
--Need this to actually clear the error status of a job and mark it as a success. When status = 2, job will run through once and quit 
--reporting success after setting error to 0. When error is 0, job will keep running until the next error condition is caught.
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'UBSMWE_Error_Status', @UBSMWE_Error_Status OUTPUT 
IF @RC <> 0 
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine: The setting for UBSMWE_Error_Status was not found in dbsInstanceConfig' 
	EXEC usp_LogErrors NULL ,0, N'usp_UBSMWE_Engine', 'Setting not exist: ',@ErrorMsg
	GOTO STOPUBSMWE
END		
ELSE
IF @UBSMWE_Error_Status = 4 --4 = shutdown, no further processing
	GOTO STOPUBSMWE

BEGIN -- Subcycle Steps DO

	-------------------- Verifying Cluster failover status --------------------
	IF @IsClustered = 0 AND CAST(SERVERPROPERTY('IsClustered') as bit) = 1
	BEGIN
		EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'dbsIsInstanceClusteredFlag', 1 
		SET @IsClustered = 1
	END

	IF @IsClustered = 1
		EXEC [DBServices].[dbo].usp_UpdateActiveServerName

	-------------------- On 10th Subcycle --------------------
	IF @SubCycleCnt = 9
	BEGIN
		IF @debug >= 2
			PRINT '-------------------- Long running maintenance threshold check --------------------'

		IF @dbsMaintLongRunConcernHrs > 1
			AND @MaintLongRunAlertRaised = 0 -- latch
		BEGIN
			IF EXISTS (SELECT TOP 1 1
				FROM  msdb.dbo.sysjobs sj
				INNER JOIN msdb.dbo.sysjobactivity sa
					ON sa.job_id = sj.job_id
				WHERE sj.[enabled] = 1
					AND sj.[name] = 'UBSMWE_WF_Sunday_WorkFlow'
					AND sa.run_requested_date IS NOT NULL
					AND sa.stop_execution_date IS NULL
					AND DATEDIFF(hour, sa.run_requested_date, getdate()) >= @dbsMaintLongRunConcernHrs
					)
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine: UBSMWE_WF_Sunday_WorkFlow Long running maintenance threshold (dbsMaintLongRunConcernHrs): ' 
					+ CAST(@dbsMaintLongRunConcernHrs as varchar(3))  + 'hrs breached'
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2

				SET @MaintLongRunAlertRaised = 1	-- prevent spam, resets in MainCycle
			END	
		END --------------------

		IF @debug >= 2
			PRINT '-------------------- usp_BackupLUN_Mon --------------------'
			
		EXEC [DBServices].[dbo].[usp_BackupLUN_Mon]
		

		IF @debug >= 2
			PRINT '-------------------- Check Backup LUN disk space --------------------'

		IF @dbsBackupProcessor IN (4,5) -- CommVault Backups
		BEGIN
			IF @SkipCnt = 0 
			BEGIN
				
				IF @dbsBackupProcessor = 5
				BEGIN
					-- TRRv3 CV TLog Backup check
					EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDBBackupChk_SleepDT', @dbsDBBackupChk_SleepDT OUTPUT, @quiet=1
					
					IF ISDATE(@dbsDBBackupChk_SleepDT) = 1
					BEGIN
						IF getdate() < CAST(@dbsDBBackupChk_SleepDT as datetime)
							SET @CVTLogBakMon_awake = 0 -- sleep  
						ELSE
						BEGIN
							-- Re-enable TLog Backup check
							SET @CVTLogBakMon_awake = 1
							SET @dbsDBBackupChk_SleepDT = NULL
							EXEC [DBServices].[dbo].[usp_UpdatedbsInstanceConfig] 'dbsDBBackupChk_SleepDT', @dbsDBBackupChk_SleepDT
						END
					END
					ELSE
						SET @CVTLogBakMon_awake = 1

					IF @BackupAlerts = 1
						AND @CVTLogBakMon_awake = 1	
					BEGIN
						IF @debug >= 2
							PRINT '-------------------- CV TLog Backup Check --------------------'
						
						IF [DBServices].[dbo].[ufn_InstanceMajorVersion] () >= 11
							SET @AOnode = CAST(SERVERPROPERTY ('IsHadrEnabled') as bit)
						ELSE
							SET @AOnode = 0

						SET @ErrorMsg = 'UBSMWE: TLog Backup Alert (threshold ' + CAST(@dbsBakTlogConcernMins as varchar(5)) + 'mins): ' 

						DECLARE bakchk_cur CURSOR FORWARD_ONLY FOR
						SELECT DISTINCT db.name
							,MAX(bs.backup_finish_date)
						FROM master.sys.databases db 
						LEFT OUTER JOIN msdb.dbo.backupset bs WITH (NOLOCK)
							ON bs.database_name = db.name
						WHERE db.state = 0
							AND db.is_in_standby = 0
							AND db.is_read_only = 0
							AND bs.[type] = 'L'
							AND db.recovery_model_desc IN ('FULL', 'BULK_LOGGED')
							AND (CASE 
									WHEN (@dbsBakTlogConcernCVOnly = 1) AND (bs.[name] = 'CommVault Galaxy Backup') THEN 1
									ELSE 0
								END) = @dbsBakTlogConcernCVOnly
							AND db.[name] NOT IN (
								SELECT DISTINCT dbs.dbsDatabaseName
								FROM DBServices.dbo.dbsDatabase dbs
								INNER JOIN DBServices.dbo.dbsDatabaseException dbe
									ON dbe.dbsDatabaseUID = dbs.dbsDatabaseUID
								WHERE dbs.dbsDatabaseIsActive = 1
									AND dbe.dbsExceptionActive = 1
									AND LOWER(LTRIM(RTRIM(dbe.dbsDatabaseExceptionType))) = 'backup'
									AND LOWER(LTRIM(RTRIM(dbe.dbsDatabaseExceptionSubType))) = 'no_full'
								)
						GROUP BY db.[name]
						OPEN bakchk_cur

						SET @RC = 0

						FETCH NEXT FROM bakchk_cur 
						INTO @DBName, @LastTLogEndDT

						WHILE (@@FETCH_STATUS = 0)
						BEGIN
							IF @AOnode = 1
								SET @AOPrim = sys.fn_hadr_backup_is_preferred_replica(@DBName)
							ELSE
								SET @AOPrim = 1

							IF @AOPrim = 1  -- primary
								AND DATEDIFF(minute, @LastTLogEndDT, getdate()) > @dbsBakTlogConcernMins
							BEGIN
								SET @RC = @RC + 1
								
								SET @ErrorMsg = @ErrorMsg + @DBName + ',' 
							END

							FETCH NEXT FROM bakchk_cur 
							INTO @DBName, @LastTLogEndDT
						END  --------------------

						CLOSE bakchk_cur
						DEALLOCATE bakchk_cur
						
						IF @RC > 0
						BEGIN
							SET  @ErrorMsg = LEFT(@ErrorMsg, LEN(@ErrorMsg)-1) 
									+ ' => for details run: EXEC DBServices..usp_HealthChk' 
							EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning
							
							SET @SkipCnt = @SkipBy -- skip check for @SkipBy * 10 subcycles (1x subcycle = 1min) 
						END
					END
				END --------------------

				IF @debug >= 2
					PRINT '-------------------- Check CV Service --------------------'

				EXEC @RC = [DBServices].[dbo].[usp_CVKickService] 1 -- Report

				IF @RC <> 0
				BEGIN
					SET  @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine: CommVault Client services are not running; DB backups will not occur. Investigation required'
					EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning

					SET @SkipCnt = @SkipBy
				END	
			END --------------------
			ELSE
				SET @SkipCnt = @SkipCnt -1 -- Alert already occured, skip until it reaches 0
		END	
	END --------------------
	
	IF @debug >= 2
		PRINT '-------------------- Running WorkFlow job update --------------------'
	EXEC [DBServices].[dbo].usp_UBSMWE_Engine_ManageWorkFlowJobs

	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsDatabase --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsDatabase

	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsDatabaseBackup --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsDatabaseBackup

	IF @debug >= 2
		PRINT '-------------------- Running usp_UpdatedbsDatabaseBackup_Schedule --------------------'
	EXEC [DBServices].[dbo].usp_UpdatedbsDatabaseBackup_Schedule

	IF @DisableMSSQLCentral = 0
	BEGIN
		IF @debug >= 2
			PRINT '-------------------- Running msc_UpdatedbsDatabase --------------------'
		EXEC [DBServices].[dbo].msc_UpdatedbsDatabase
	END

	IF @debug >= 2
		PRINT '-------------------- Running usp_CheckNetbackupStatus --------------------'
	EXEC [DBServices].[dbo].usp_CheckNetbackupStatus

	IF @debug >= 2
		PRINT '-------------------- Running usp_BackupDatabase --------------------'
	EXEC [DBServices].[dbo].usp_BackupDatabase

	IF @debug >= 2
		PRINT '-------------------- Running usp_PurgeOldBackupFiles --------------------'
	EXEC [DBServices].[dbo].usp_PurgeOldBackupFiles

END -- Subcycle Steps DO

-------------------- Entering into delay loop --------------------

SET @MainCycleCountMinutes = @MainCycleCountMinutes - 1

-- MainCycle check:
IF CONVERT (char(5), getdate(), 8) = '00:00' -- Restart MainCycle at midnight
	OR @MainCycleCountMinutes <= 0
	GOTO StartMainCycle
ELSE
BEGIN
	-- SubCycle run:
	SET @SubCycleCnt = @SubCycleCnt + 1
	IF @SubCycleCnt >= 10
		SET @SubCycleCnt = 0

	WAITFOR DELAY '00:01'
	GOTO StartSubCycle
END

------------------------------------------------
STOPUBSMWE:

EXEC [DBServices].[dbo].usp_UpdatedbsInstanceConfig 'MSCCQProcessEnabled', @MSCCQProcessEnabled

RETURN 0

END --Main execution

GO
/****** Object:  StoredProcedure [dbo].[usp_UBSMWE_Engine_ManageWorkFlowJobs]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE PROCEDURE [dbo].[usp_UBSMWE_Engine_ManageWorkFlowJobs] (@debug  tinyint =0)
AS
/************************************************************************************************
Name: 		usp_UBSMWE_Engine_ManageWorkFlowJobs.SQL
Purpose:	Generates,adds & maintains  WorkFlow jobs from the UBSMWE Engine
              
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 16/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta

************************************************************************************************/
BEGIN -- main

SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE	@WFJobID uniqueidentifier ,
	@WFJobName nvarchar(255) ,
	@WFsysjobsJobID uniqueidentifier ,
	@WFJobDescription nvarchar(255) ,
	@WFCommand nvarchar(255),
	@WFCommandDatabase nvarchar(255),
	@WFJobStatus int,
	@WFJobStartTime varchar(8),
	@WFJobFreq varchar(50),
	@WFJobNeedsUpdate bit,
	@WFRunWorkFlowFlag bit,
	@RC tinyint,
	@ErrorMsg nvarchar(255)

--------------------	
SET @RC=0

-- See if we have any jobs that need to be created

IF EXISTS (SELECT * FROM DBServices.dbo.WorkFlowJob 
			WHERE WFsysjobsJobID IS NULL 
				OR WFJobNeedsUpdate = 1)
	OR EXISTS (SELECT * FROM DBServices.dbo.WorkFlowJob
				WHERE WFsysjobsJobID IS NOT NULL
					AND WFsysjobsJobID NOT IN (SELECT job_id FROM msdb.dbo.sysjobs) )
BEGIN --We have jobs to create

	--We do, so, now need to do the processing and get the jobs created
	IF OBJECT_ID('tempdb..#JobCurTable') IS NOT NULL 
		DROP TABLE #JobCurTable

	CREATE TABLE #JobCurTable ([WFJobID] uniqueidentifier null
		  ,[WFJobName] nvarchar(255) null
		  ,[WFsysjobsJobID] uniqueidentifier null
		  ,[WFJobDescription] varchar(255) null
		  ,[WFCommand] nvarchar(255) null
		  ,[WFCommandDatabase] nvarchar(255) null
		  ,[WFJobStatus] int null
		  ,[WFJobStartTime] varchar(8) null
		  ,[WFJobFreq] varchar(50) null
		  ,[WFJobNeedsUpdate] bit null
		  ,[WFRunWorkFlowFlag] bit null )

	INSERT INTO #JobCurTable
	SELECT [WFJobID]
		  ,[WFJobName]
		  ,[WFsysjobsJobID]
		  ,[WFJobDescription]
		  ,[WFCommand]
		  ,[WFCommandDatabase]
		  ,[WFJobStatus]
		  ,[WFJobStartTime]
		  ,[WFJobFreq]
		  ,[WFJobNeedsUpdate]
		  ,[WFRunWorkFlowFlag]
	FROM [DBServices].[dbo].[WorkFlowJob]
	WHERE WFsysjobsJobID IS NULL 
		OR WFJobNeedsUpdate = 1
		OR (WFsysjobsJobID IS NOT NULL
			AND WFsysjobsJobID NOT IN (SELECT job_id FROM msdb.dbo.sysjobs))

	DECLARE JobCursor CURSOR --READ_ONLY
	FOR SELECT [WFJobID]
			  ,[WFJobName]
			  ,[WFsysjobsJobID]
			  ,[WFJobDescription]
			  ,[WFCommand]
			  ,[WFCommandDatabase]
			  ,[WFJobStatus]
			  ,[WFJobStartTime]
			  ,[WFJobFreq]
			  ,[WFJobNeedsUpdate]
			  ,[WFRunWorkFlowFlag]
	FROM #JobCurTable
	OPEN JobCursor

	FETCH NEXT FROM JobCursor INTO @WFJobID
					  ,@WFJobName
					  ,@WFsysjobsJobID
					  ,@WFJobDescription
					  ,@WFCommand
					  ,@WFCommandDatabase
					  ,@WFJobStatus
					  ,@WFJobStartTime
					  ,@WFJobFreq
					  ,@WFJobNeedsUpdate
					  ,@WFRunWorkFlowFlag

	WHILE (@@fetch_status <> -1)
	BEGIN 
		IF (@@fetch_status <> -2)
		BEGIN
			EXEC @RC = [DBServices].[dbo].[usp_WorkFlowAddJobs] 
							   @WFJobID
							  ,@WFJobName
							  ,@WFJobDescription
							  ,@WFCommand
							  ,@WFCommandDatabase
							  ,@WFJobStatus
							  ,@WFJobStartTime
							  ,@WFJobFreq
							  ,@WFJobNeedsUpdate
							  ,@WFRunWorkFlowFlag
							  ,@WFsysjobsJobID OUTPUT

			IF (@RC <> 0)
			BEGIN
				SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_Engine_ManageWorkFlowJobs: ERROR: Failed to add WorkFlow job: ' + @WFJobName 
				EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3	-- raise an error
				
				RETURN(1) -- Failure
			END
		END

		FETCH NEXT FROM JobCursor INTO @WFJobID
						  ,@WFJobName
						  ,@WFsysjobsJobID
						  ,@WFJobDescription
						  ,@WFCommand
						  ,@WFCommandDatabase
						  ,@WFJobStatus
						  ,@WFJobStartTime
						  ,@WFJobFreq
						  ,@WFJobNeedsUpdate
						  ,@WFRunWorkFlowFlag
	END -- end of while
	CLOSE JobCursor
	DEALLOCATE JobCursor	
END  --end of We have jobs to create

IF OBJECT_ID('tempdb..#JobCurTable') IS NOT NULL 
	DROP TABLE #JobCurTable

RETURN 0

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_UBSMWE_WF_RunWorkflow]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UBSMWE_WF_RunWorkflow] @WFName nvarchar(255)
AS

/****************************************************************************************
// @File: usp_UBSMWE_WF_RunWorkflow.SQL
//
// Purpose:
//   Run all the jobs contined in the workflow
//
// Notes: This stored procedure is called from main UBSMWE. Can be run by hand if needed.
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 15/02/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Created 
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//   @Date: 13/10/2008 @Author: Kevin Wagner @Version: 2.5.4.1 @Action: Updated to prevent spin condition when Job not exists.
//   @Date: 13/10/2008 @Author: Kevin Wagner @Version: 2.5.4.1 @Action: Updated to allow for stopping the UBSMWE by setting the error level to 4.
//   @Date: 10/10/2013 @Author: Steve Trogub @Version: 5.0.8 @Action: Added File Backup execution during FULL backup forklow execution under CommVault
//   @Date: 02/06/2014 @Author: Chris Basson @Version: 5.0.11 @Action: Rewrite in order to allow for WFTask dependancies 
//   @Date: 11/07/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 Beta
//   @Date: 08/09/2014 @Author: Chris Basson @Version: 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 14/10/2014 @Author: Chris Basson @Version: 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 06/11/2014 @Author: Chris Basson @Version: 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 13/11/2014 @Author: Chris Basson @Version: 6.0.0.11 @Action: TRRv3 Beta
//   @Date: 10/12/2014 @Author: Chris Basson @Version: 6.0.0.15 @Action: TRRv3 Beta
//   @Date: 15/12/2014 @Author: Chris Basson @Version: 6.0.0.16 @Action: TRRv3 Beta
//   @Date: 12/01/2015 @Author: Chris Basson @Version: 6.0.0.20 @Action: Bugfix TRR-115
//   @Date: 26/01/2015 @Author: Chris Basson @Version: 6.0.0.22 @Action: TRR-118 Filebackup Job may exec before dumps complete 
//   @Date: 10/03/2015 @Author: Chris Basson @Version: 6.0.0.27 Bugfix: TRR-127
//   @Date: 30/06/2015 @Author: Chris Basson @Version: 6.0.0.34 Bugfix: Reduced poll sleep time
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
	,@NB_Enabled bit
	,@CV_Enabled bit
	,@dbsFSBakMinHrs tinyint
	,@FSSuccessStartDate datetime
	,@NetbackupErrorLimit int
	,@NetbackupErrorCount int
	,@NB_WindowFlag bit
	,@FSRetryCnt smallint
	,@FSRetryMax smallint
	,@dbsJobName nvarchar(255)
	,@MaxConcurrentBUFull int
	,@MaxConcurrentBULog int
	,@MaxConcurrentDBCheck int
	,@MaxConcurrentIDXReBld int
	,@MaxConcurrentIDXUpdSt int
	,@JobState int
	,@TotalTaskCount int
	,@CurrentTaskTypeName nvarchar(255)
	,@RunningTotalTaskCount int
	,@RunningMaxConcurrentTaskCount int
	,@RunningConcurrentTaskCount int
	,@WFTaskID uniqueidentifier 
	,@WFTaskName nvarchar(255) 
	,@Check_WFTaskName nvarchar(255) 
	,@WFPriority int 
	,@WFTaskPriority int 
	,@IsRunning bit 
	,@IsExecuted bit 
	,@WFTaskTypeName nvarchar(255)
	,@WFTaskTypeID tinyint
	,@WFTaskdbsDatabaseUID uniqueidentifier
	,@RunningTaskCount int
	,@SpinCheckCount int
	,@UBSMWE_Error_Status nvarchar(255)
	,@ErrorMsg nvarchar(255)
	,@dbsBackupProcessor tinyint
	,@GoodtoGO bit
	,@sqlstr nvarchar (4000)
	,@cpo bit
	,@NB_WindowStartTime char(5)
	,@FSstartdt datetime
	,@CVSCHED_disabled bit

----------------------------------------------------------------
-- WFTask dependancies table build 

IF  NOT EXISTS (SELECT * FROM DBServices.sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WorkFlowTaskDependancies]'))
BEGIN

	CREATE TABLE [DBServices].[dbo].[WorkFlowTaskDependancies](
		[WFTaskTypeID] [tinyint] NOT NULL,
		[WFTaskTypeID_Dependancy] [tinyint] NOT NULL,
	 CONSTRAINT [IX_WorkFlowTaskDependancies] UNIQUE NONCLUSTERED 
	(
		[WFTaskTypeID] ASC,
		[WFTaskTypeID_Dependancy] ASC
	)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	/*
	WFTaskTypeID	WFTaskTypeName
	1	UBSMWE_WFST_BUFull
	2	UBSMWE_WFST_BULog
	3	UBSMWE_WFST_DBCheck
	4	UBSMWE_WFST_IDXReBld
	5	UBSMWE_WFST_IDXUpdSt
	*/

	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (1,2) -- UBSMWE_WFST_BUFull - UBSMWE_WFST_BULog 
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (1,4) -- UBSMWE_WFST_BUFull - UBSMWE_WFST_IDXReBld 
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (1,3) -- UBSMWE_WFST_BUFull - UBSMWE_WFST_DBCheck 
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (1,5) -- UBSMWE_WFST_BUFull - UBSMWE_WFST_IDXUpdSt 
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (5,1) -- UBSMWE_WFST_IDXUpdSt - UBSMWE_WFST_BUFull
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (5,4) -- UBSMWE_WFST_IDXUpdSt - UBSMWE_WFST_IDXReBld
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (5,3) -- UBSMWE_WFST_IDXUpdSt - UBSMWE_WFST_DBCheck
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (3,1) -- UBSMWE_WFST_DBCheck - UBSMWE_WFST_BUFull
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (3,4) -- UBSMWE_WFST_DBCheck - UBSMWE_WFST_IDXReBld
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (3,5) -- UBSMWE_WFST_DBCheck - UBSMWE_WFST_IDXUpdSt 
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (4,1) -- UBSMWE_WFST_IDXReBld - UBSMWE_WFST_BUFull
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (4,3) -- UBSMWE_WFST_IDXReBld - UBSMWE_WFST_DBCheck
	INSERT INTO [DBServices].[dbo].[WorkFlowTaskDependancies] VALUES (4,5) -- UBSMWE_WFST_IDXReBld - UBSMWE_WFST_IDXUpdSt
	
	/*
	-- Check
	SELECT wftd.WFTaskTypeID
		, wftd.WFTaskTypeID_Dependancy
		, wftt.WFTaskTypeName AS 'WFTaskType'
		, wftt2.WFTaskTypeName AS 'WFTaskType_Dependancy'
	FROM [DBServices].[dbo].WorkFlowTaskDependancies wftd
		INNER JOIN [DBServices].[dbo].WorkFlowTaskType wftt ON wftd.WFTaskTypeID = wftt.WFTaskTypeID
		INNER JOIN [DBServices].[dbo].WorkFlowTaskType wftt2 ON  wftd.WFTaskTypeID_Dependancy = wftt2.WFTaskTypeID
	*/	
END

----------------------------------------------------------------
-- Set Vars
SET @SpinCheckCount = 0
SET @FSRetryMax = 6 -- Num of FS Backup retries 
SET @CVSCHED_disabled = 0

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 

----------------------------------------------------------------
-- Validation

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'UBSMWE_Error_Status', @UBSMWE_Error_Status OUTPUT 
IF @RC <> 0 
BEGIN
	SELECT @ErrorMsg = 'The setting for UBSMWE_Error_Status was not found in dbsInstanceConfig, please let Database Engineering know, we should never get this error in normal operation.' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3
	GOTO END_IT
END
	
IF @UBSMWE_Error_Status = 4 --4 = shutdown, no further processing
BEGIN
	PRINT 'The setting for UBSMWE_Error_Status of 4 indicates a shutdown has been requested for all UBSMWE operations. We are skipping this run of the workflow: ' + @WFName
	GOTO END_IT
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MaxConcurrentBUFull', @MaxConcurrentBUFull OUTPUT 
IF @RC <> 0 
BEGIN
	PRINT 'Setting for MaxConcurrentBUFull not found, please check UBSMWE install log for errors.'
	PRINT 'Setting to MaxConcurrentBUFull = 1 for this run.'
	SET  @MaxConcurrentBUFull = 1
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MaxConcurrentBULog', @MaxConcurrentBULog OUTPUT 
IF @RC <> 0 
BEGIN
	PRINT 'Setting for MaxConcurrentBULog not found, please check UBSMWE install log for errors.'
	PRINT 'Setting to MaxConcurrentBULog = 1 for this run.'
	SET  @MaxConcurrentBULog = 1
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MaxConcurrentDBCheck', @MaxConcurrentDBCheck OUTPUT 
IF @RC <> 0 
BEGIN
	PRINT 'Setting for MaxConcurrentDBCheck not found, please check UBSMWE install log for errors.'
	PRINT 'Setting to MaxConcurrentDBCheck = 1 for this run.'
	SET  @MaxConcurrentDBCheck = 1
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MaxConcurrentIDXReBld', @MaxConcurrentIDXReBld OUTPUT 
IF @RC <> 0 
BEGIN
	PRINT 'Setting for MaxConcurrentIDXReBld not found, please check UBSMWE install log for errors.'
	PRINT 'Setting to MaxConcurrentIDXReBld = 1 for this run.'
	SET  @MaxConcurrentIDXReBld = 1
END

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MaxConcurrentIDXUpdSt', @MaxConcurrentIDXUpdSt OUTPUT 
IF @RC <> 0 
BEGIN
	PRINT 'Setting for MaxConcurrentIDXUpdSt not found, please check UBSMWE install log for errors.'
	PRINT 'Setting to MaxConcurrentIDXUpdSt = 1 for this run.'
	SET  @MaxConcurrentIDXUpdSt = 1
END

IF @WFName = 'UBSMWE_WF_Filebackup'
	GOTO UBSMWE_WF_Filebackup

----------------------------------------------------------------
-- Backup processor specifics:

IF @dbsBackupProcessor = 4 -- CV SQL iDA local
BEGIN

	IF @WFName = 'UBSMWE_WFST_BULog'
	BEGIN
		EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Parallel_Ops', @cpo OUTPUT

		IF @cpo=0 -- EXEC CV SQLiDA TLog backups (if applicable)
			EXEC [DBServices].[dbo].[usp_CVBackup] @BackupType=1, @ALL=1 

		-- Continue to action local Tlog dumps if applicable...
	END ------------------
	ELSE
	IF @WFName = 'UBSMWE_WFST_BUFull'
	BEGIN
		-- EXEC CV SQLiDA DB backups (if applicable)
		EXEC [DBServices].[dbo].[usp_CVBackup] @ALL=1

		-- Continue to action local DB dumps if applicable...
	END
END
ELSE ------------------
IF @dbsBackupProcessor = 5 
BEGIN
	-- TRRv3 - CVScheduling
	IF @WFName = 'UBSMWE_WFST_IDXReBld' 
	BEGIN -- Disable (queue) CVScheduled backups as a pre reindex job

		SET @CVSCHED_disabled = 1

		EXEC @RC = [DBServices].[dbo].[usp_CVSubclientScheduleControl_Local] 
				@operation='CVSCHED_DISABLE'
				, @Retrymax=5
				, @PollTime=1

		IF @RC <> 0
		BEGIN
			SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_WF_RunWorkflow: An error occured whilst trying to disable/queue CV Scheduled DB backups'
							+ ' prior to task: UBSMWE_WFST_IDXReBld - continuing with Index rebuilds however performance may be severly impacted'
		    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
		END
	END
END

----------------------------------------------------------------
-- Build task list based on WF priority and WFtask priority

DECLARE @task_list TABLE (WFTaskID uniqueidentifier, 
							WFTaskName nvarchar(255), 
							WFPriority int, 
							WFTaskPriority int, 
							IsRunning bit, 
							IsExecuted bit, 
							WFTaskTypeName nvarchar(255), 
							WFTaskTypeID tinyint,
							WFTaskdbsDatabaseUID uniqueidentifier,
							UNIQUE NONCLUSTERED ([WFTaskID] ASC))

------------------
	
INSERT INTO @task_list (WFTaskID, WFTaskName, WFPriority, WFTaskPriority
	, IsRunning, IsExecuted, WFTaskTypeName, WFTaskTypeID, WFTaskdbsDatabaseUID) 
(SELECT DISTINCT wft.WFTaskID
	,wft.WFTaskName
	,wf.WFPriority
	,wft.WFTaskPriority
	,0 AS 'IsRunning'
	,0 AS 'IsExecuted'
	,wftt.WFTaskTypeName
	,wft.WFTaskTypeID
	,wft.dbsDatabaseUID

FROM [DBServices].[dbo].WorkFlow wf
INNER JOIN [DBServices].[dbo].WorkFlowManifest wfm
	ON wf.WFID = wfm.WFID
INNER JOIN [DBServices].[dbo].WorkFlowTask wft
	ON wfm.WFTaskID = wft.WFTaskID
INNER JOIN [DBServices].[dbo].[dbsDatabase] db
	ON db.dbsDatabaseUID = wft.dbsDatabaseUID
LEFT OUTER JOIN [DBServices].[dbo].WorkFlowTaskType wftt
	ON wft.WFTaskTypeID = wftt.WFTaskTypeID
LEFT OUTER JOIN [DBServices].[dbo].WorkFlowTaskException wfte
	ON wft.WFTaskID = wfte.WFTaskID 
LEFT OUTER JOIN [DBServices].[dbo].WorkFlowException wfe
	ON wf.WFID = wfe.WFID 

WHERE db.dbsDatabaseIsActive = 1
	AND (wfm.WFManifestEnabled = 1) 
	AND ((wfte.WFTaskExceptionExists = 0) OR (wfte.WFTaskExceptionExists IS NULL))
	AND ((wfe.WFExceptionExists = 0) OR (wfe.WFExceptionExists IS NULL))
	AND (wf.WFName = @WFName) 
	AND (wft.WFTaskEnabled = 1) )							

----------------------------------------------------------------
-- Process tasks

SELECT @TotalTaskCount = COUNT(*)
FROM @task_list

IF @TotalTaskCount = 0
BEGIN
	PRINT CAST(GETDATE() as char(19)) + '(LT) UBSMWE WF: ' + @WFName + ' Nothing to do, exiting procedure'
	GOTO END_OK
END
ELSE
BEGIN --Processing
 
	PRINT CAST(GETDATE() as char(19)) + '(LT) UBSMWE WF: ' + @WFName + ': Total number of WF Tasks to process: ' + CAST(@TotalTaskCount as varchar(3))

	-- Process tasks
	WHILE EXISTS (SELECT TOP 1 WFTaskID 
				FROM @task_list
				WHERE IsExecuted = 0 OR IsRunning = 1) -- while 1
	BEGIN 
		-- WFTasks - DO		
		DECLARE RunningTaskList_cur CURSOR LOCAL DYNAMIC
		FOR SELECT WFTaskID
			, WFTaskName
			, WFPriority
			, WFTaskPriority
			, IsRunning
			, IsExecuted
			, WFTaskTypeName
			, WFTaskTypeID
			, WFTaskdbsDatabaseUID
		FROM @task_list
		WHERE IsExecuted = 0 --All tasks that have not been processed yet
			OR IsRunning = 1 --All tasks that are still being processed and not completed yet
		ORDER BY WFTaskPriority DESC 
		FOR UPDATE
		
		OPEN RunningTaskList_cur

		FETCH NEXT FROM RunningTaskList_cur
			INTO @WFTaskID, @WFTaskName, @WFPriority, @WFTaskPriority, @IsRunning
				, @IsExecuted, @WFTaskTypeName, @WFTaskTypeID, @WFTaskdbsDatabaseUID
	
		WHILE (@@FETCH_STATUS <> -1) -- while 2
		BEGIN
			SET @ErrorMsg = NULL

			SELECT @RunningConcurrentTaskCount = COUNT(*) 
			FROM @task_list 
			WHERE IsRunning = 1 
				AND WFTaskTypeID = @WFTaskTypeID

			IF (@@FETCH_STATUS <> -2)
			BEGIN
				-- Determine if a WFTask can be executed based on @RunningConcurrentTaskCount

				IF (@IsRunning = 0 AND @IsExecuted = 0) AND (CASE 
						WHEN (@WFTaskTypeName = 'UBSMWE_WFST_BUFull' AND @RunningConcurrentTaskCount < @MaxConcurrentBUFull) THEN 1
						WHEN (@WFTaskTypeName = 'UBSMWE_WFST_BULog' AND @RunningConcurrentTaskCount < @MaxConcurrentBULog) THEN 1 
						WHEN (@WFTaskTypeName = 'UBSMWE_WFST_DBCheck' AND @RunningConcurrentTaskCount < @MaxConcurrentDBCheck) THEN 1
						WHEN (@WFTaskTypeName = 'UBSMWE_WFST_IDXReBld' AND @RunningConcurrentTaskCount < @MaxConcurrentIDXReBld) THEN 1 
						WHEN (@WFTaskTypeName = 'UBSMWE_WFST_IDXUpdSt' AND @RunningConcurrentTaskCount < @MaxConcurrentIDXUpdSt) THEN 1
						WHEN (@RunningConcurrentTaskCount < 1) THEN 1
						ELSE 0 
					END = 1) 
					
				BEGIN --Start new task and update info in table
				
					SET @JobState = NULL
					SET @GoodtoGO = 1
					
					------------------------------------
					-- Verify if any dependant (conflicting) jobs are running
					DECLARE Verify_Dependancies_state_cur CURSOR LOCAL FORWARD_ONLY STATIC 
					FOR SELECT DISTINCT wft.WFTaskName
					FROM [DBServices].[dbo].WorkFlowTask wft
					WHERE wft.dbsDatabaseUID = @WFTaskdbsDatabaseUID
						AND wft.WFTaskEnabled = 1
						AND wft.WFTaskName <> @WFTaskName
						AND wft.WFTaskTypeID IN 
							(SELECT DISTINCT [WFTaskTypeID_Dependancy]
							FROM [DBServices].[dbo].[WorkFlowTaskDependancies]
							WHERE WFTaskTypeID = @WFTaskTypeID)

					OPEN Verify_Dependancies_state_cur

					FETCH NEXT FROM Verify_Dependancies_state_cur INTO @Check_WFTaskName
					WHILE (@@FETCH_STATUS = 0) -- while 3
					BEGIN
						-- Determine WFTask job state
						EXEC @JobState = [DBServices].[dbo].usp_GetJobState @Check_WFTaskName
						/*
							@JobState=
							-1 - Job not found
							0 = Not idle or suspended, 
							1 = Executing, 
							2 = Waiting For Thread, 
							3 = Between Retries, 
							4 = Idle, 
							5 = Suspended, 
							6 = WaitingForStepToFinish, 
							7 = PerformingCompletionActions 
						*/					
						IF @JobState NOT IN (4,-1)
						BEGIN
							PRINT CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName 
								+ ': identified dependancy for task ' + @Check_WFTaskName + ' to complete' 
							SET @GoodtoGO =0
						END	
						
						FETCH NEXT FROM Verify_Dependancies_state_cur INTO @Check_WFTaskName
					END --end of while 3
					CLOSE Verify_Dependancies_state_cur
					DEALLOCATE Verify_Dependancies_state_cur

					------------------------------------
					EXEC @JobState = [DBServices].[dbo].usp_GetJobState @WFTaskName

					IF @GoodtoGO = 1 AND @JobState = 4
					BEGIN --OK kick off the job 
						PRINT CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName + ' initiating....'
						
						-- No WF job dependant jobs exist - Good to start the WFTask								
						EXEC @RC = msdb.dbo.sp_start_job @job_name = @WFTaskName
						IF @RC <> 0 
						BEGIN
							PRINT CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName 
								+ ' failed to start execution; investigation required'
							
							-- Mark as actioned							
							UPDATE @task_list
							SET IsRunning = 0, IsExecuted = 1
							WHERE CURRENT OF RunningTaskList_cur
						END ------------------
						ELSE
						BEGIN
							WAITFOR DELAY '00:00:01'
							
							-- Job kicked off OK; mark as running
							UPDATE @task_list
							SET IsRunning = 1, IsExecuted = 1
							WHERE CURRENT OF RunningTaskList_cur
						END ------------------
					END ------------------
					ELSE 
					IF @GoodtoGO = 0
						AND @JobState = 4
					BEGIN
						-- Dependant (conflicting) jobs are running - skip
						PRINT CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName
							+ ' pending on dependant (conflicting) jobs to complete:'
						
						SELECT DISTINCT wft.WFTaskName
						FROM [DBServices].[dbo].WorkFlowTask wft
						WHERE wft.dbsDatabaseUID = @WFTaskdbsDatabaseUID
							AND wft.WFTaskEnabled = 1
							AND wft.WFTaskName <> @WFTaskName
							AND wft.WFTaskTypeID IN 
								(SELECT DISTINCT [WFTaskTypeID_Dependancy]
								FROM [DBServices].[dbo].[WorkFlowTaskDependancies]
								WHERE WFTaskTypeID = @WFTaskTypeID)
					END ------------------
					ELSE 
					BEGIN 
						-- Then an issue with the WFTask job
						SET @ErrorMsg = CASE @JobState 
								WHEN 0 THEN CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName + ' failed; investigation required'
								WHEN 5 THEN CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName + ' user canceled'
								WHEN -1 THEN CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName + ' not found - skipping; investigation required' --This is to get around the Spin error encountered when job not exists.
							ELSE
								CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName
									 + ' skipping as the WFjob is not in an IDLE state'
							END	
						
						PRINT @ErrorMsg
						
						-- Mark as actioned
						UPDATE @task_list
						SET IsRunning = 0, IsExecuted = 1
						WHERE CURRENT OF RunningTaskList_cur
					END ------------------
				END -- end of: Start new task and update task table with status
					------------------
				ELSE
				IF @IsRunning = 1
					AND @IsExecuted = 1
				BEGIN
					-- Verifiy executed WFTask job running status
					
					WAITFOR DELAY '00:00:00:400'
					EXEC @JobState = [DBServices].[dbo].usp_GetJobState @WFTaskName	
					/*
						@JobState=
						-1 - Job not found
						0 = Not idle or suspended, 
						1 = Executing, 
						2 = Waiting For Thread, 
						3 = Between Retries, 
						4 = Idle, 
						5 = Suspended, 
						6 = WaitingForStepToFinish, 
						7 = PerformingCompletionActions 
					*/

					IF @JobState = 4 
					BEGIN	-- WFTask job has completed, mark accordingly
						PRINT CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName 
							+ ' Completed'

						-- Mark as actioned						
						UPDATE @task_list
						SET IsRunning = 0, IsExecuted = 1
						WHERE CURRENT OF RunningTaskList_cur
					END ------------------
					ELSE 
					BEGIN  
						IF @JobState IN (-1,0,5)
						BEGIN
							--  issue with the WFTask job
							SET @ErrorMsg = CASE @JobState 
									WHEN 0 THEN CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName
										+ ' failed; investigation required'
									WHEN 5 THEN CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName 
										+ ' user canceled'
									WHEN -1 THEN CAST (getdate() as char(19)) + '(LT) UBSMWE WF Task: ' + @WFTaskName
										+ ' not found - skipping; investigation required' --This is to get around the Spin error encountered when job not exists.
								END				
						
							PRINT @ErrorMsg
							
							-- Mark as actioned
							UPDATE @task_list
							SET IsRunning = 0, IsExecuted = 1
							WHERE CURRENT OF RunningTaskList_cur
							
							GOTO END_IT
						END 
						-- ELSE WFTask is still running - let it be ie. IsRunning = 1, IsExecuted = 1
					END ------------------
				END
			END
			
			-- NOTE: @IsRunning = 0 AND @IsExecuted = 1 skip, @IsRunning = 1 AND @IsExecuted = 0 should not occur

			FETCH NEXT FROM RunningTaskList_cur
			INTO @WFTaskID, @WFTaskName, @WFPriority, @WFTaskPriority, @IsRunning
				, @IsExecuted, @WFTaskTypeName, @WFTaskTypeID, @WFTaskdbsDatabaseUID
		END --end of while 2

		CLOSE RunningTaskList_cur
		DEALLOCATE RunningTaskList_cur

		IF EXISTS (SELECT 1
			FROM @task_list
			WHERE IsExecuted = 0 OR IsRunning = 1)
		BEGIN
			-- Wait 5 seconds before polling
			WAITFOR DELAY '00:00:05'
			CONTINUE
		END
		ELSE
			BREAK
	END --end of while 1 
END --Processing

-------------------------------------------------
END_OK:

-- TRR special cases

IF @dbsBackupProcessor = 5 
BEGIN
	-- TRRv3 - CVScheduling
	IF @WFName = 'UBSMWE_WFST_IDXReBld' 
		AND @CVSCHED_disabled = 1
	BEGIN -- Re-enable CVScheduled backups post reindex WF
		EXEC @RC = [DBServices].[dbo].[usp_CVSubclientScheduleControl_Local] @operation='CVSCHED_ENABLE'

		RETURN (@RC)
	END
END

-------------------------------------------------
--FileSystem backup integration

UBSMWE_WF_Filebackup:

IF (@CV_Enabled = 1 OR @NB_Enabled = 1)
	AND @WFName = 'UBSMWE_WFST_BUFull'
		OR @WFName = 'UBSMWE_WF_Filebackup'
BEGIN -- FS Backup

	SET @FSRetryCnt = 0
	SET @GoodtoGO = 0
	
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsFSBakMinHrs',  @dbsFSBakMinHrs OUTPUT 
	IF @RC <> 0 
		SET @dbsFSBakMinHrs = 11
		
	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorLimit',  @NetbackupErrorLimit OUTPUT 
	IF @RC<> 0 
		SET @NetbackupErrorLimit = 3

	EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorCount',  @NetbackupErrorCount OUTPUT 
	IF @RC <> 0 
	BEGIN
		EXEC @RC = [DBServices].[dbo].[usp_ConfigureUBSMWE] 'NetbackupErrorCount',  0
		SET @NetbackupErrorCount = 0
	END
	
	SELECT TOP 1 @FSSuccessStartDate = dbsNetbackupRequestStartDate
	FROM [DBServices].[dbo].[dbsNetbackup]
	WHERE LOWER(dbsNetbackupExitStatus) LIKE '%success%'
	ORDER BY dbsNetbackupID DESC
		
	----------------------------------
	-- Determine if FS Back can run
	
	WHILE @FSRetryCnt <= @FSRetryMax
		AND @NetbackupErrorCount <= @NetbackupErrorLimit
	BEGIN
		
		----------------------------------
		-- TRR-118: Filebackup Job may exec before dumps complete 
		IF EXISTS (SELECT 1 
					FROM [DBServices].[dbo].WorkFlowTask wft
					WHERE wft.WFTaskIsRunningFlag = 1
						AND wft.WFTaskTypeID = 1) -- UBSMWE_WFST_BUFull jobs still running 
			AND (@FSRetryCnt < (@FSRetryMax -2)) -- cant wait forever - just try and proceed 
			GOTO RETRY_FS_BAK -- wait

		----------------------------------
		-- Determine if there are FS dumps to backup

		SELECT @GoodtoGO = 1
		FROM [DBServices].[dbo].dbsDatabase db
		INNER JOIN	[DBServices].[dbo].dbsDatabaseBackup dbb
			ON dbb.dbsDatabaseUID = db.dbsDatabaseUID
		INNER JOIN [DBServices].[dbo].dbsDatabaseBackupHistory dbh
			ON dbh.dbsDatabaseUID = db.dbsDatabaseUID
		WHERE (dbh.dbsDBHIsOnDiskFlag = 1) 
			AND (ISNULL(dbh.dbsDBHSentToNBFlag, 0) = 0) 
			AND	(dbb.dbsDBExternalBackupFlag = 1 
				OR (dbb.dbsDBExternalBackupFlag = 0 AND (ISNULL(dbb.dbsDBDoFullBackupNow, 0) = 0)) ) 
			AND	(ISNULL(dbb.dbsDBIsInFullBackupProcess, 0) = 0)

		SET @GoodtoGO = ISNULL(@GoodtoGO, 0)
		
		IF @GoodtoGO = 0
			RETURN (0) -- nothing to do - exit success!
		ELSE ----------------------------------
		BEGIN
			-- FS dumps to backup
			
			IF (@NetbackupErrorCount = 0
					AND (@FSSuccessStartDate IS NULL 
						OR @FSSuccessStartDate <= DATEADD(hh, - @dbsFSBakMinHrs, getdate()) )
				) -- something new to do and a successful FS backup has not run for at least dbsFSBakMinHrs
				OR
				(@NetbackupErrorCount > 0
					AND @NetbackupErrorCount <= @NetbackupErrorLimit
				)
			BEGIN
				-- Ensure the FS backup window is open
				EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_WindowFlag', @NB_WindowFlag OUTPUT 
				
				IF @RC = 0 
					AND @NB_WindowFlag = 0 -- FS backup window is closed
				BEGIN
					EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_WindowStartTime', @NB_WindowStartTime OUTPUT 
					
					IF @RC = 0 
						AND ISDATE (@NB_WindowStartTime) = 1 
					BEGIN
						SET @FSstartdt = DBServices.dbo.ufn_ParseMWETime (@NB_WindowStartTime)

						IF DATEDIFF (minute, getdate(), @FSstartdt) <= 0
							SET @FSstartdt = DATEADD(day, 1, @FSstartdt)

						SET @FSstartdt = DATEADD(minute, 5, @FSstartdt) -- Wait for an additional 5 mins to allow for NB_WindowFlag updates 

						PRINT 'FS backup window closed - will retry at: ' + CAST (@FSstartdt as char(19)) + '(LT)'

						WAITFOR TIME @FSstartdt
					END
					ELSE
					BEGIN
						SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_WF_RunWorkflow: Unable to initiate job UBSMWE_WF_Filebackup - please verify value of dbsInstanceConfig: NB_WindowStartTime'
						EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
						
						RETURN (0) -- exit success as main DB dumps would have completed successfully 
					END
				END
				
				----------------------------------
				-- Kick off the Filesystem backup job
				SET @dbsJobName = 'UBSMWE_WF_Filebackup'  

				EXEC @JobState = [DBServices].[dbo].usp_GetJobState @dbsJobName
				
				IF @JobState = 4 --Only execute if filebackup job is idle
				BEGIN
					PRINT 'Initiating UBSMWE_WF_Filebackup job' 
					EXEC @RC = msdb.dbo.sp_start_job @job_name = @dbsJobName
					
					IF @RC = 0
						RETURN (0) -- Successfully started FS backup job
				END  -----------------
				ELSE
					PRINT 'Backup jobs are not idle...'
			END -----------------
			ELSE
				RETURN (0) -- Conditions not met - exit success as main DB dumps would have completed successfully
		END
		
		-----------------
		RETRY_FS_BAK:
		
		SET @FSRetryCnt = @FSRetryCnt + 1	

		PRINT '=> FS Backup conditions not met - will retry in 10 mins (' 
				+ CAST(@FSRetryCnt as varchar(3))
				+ '/' + CAST(@FSRetryMax as varchar(3)) + ')'
 
		WAITFOR DELAY '00:10' -- Wait for 10 mins
		
		EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NetbackupErrorCount',  @NetbackupErrorCount OUTPUT 
	END -- loop ---------------
	
	IF @GoodtoGO = 1
		AND (@FSRetryCnt > @FSRetryMax
			OR @NetbackupErrorCount > @NetbackupErrorLimit)
	BEGIN
		SET @ErrorMsg = 'UBSMWE: usp_UBSMWE_WF_RunWorkflow: Unable to initiate job UBSMWE_WF_Filebackup - investigation required'
	    EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
	END
END

RETURN (0) -- exit success

-------------------------------------
END_IT:

IF @dbsBackupProcessor = 5 
	AND @WFName = 'UBSMWE_WFST_IDXReBld'
	AND @CVSCHED_disabled = 1
BEGIN
	-- TRRv3 - CVScheduling  
	-- Ensure CVScheduled backups are re-enabled if reindex WF

	EXEC @RC = [DBServices].[dbo].[usp_CVSubclientScheduleControl_Local] @operation='CVSCHED_ENABLE'
END

RETURN (1)

END --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UBSMWE_WFST_DBChek_JobRun]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UBSMWE_WFST_DBChek_JobRun]
		@DatabaseName nvarchar(128),
		@dbsWITH_PHYSICAL_ONLY_override bit = 0  -- ST : WITH_PHYSICAL_ONLY OVERRIDE
AS 

/*****************************************************************************************************
//   Name:         usp_UBSMWE_WFST_DBChek_JobRun
//   Author:       Kevin Wagner
//   Date Created: 24/02/2008
//   Purpose:      Runs DBCC checkdb against database name passed in as param.
//   
//   Modification History:
//   @Date: 03/08/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 05/07/2011 @Author: Steve Trogub @Version: UBSMWE 4.0.1 @Action: Run CHECKDB using the WITH PHYSICAL_ONLY user configurable option
//   @Date: 04/18/2012 @Author: Steve Trogub @Version: UBSMWE 4.0.1 @Action: added  @dbsWITH_PHYSICAL_ONLY_override paramter as user configurable option
//   @Date: 30/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.7 @Action: TRRv3 Beta 

****************************************************************************************************/
BEGIN -- main

SET NOCOUNT ON --Allow for computed columns and local db settings to stop errors
SET ARITHABORT ON
SET DATEFORMAT ymd

DECLARE @ErrorMsg varchar(255)
		, @SQL nvarchar(500)
		, @debug tinyint
		, @RC int
		, @dbsWITH_PHYSICAL_ONLY bit
		
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'WITH_PHYSICAL_ONLY', @dbsWITH_PHYSICAL_ONLY OUTPUT
IF @RC <> 0
	PRINT 'Error while getting output param for WITH_PHYSICAL_ONLY'

IF @dbsWITH_PHYSICAL_ONLY_override = 1
	SET @dbsWITH_PHYSICAL_ONLY = 1

PRINT CONVERT (VARCHAR, GETDATE(), 113) + ' - Start of DBCC CHECKDB for database ' + @DatabaseName

SET @SQL = 'DBCC CHECKDB ([' + @DatabaseName +'])'

IF @dbsWITH_PHYSICAL_ONLY = 1 
	SET @SQL = @SQL + ' WITH PHYSICAL_ONLY'

PRINT @SQL
EXEC (@SQL)

SET @RC = @@ERROR
IF @RC <> 0
BEGIN
	SET @ErrorMsg = 'DBCC CHECKDB failed for ' + @DatabaseName 

	EXEC [DBServices].[dbo].[usp_LogErrors] 
		@command = 'usp_UBSMWE_WFST_DBChek_JobRun'
		, @message = @ErrorMsg
		, @LogEvent = 1
		, @Level = 3
END

PRINT CONVERT (VARCHAR, GETDATE(), 113) + ' - End of CHECKDB for database ' + @DatabaseName

RETURN @RC

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_UBSMWE_WFST_IDXReBld_JobRun]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UBSMWE_WFST_IDXReBld_JobRun] 
		@DatabaseName		nvarchar(128),
		@InxDefragtyp       varchar(20) = 'REBUILD', -- default 'REBUILD', option: 'REORGANIZE'
		@FailoverToReorg    bit = 1, -- default 1 - fail over to reorg
		@MaxTransLogPct     int = 60,  -- picked up from dbsInstanceConfig 
		@retrymax			tinyint	= 0,	-- default 0 (disabled) will retry upto n times		
		@retrydelay			char(5) = '00:01', -- default 1min - format 'hh:mm'
		@deadline			char(5) = NULL, -- default NULL no deadline - format 'hh:mm'
		@online				bit = 0, -- specify 1 for REBUILD WITH ONLINE 
		@disableFalerts		bit = 0, -- specify 1 to disable alerting for failed index rebuilds - !use with caution!
		@TblLockCheck		bit = 0, -- specify 1 to enable check for table lock with skip (@retrymax = 0) or retry (@retrymax > 0)
		@SortinTempDB		bit = 0, -- specify 1 to sort in tempdb 
		@Override			bit = 0 -- Specify 1 to override values in the dbsInstanceConfig table
AS 

/*****************************************************************************************************
//   Name:         usp_UBSMWE_WFST_IDXReBld_JobRun
//   Author:       Rakesh Bist
//   
//   Date Created:		24/04/2006
//   
//   Purpose:      Defrag Indexes for all indexes in the database. Index rebuild is on a table if 
//                             fragmentation is greater than 10 percent (default).
//                             Procedure takes four parameters, they are optional.
//                             - @DatabaseName (Database Name)
//                             - @InxDefragtyp (Index Rebuild options: REBUILD or REORGANIZE)
//                             - @FailoverToReorg (1 = Attempt index REORGANIZE if not enough space to REBUILD a fragmented index)
//                             - @MaxTransLogPct (If transaction log used% more than this then exit this proc)
//                             - @retrymax (If TLog > @MaxTransLogPct, retry in @retrydelay (format 'hh:mm') upto @retrymax times)
//                             - @retrydelay (If TLog > @MaxTransLogPct, retry in @retrydelay (format 'hh:mm') upto @retrymax times)
//                             - @deadline (format 'hh:mm' procedure will end - default NULL no deadline)
//                             - @online (default 0, 1 for REBUILD WITH ONLINE)
//                             - @disableFalerts (default 0, 1 to disable alerting for failed index rebuilds - use with caution!)
//                             - @TblLockCheck (default 0, 1 to enable a check for table locking. If locked; @retrymax = 0 will skip the index
//                               Retry supported if @retrymax > 0)
								- @Override when set the sps user input parameters override the values stored in the dbsInstanceConfig table
Modification History:

Version  Name                Date        Notes
//   @Date: 16/10/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0.6 @Action: Fixed bug with space in the name of databases and objects, will 
//                                                                  not operate on databases not at compat level of 2005,  will 
//                                                                  no longer select system supplied objects.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 25/02/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Major overhaul, changed for one database at a time.
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 24/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4 @Action: Updated for Reindex issue
//   @Date: 03/06/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4 @Action: Updated for Bug# 48
//   @Date: 06/10/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated for Bug# 56
//
//   @Date: 11/11/2009 @Author: Paul Davies @Version: GPA Specific version based on 2.5.4.1
//                1. The indexes to be defragged are now processed in ascending size order rather than the previous alphabetic order.
//                2. When using the REBUILD option, we now check available disk space before attempting perform the index REBUILD.
//                   This is to avoid wasting time trying to rebuild an index when disk space is not available to complete the operation.
//                3. The @FailoverToReorg parameter has been added to allow an attempt to REORGANIZE an index if space is insufficient for a REBUILD.
//                4. A Try/Catch error trap has been implemented to trap a failed REBUILD/REORGANIZE operation and continue with subsequent indexes
//                   instead of terminating the remaining reindexing for the current database.
//                5. Status information has been added to the DBServices dbsIndexDFRG table to allow easier tracking of
//                   which reindexing actions succeeded/failed or were not attempted, and at what times.
//
//   @Date: 30/11/2009 @Author: Paul Davies @Version: GPA Specific version based on 2.5.4.1
//         Any existing stats for the passed-in database are now cleared-down from the dbsIndexDFRG table prior to a new set 
//         of stats being created.
//
//   @Date: 13/01/2010 @Author: Paul Davies @Version: GPA Specific version based on 2.5.4.1
//                1.        sys.dm_db_index_physical_stats results further filtered on alloc_unit_type_desc = 'IN_ROW_DATA'
//                        to avoid LOB_DATA & ROW_OVERFLOW_DATA creating multiple rows for the same index/partition.
//                2.        If @MaxTransLogPct value supplied then T-Log space checked BEFORE each individual reindex op.
//                        If log% > @MaxTransLogPct then all further reindexing operations on the current dbase are terminated.
//                        This is to guard against ReIndexing operations completely filling-up the transaction log.
//
//   @Date: 22/03/2010 @Author: Julian Sadotti @Version: GPA Specific version based on 2.5.4.1
//                1.        Insert existing compression type desc per partition via sys.partitions into DBServices.dbo.dbsIndexDFRG
//                        (New supporting column added to DBServices.dbo.dbsIndexDFRG accordingly)
//                2.        Modified index 'Rebuild' dynamic script generation to include existing compression type
//                3.        Modified index 'Reorg' dynamic script generation to remove compression type references
//                        (not reorg applicable)
//   @Date: 23/03/2010 @Author: Julian Sadotti @Version: GPA Specific version based on 2.5.4.1
//                        Fixed the compression modifications to allow the proc to be run for REORGANISE param value
//                        instead of REBUILD. Achieved through use of a case statement when building the dynamic sql
//
//   @Date: 23/07/2010 @Author: Steve Trogub @Version: 2.5.4.3
//                        hardcoded @MaxTransLogPct int = 60 so that the job does not have to be modifed by end users.
//                        60% would be a global setting.
//
//   @Date: 04/07/2011 @Author: Paul Davies @Version: 2.5.4.1
//                        BUG FIX to the query which populates the #DBase_Index_Space_Stats table.
//                        Query amended to get space stats data for alloc_unit_type_desc = 'IN_ROW_DATA' only
//                        as per earlier fixes to the sys.dm_db_index_physical_stats querying.
//                        This avoids the code using the wrong space stats for the given index and
//                        possibly attempting a reindex when sufficient filegroup space is not actually available.
//
//    @Date: 01/03/2013 @Author: Steve Trogub @Version: 5.0.4 @action: Bug fixes
//
//    @Date 17/7/2012 @Author: Andrew Calvett @action: Implemented method to gather index stats from a list of tables that exludes heaps with no indexes
//						rather than cycle through all tables as large multi TB warehouses commonly only have heaps and checking them can be a 
//						significant waste of resources. Implemented via exception table, ExceptionType 'maintenance' and ExceptionSubType = 'warehouse_indexrebuild'
//    @Date: 25/10/2013 @Author: Steve Trogub @Version: 5.0.8
							@action: removed MAXDOP and With Compression for for when REROGANIZE option is used
//    @Date: 28/10/2013 @Author: Chris Basson @Version: 5.0.8
//							Added retry for @retrydelay, @retrymax times if DB Tlog usage > @MaxTransLogPct
//    @Date: 20/02/2014 @Author: Chris Basson @Version: 5.0.9
//							Added @online for REBUILD WITH ONLINE = ON. Default 0 (WITH ONLINE = OFF). Note: XML or spatial index; only ONLINE = OFF is supported 
//    @Date: 17/03/2014 @Author: Chris Basson @Version: 5.0.9.1
//							Bugfix: dbsIndexDFRG entry for idx failures. Added option to disable alerts for failed indexes. Fixed bug MAXDOP error when failing over to REORGANIZE 
//    @Date: 07/04/2014 @Author: Chris Basson @Version: 5.0.9.2
//							Bugfix: Empty with statement when failing over to REORGANIZE  
//    @Date: 28/05/2014 @Author: Chris Basson @Version: 5.0.9.3
//							Bugfix: partitioned table performance issue (Andrew Calvett), Error msg update, New func: Check for table lock with skip or retry
//    @Date: 18/07/2014 @Author: Chris Basson @Version: 6.0.0 TRRv3 Beta
//    @Date: 10/11/2014 @Author: Chris Basson @Version: 6.0.0.10 TRRv3 Beta
//    @Date: 15/01/2015 @Author: Chris Basson @Version: 6.0.0.21 JIRA: MSSQL-622
//    @Date: 29/06/2015 @Author: Chris Basson @Version: 6.0.0.33 minor fix case reorganize option disabled
//    @Date: 30/11/2015 @Author: Chris Basson @Version: 6.0.0.40 Added MAXDOP to dbsIndexDFRG build queries

****************************************************************************************************/
BEGIN -- Main

SET DATEFORMAT ymd
SET NOCOUNT ON
SET NUMERIC_ROUNDABORT OFF
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @i int
	,@objectid int
	,@objectname nvarchar(255)
	,@IndexId int
	,@partitioncount bigint
	,@schemaname sysname
	,@Indexname sysname
	,@partitions bigint
	,@frag float
	,@pagecount bigint
	,@SQLStrMain nvarchar (4000)
	,@SQLStr nvarchar(4000)
	,@rtn int
	,@debug nvarchar(2)
	,@errmsg nvarchar(255)
	,@permdef nvarchar(500)
	,@IndexFragmentationLimitPercent int
	,@MAXDOP int
	,@partition_number int
	,@DB_ID int
	,@UsedPagesMB numeric(12,2)
	,@FGAvailSpaceInMB numeric(12,2)
	,@SkipIndex bit
	,@LogUsedPct decimal(18,5)
	,@CompressDesc varchar(60)
	,@MajorVersion int
	,@exceptionNum int
	,@DatabaseUID uniqueidentifier
	,@ErrorText varchar(4000)
	,@retrycnt tinyint
	,@resource_type nvarchar(120)
	,@astr varchar(255)
	,@RC int
	,@FinalRC int
	,@idx_datatypeid int

DECLARE @TLogsUsedPct TABLE	(
        DbaseName sysname
		,LogSize numeric(18,5)
		,LogUsed numeric(18,5)
		,StatusBit int 
	)
	
------------------------------------------------------------------------------------------
-- Init vars
			
SET @MajorVersion = [DBServices].[dbo].[ufn_InstanceMajorVersion] ()  
SET @retrycnt =0
SET @FinalRC = 0

SELECT @DatabaseUID = dbsD.[dbsDatabaseUID]            
FROM [DBServices].[dbo].[dbsDatabase] dbsD
INNER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbsDB
	ON dbsD.[dbsDatabaseUID] = dbsDB.[dbsDatabaseUID]
WHERE dbsD.dbsDatabaseName = @DatabaseName
	AND dbsD.dbsDatabaseIsActive = 1

IF @DatabaseUID IS NULL
BEGIN
	SET @ErrorText = 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: ' + @DatabaseName
		 + ' is deemed offline or missing - exiting without action.'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 3
	
	SET @FinalRC = 1
    GOTO Exit_Sproc
END

-- PD : dbsIndexDFRG is now a permanent table located in the DBServices database
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'DBServices.dbo.dbsIndexDFRG') AND type in (N'U'))
BEGIN
	SET @ErrorText = 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: DBServices.dbo.dbsIndexDFRG table does not exist. Procedure will exit without action.'
  	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 2

	SET @FinalRC = 1
    GOTO Exit_Sproc
END
ELSE 	-- Cleardown any previous frag stats for the passed-in database
	DELETE FROM DBServices.dbo.dbsIndexDFRG
	WHERE dbsDatabaseName = @DatabaseName

SET @InxDefragtyp = LTRIM(RTRIM(@InxDefragtyp))
IF @InxDefragtyp NOT IN ('REBUILD', 'REORGANIZE')
BEGIN
	PRINT 'Invalid input parameter for @InxDefragtyp: ' + @InxDefragtyp 
		+ ' value must either be REBUILD or REORGANIZE'

	SET @FinalRC = 1
	GOTO Exit_Sproc	
END

------------------------------------------------------------------------
-- Verifiy params

IF EXISTS (SELECT 1 
		FROM dbsInstanceConfig
		WHERE dbsInstanceConfigName = 'MaxTransLogPct')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MaxTransLogPct', @astr OUTPUT
	PRINT 'MaxTransLogPct = ' + @astr
	SET @MaxTransLogPct = CAST (@astr as int)
END

IF @MaxTransLogPct NOT BETWEEN 30 AND 100
BEGIN
	PRINT 'Incorrect configuration parameter MaxTransLogPct: ' + CAST (@MaxTransLogPct as varchar(3)) 
		+ ' value must between 30 and 100 - exiting'
	SET @FinalRC = 1
	GOTO Exit_Sproc	
END

IF EXISTS (SELECT 1
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexTblLockCheck')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexTblLockCheck', @astr OUTPUT
	PRINT 'IndexTblLockCheck = ' + @astr
	SET @TblLockCheck = CAST (@astr as bit)
END

IF EXISTS (SELECT 1
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexFailovertoREORG')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexFailovertoREORG', @astr OUTPUT
	PRINT 'IndexFailovertoREORG = ' + @astr
	SET @FailoverToReorg = CAST (@astr as bit)
END

IF EXISTS (SELECT 1
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexRetryDelay')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexRetryDelay', @astr OUTPUT
	PRINT 'IndexRetryDelay = ' + @astr
	SET @retrydelay = @astr
END

SET @retrydelay = LTRIM(RTRIM(@retrydelay))
IF ISDATE(@retrydelay) = 0
BEGIN
	PRINT 'Incorrect configuration parameter IndexRetryDelay: ' + @retrydelay 
		+ ' value must of format hh:mm - exiting'
	SET @FinalRC = 1
	GOTO Exit_Sproc	
END

IF EXISTS (SELECT 1
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexRetryMaxTimes')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexRetryMaxTimes', @astr OUTPUT
	PRINT 'IndexRetryMaxTimes = ' + @astr
	SET @retrymax = CAST (@astr as tinyint)
END

IF @retrymax NOT BETWEEN 0 AND 255
BEGIN
	PRINT 'Incorrect configuration parameter IndexRetryMaxTimes: ' + CAST (@retrymax as varchar(3)) 
		+ ' value must be between 0 and 255 - exiting'
	SET @FinalRC = 1
	GOTO Exit_Sproc	
END

IF EXISTS (SELECT 1 
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexDeadline')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexDeadline', @astr OUTPUT
	PRINT 'IndexDeadline = ' + @astr
	SET @deadline = LTRIM(RTRIM(@astr))
END

IF (@deadline IS NOT NULL)
	AND (ISDATE(@deadline) = 0)
BEGIN
	PRINT 'Incorrect configuration parameter IndexDeadline: ' + @deadline 
		+ ' value must of format hh:mm - exiting'
	SET @FinalRC = 1
	GOTO Exit_Sproc	
END

IF EXISTS (SELECT 1
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexRebuildOnline')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexRebuildOnline', @astr OUTPUT
	PRINT 'IndexRebuildOnline = ' + @astr
	SET @online = CAST (@astr as bit)
END

IF EXISTS (SELECT 1
	FROM dbsInstanceConfig
	WHERE dbsInstanceConfigName = 'IndexSortinTempDB')
	AND @Override = 0
BEGIN
	EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexSortinTempDB', @astr OUTPUT
	PRINT 'IndexSortinTempDB = ' + @astr
	SET @SortinTempDB = CAST (@astr as bit)
END

------------------------------------------------------------------------
-- Get config

SELECT @exceptionNum = MAX(dbsDatabaseExceptionID)
FROM [DBServices].[dbo].[dbsDatabaseException]
WHERE dbsDatabasename = @DatabaseName
	AND dbsDatabaseUID = @DatabaseUID
	AND dbsDatabaseExceptionType = 'maintenance'
	AND dbsDatabaseExceptionSubType = 'indexrebuild';

IF (SELECT dbsExceptionActive 
	FROM [DBServices].[dbo].[dbsDatabaseException]
	WHERE dbsDatabaseExceptionID = @exceptionNum) = 1 
BEGIN
    SET @ErrorText = 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: ' 
		 + @DatabaseName + ' is excluded from IDXReBld. Please use MWE GUI or usp_ConfigureExclusion to remove exclusion. Procedure will exit without action.'

	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 1

    GOTO Exit_Sproc
END		

PRINT '-------------------------------------------------------------' 

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IndexFragmentationLimitPercent', @IndexFragmentationLimitPercent OUTPUT 
IF @IndexFragmentationLimitPercent NOT BETWEEN 0 AND 100
BEGIN
	PRINT 'Using IndexFragmentationLimitPercent = 10% as config is incorrect; current setting is ' + CAST(@IndexFragmentationLimitPercent as char(3))
	SET @IndexFragmentationLimitPercent = 10
END

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'MAXDOP', @MAXDOP OUTPUT 
IF @MAXDOP IS NULL
BEGIN
	PRINT 'Using @MAXDOP = 0 as config missing'
	SET @MAXDOP = 0
END

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT 
IF @debug IS NULL
BEGIN
    PRINT 'Using @debug = 0 as config missing'
    SET @debug = 0
END


------------------------------------------------------------------------------------------
-- Action reindex:

-- Build valid database list


PRINT CONVERT (varchar, getdate(), 113) + ' - Start of Indexes Fragmentation report for database: ' + @DatabaseName

-- Called sp_executesql in MSSQL 2000, in 2005 we now run sp_executesql to run DM view in the context of database where index fragmentation info
-- is collected. To get object name from object id connection needs to be in context of that DB.

--Precache the DB_ID with info from the DBServices database.

SELECT TOP 1 @DB_ID = dbsDatabasedbid 
FROM DBServices.dbo.dbsDatabase 
WHERE dbsDatabaseName = @DatabaseName
      AND dbsDatabaseIsActive = 1
      
--check exclusion list to see if database used the a different index stats strategy
SELECT @exceptionNum = MAX(dbsDatabaseExceptionID) 
FROM [DBServices].[dbo].[dbsDatabaseException] 
WHERE dbsDatabasename = @DatabaseName 
	AND dbsDatabaseUID = @DatabaseUID
	AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionType))) = 'maintenance'
	AND LOWER(LTRIM(RTRIM(dbsDatabaseExceptionSubType))) = 'warehouse_indexrebuild';

--In large warehouses its not uncommon to have most tables with no indexes but the standard approach still has to scan
--the heaps before filtering them out leading to wasted io. We look to see if the database is a warehouse in the exceptions table
--and if it is we build a list of tables with indexes and then run defrag checks on the list rather than every table regardless.
--In one warehouse this reduced runtime from 2 hours to 2 seconds....

IF @exceptionNum IS NOT NULL
	AND (SELECT dbsExceptionActive
	FROM [DBServices].[dbo].[dbsDatabaseException]
	WHERE dbsDatabaseExceptionID = @exceptionNum) = 1 
BEGIN
	--Build a list of tables and get defrag

	SET @SQLStr = '
	DECLARE @SQLStr nvarchar(2000)

	DECLARE TableList CURSOR READ_ONLY
	FOR 
	SELECT CAST(sobj.object_id as nvarchar(50))
	FROM sys.objects sObj
	INNER JOIN sys.indexes sInd
		ON sObj.object_id = sind.object_id
	WHERE sobj.is_ms_shipped = 0 
		AND sobj.type = ''U''
		AND sInd.index_id > 0
	GROUP BY sobj.name, sobj.object_id 
			
	DECLARE @ObjID nvarchar(50)
	OPEN TableList
	FETCH NEXT FROM TableList INTO @ObjID
	WHILE (@@fetch_status <> -1)
	BEGIN
		IF (@@fetch_status <> -2)

		BEGIN
			SET @SQLStr = '' INSERT INTO DBServices.dbo.dbsIndexDFRG 
			SELECT getdate()
				,''''' + @DatabaseName + '''''
				,object_name(s.object_id)
				,s.object_id
				,s.index_id
				,s.index_type_desc
				,s.Index_Depth
				,s.partition_number
				,CAST(s.avg_fragmentation_in_percent as char(9))
				,CAST(s.avg_fragment_size_in_pages as char(9))
				,s.fragment_count
				,s.page_count
				,s.min_record_size_in_bytes
				,s.max_record_size_in_bytes
				,s.avg_record_size_in_bytes
				,s.record_count
				,CAST(s.avg_page_space_used_in_percent as char(9))
				,s.forwarded_record_count
				,NULL
				,NULL
				,p.data_compression_desc
			FROM sys.dm_db_index_physical_stats (' + CAST(@DB_ID as nvarchar(10)) + ',''+ @ObjID +'', NULL, NULL, ''''SAMPLED'''') s
			INNER JOIN sys.partitions p WITH (NOLOCK)
					ON p.object_id = s.object_id
					AND p.index_id = s.index_id
					AND p.partition_number = s.partition_number                        
			WHERE s.index_id > 0
				AND objectproperty(s.object_id ,''''IsMSShipped'''') = 0
				AND s.alloc_unit_type_desc = ''''IN_ROW_DATA''''
			GROUP BY s.database_id
				,s.object_id
				,s.index_id
				,s.index_type_desc
				,s.Index_Depth
				,s.partition_number
				,s.avg_fragmentation_in_percent
				,s.avg_fragment_size_in_pages
				,s.fragment_count
				,s.page_count
				,s.min_record_size_in_bytes
				,s.max_record_size_in_bytes
				,s.avg_record_size_in_bytes
				,s.record_count
				,s.avg_page_space_used_in_percent
				,s.forwarded_record_count
				,p.data_compression_desc        
			ORDER BY object_name(s.object_id), s.index_id asc, s.partition_number ASC 
			OPTION (MAXDOP ' + CAST(@MAXDOP as varchar(3)) + ') ''

			SET @SQLStr = N''USE [' + @DatabaseName +']'' + @SQLStr

			EXEC sp_executesql @SQLStr 

		END
		FETCH NEXT FROM TableList INTO @ObjID
	END
	CLOSE TableList
	DEALLOCATE TableList'
END -----------------------------
ELSE
BEGIN
	SET @SQLStr = 'INSERT INTO DBServices.dbo.dbsIndexDFRG 
	SELECT getdate()
		,''' + @DatabaseName + '''
		,object_name(s.object_id)
		,s.object_id
		,s.index_id
		,s.index_type_desc
		,s.Index_Depth
		,s.partition_number
		,CAST(s.avg_fragmentation_in_percent as char(9))
		,CAST(s.avg_fragment_size_in_pages as char(9))
		,s.fragment_count
		,s.page_count
		,s.min_record_size_in_bytes
		,s.max_record_size_in_bytes
		,s.avg_record_size_in_bytes
		,s.record_count
		,CAST(s.avg_page_space_used_in_percent as char(9))
		,s.forwarded_record_count
		,NULL
		,NULL -- PD : Extra Stats columns added
		,p.data_compression_desc -- JS : Column to capture current compression type
	FROM sys.dm_db_index_physical_stats (' + CAST(@DB_ID as nvarchar(10)) + ', NULL, NULL, NULL, ''SAMPLED'') s
	INNER JOIN sys.partitions p WITH (NOLOCK)
			ON p.object_id = s.object_id
			AND p.index_id = s.index_id
			AND p.partition_number = s.partition_number                        
	WHERE s.index_id > 0
		AND objectproperty(s.object_id ,''IsMSShipped'') = 0
		AND s.alloc_unit_type_desc = ''IN_ROW_DATA''
	GROUP BY s.database_id
		,s.object_id
		,s.index_id
		,s.index_type_desc
		,s.Index_Depth
		,s.partition_number
		,s.avg_fragmentation_in_percent
		,s.avg_fragment_size_in_pages
		,s.fragment_count, s.page_count
		,s.min_record_size_in_bytes
		,s.max_record_size_in_bytes
		,s.avg_record_size_in_bytes
		,s.record_count
		,s.avg_page_space_used_in_percent
		,s.forwarded_record_count
		,p.data_compression_desc        
	ORDER BY object_name(s.object_id), s.index_id asc, s.partition_number ASC 
	OPTION (MAXDOP ' + CAST(@MAXDOP as varchar(3)) + ')'
END

SET @SQLStr = N'USE [' + @DatabaseName +'] ' + @SQLStr

EXEC @RC = sp_executesql @SQLStr 

IF @RC <> 0
	SET @FinalRC = 1

PRINT 'Index information...'
PRINT '----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'
SELECT * FROM DBServices.dbo.dbsIndexDFRG
WHERE dbsDatabaseName = @DatabaseName
ORDER BY dbsDatabaseName, CountPages, avg_fragmentation_in_percent ASC -- PD : Order by smallest indexes first
PRINT '----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'

------------------------------------------------------------------------------------------

-- PD : If REBUILD then need to gather disk space stats
--
IF (@InxDefragtyp = 'REBUILD')
BEGIN
	-- PD : Get the disk space available for all FileGroups in the current database
	--
	CREATE TABLE #DBase_FileGroup_Space_Stats
	(
			FileGroup			sysname NULL,
			FGAvailSpaceInMB	numeric(12,2) NULL
	)

	SELECT @SQLStr = 'USE [' + @DatabaseName + ']' + char(13) +
		'INSERT INTO #DBase_FileGroup_Space_Stats
		SELECT 
			SFG.groupname as FileGroup,
			SUM(size/128.0 - CAST(FILEPROPERTY(name, ''SpaceUsed'' ) as int)/128.0) as [FGAvailableSpaceInMB]
		FROM dbo.sysfiles SF
		JOIN dbo.sysfilegroups SFG ON SF.groupid = SFG.groupid
		GROUP BY SFG.groupname'

	EXEC @RC = sp_executesql @SQLStr
	IF @RC <> 0
		SET @FinalRC = 1

	-- PD : Get the disk space consumed by every Index in the current database
	CREATE TABLE #DBase_Index_Space_Stats
		(
			TableName			sysname NULL,
			IndexId				int NULL,
			Partition_number	int NULL,
			FileGroup			sysname NULL,
			UsedPagesMB			numeric(12,2) NULL           
		)

	SELECT @SQLStr = 'USE [' + @DatabaseName + ']' + char(13) +
		'INSERT INTO #DBase_Index_Space_Stats
		SELECT 
			o.[name], 
			i.index_id,
			s.[partition_number],
			f.[name],
			((s.used_pages * 8) / 1024)
		FROM sys.objects as o INNER JOIN
			(
			SELECT data_space_id, p.partition_number, type_desc, [rows], total_pages, used_pages, data_pages, [object_id], index_id
			FROM sys.allocation_units as a 
				INNER JOIN sys.partitions as p ON a.container_id = p.hobt_id
			WHERE a.type = 1 -- IN_ROW_DATA
			) as s ON o.[object_id] = s.[object_id]
		INNER JOIN sys.data_spaces as f ON s.[data_space_id] = f.[data_space_id]
		INNER JOIN sys.indexes as i ON s.[object_id] = i.[object_id] AND s.index_id = i.index_id
		WHERE o.type = ''U'' -- User Defined Table
			AND i.index_id <> 0 -- Not a Heap
		ORDER BY o.[name], i.[index_id]'

	EXEC @RC=sp_executesql @SQLStr
	IF @RC <> 0
		SET @FinalRC = 1
END

------------------------------------------------------------------------------------------
--Now start with Defrag task

DECLARE @tblList table 
( 
        TabNum  int identity ,
        dbsDatabaseName  sysname,
        objectname nvarchar(255),
        ObjectId int, 
        IndexId int,
        CountPages bigint,
        ObjFrag float,
        Partition_number int,
        CompressionDesc nvarchar(60)
)
-- object name for each db and defrag if fragmentation is greater than defined.
PRINT CONVERT (varchar, getdate(), 113) + ' - Start of Index Defrag Operation'
PRINT '...'        

--CB MWE 5.0.9.3: 
IF @MajorVersion <= 9 -- SQL 2000
BEGIN
    INSERT @tblList
    SELECT DISTINCT dbsDatabaseName
		, ObjectName
		, ObjectId
		, IndexId
		, CountPages
		, avg_fragmentation_in_percent
		, Partition_number
		, 'NONE'
    FROM DBServices.dbo.dbsIndexDFRG
    WHERE dbsDatabaseName = @DatabaseName
		AND ISNULL(avg_fragmentation_in_percent,0) > @IndexFragmentationLimitPercent -- CB MWE 5.0.9.3: exclude nothing to do's because update is to slow when the are 10,000's of partitions
    ORDER BY dbsDatabaseName, CountPages ASC, avg_fragmentation_in_percent ASC -- PD : Order by smallest indexes first
END -----------------------
ELSE
BEGIN
	INSERT @tblList
	SELECT DISTINCT dbsDatabaseName
		, ObjectName
		, ObjectId
		, IndexId
		, CountPages
		, avg_fragmentation_in_percent
		, Partition_number
		, data_compression_desc
	FROM DBServices.dbo.dbsIndexDFRG 
	WHERE dbsDatabaseName = @DatabaseName
			AND ISNULL(avg_fragmentation_in_percent,0) > @IndexFragmentationLimitPercent -- CB MWE 5.0.9.3: exclude nothing to do's because update is to slow when the are 10,000's of partitions
	ORDER BY dbsDatabaseName, CountPages ASC, avg_fragmentation_in_percent ASC -- PD : Order by smallest indexes first
END

SET @RC=@@ERROR
IF @RC <> 0
	SET @FinalRC = 1

------------------------------------------------------------------------------------------
--CB MWE 5.0.9.3: Evaluate scope - excluded all the indexes below the threshold
--so we just do one mass update here to mark them all as not defrag.        

UPDATE DBServices.dbo.dbsIndexDFRG 
SET ReIndexStatus = 'NOT PERFORMED - FRAGMENTATION UNDER ' + CAST(@IndexFragmentationLimitPercent as varchar(3)) + '% LIMIT'
WHERE  
	dbsDatabaseName = @DatabaseName
	AND ISNULL(avg_fragmentation_in_percent, 0) <=  @IndexFragmentationLimitPercent 

PRINT CONVERT (NVARCHAR, getdate(), 113) + ' - ' + CAST(@@ROWCOUNT as NVARCHAR(7)) + ' INDEXES BELOW FRAGMENTATION THRESHOLD. REVIEW DBSERVICES..DBSINDEXDFG FOR MORE INFO.'
PRINT '...'   

------------------------------------------------------------------------------------------
-- Main reindex do loop

SET @i = 1

WHILE (@i <= (SELECT MAX(TabNum) FROM @tblList)) 
BEGIN
	SET @ErrorText = NULL

	SELECT @DatabaseName = ISNULL(dbsDatabaseName, 'NA')
			, @objectname=ISNULL(objectname, 'NA')
			, @objectid=ISNULL(ObjectId, 0)
			, @IndexId=ISNULL(IndexId, 0)
			, @frag= ISNULL(ObjFrag, 0)
			, @partition_number = ISNULL(Partition_number, 0)
			, @CompressDesc = ISNULL(CompressionDesc,'NONE')
	FROM @tblList  
	WHERE TabNum = @i 
             
	--  Get schema name as well if there any user defined schemas.
	SET @SQLStr = N' SELECT @schemanameOUT = s.name FROM sys.objects  o
					JOIN sys.schemas  s ON s.schema_id = o.schema_id
					WHERE o.object_id = ' + CAST(@objectid as varchar(20))
	SET @permdef = N'@schemanameOUT nvarchar(255) OUTPUT'
	SET @SQLStr = N'Use [' + @DatabaseName +'] ' + @SQLStr

	EXEC @RC=sp_executesql @SQLStr,@permdef,@schemanameOUT=@schemaname OUTPUT

	IF @RC <> 0
		SET @FinalRC = 1

	-----------------------------------------
	
	SET @SQLStr = N' SELECT @IndexnameOUT = ISNULL(name,''IndDisable'') FROM sys.indexes
					WHERE  object_id = ' + CAST(@objectid as varchar(20)) + ' AND index_id =  '
					+ CAST(@IndexId as varchar(20)) + '        AND is_disabled=0 '

	SET @permdef = N'@IndexnameOUT nvarchar(150)OUTPUT'
	SET @SQLStr = N'Use [' + @DatabaseName +'] ' + @SQLStr

	EXEC @RC=sp_executesql @SQLStr,@permdef,@IndexnameOUT=@Indexname OUTPUT

	IF @RC <> 0
		SET @FinalRC = 1
		
	-----------------------------------------
	
	IF @Indexname <> 'IndDisable'
		AND @Indexname NOT IN (
			SELECT [Index].IndexName
			FROM dbsDatabase INNER JOIN [Table] 
				ON dbsDatabase.dbsDatabaseUID = [Table].dbsDatabaseUID
			INNER JOIN [Index] 
				ON [Table].TableOwner = [Index].TableOwner 
					AND [Table].TableName = [Index].TableName
			WHERE (dbsDatabase.dbsDatabaseIsActive = 1) 
				AND (dbsDatabase.dbsDatabaseName = @DatabaseName) 
				AND ([Table].TableOwner = @schemaname)
				AND ([Table].TableName = @objectname) 
				AND ([Index].IndexName = @Indexname)
				AND ([Index].DisableRebuildFlag = 1)
		)
	BEGIN
		-- check if tables or indexes are spread over multiple partions.
		SET @SQLStr = N' SELECT @partCntOUT= count(*)
			FROM sys.partitions  
			WHERE object_id = ' + CAST(@objectid as varchar(20)) 
				+ ' AND index_id = ' + CAST(@IndexId as varchar(20))
		
		SET @permdef = N'@partCntOUT int OUTPUT'
		SET @SQLStr = N'Use [' + @DatabaseName +'] ' + @SQLStr
		
		EXEC @RC=sp_executesql @SQLStr, @permdef, @partCntOUT = @partitioncount OUTPUT

		-----------------------------------------
		
		IF @frag >  @IndexFragmentationLimitPercent
		BEGIN -- Compile idx rebuild / reorg command to @SQLStrMain
		
			PRINT 'Performing ' + @InxDefragtyp + ' on index ['
				 + @DatabaseName + N'].[' + @schemaname + N'].[' + LTRIM(RTRIM(@objectname)) + N'].[' + @Indexname + ']'
				 + ' PARTITION=' + CAST(@partition_number as varchar(4))

			SET @SkipIndex = 0
			SET @SQLStrMain = N'ALTER INDEX  [' + @Indexname + N'] ON [' + @DatabaseName + N'].[' + @schemaname + N'].[' + LTRIM(RTRIM(@objectname)) + N'] ' 

			IF @partitioncount > 1
				SET @SQLStrMain = @SQLStrMain + @InxDefragtyp 
					+ ' PARTITION=' + CAST(@partition_number as varchar(4))
			ELSE
				SET @SQLStrMain = @SQLStrMain + @InxDefragtyp

			-----------------------------------------
			IF @MajorVersion <= 9
			BEGIN
				SET @SQLStrMain = @SQLStrMain +
					CASE 
						WHEN @InxDefragtyp='REBUILD' THEN ' WITH (MAXDOP = ' + CAST(@MAXDOP as nvarchar(3)) + ')' 
						WHEN @InxDefragtyp='REORGANIZE' THEN ''
						ELSE '' 
					END			
			END -----------------------
			ELSE -- MSSQL 2005 +
			BEGIN
				SET @idx_datatypeid = NULL
	
				IF @InxDefragtyp='REBUILD' 
					AND @online = 1
				BEGIN
					-- online rebuild - determine if index on LOB column (MSSQL-622)

					SET @SQLStr = N' SELECT TOP 1 @idx_datatypeidOUT = sc.user_type_id 
						FROM sys.columns sc WITH (NOLOCK)
						WHERE sc.object_id = ' + CAST(@objectid as nvarchar(20)) + '
							AND (CASE
									--34 image, 35 text, 99 ntext, 241 xml
									WHEN sc.user_type_id IN(34, 35 ,99, 241) THEN 1
									 --167 varchar(max), 231 nvarchar(max), 165 varbinary(max)
									WHEN sc.user_type_id IN(167, 231 ,165) AND sc.max_length = -1 THEN 1
									ELSE 0
								END) = 1'
								
					SET @permdef = N'@idx_datatypeidOUT int OUTPUT'
					SET @SQLStr = N'Use [' + @DatabaseName +'] ' + @SQLStr

					EXEC @RC = sp_executesql @SQLStr, @permdef, @idx_datatypeidOUT = @idx_datatypeid OUTPUT

					IF @RC <> 0
					BEGIN
						SET @astr = 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: Unhandled exception - LOB check table: ' + @objectname 				
						PRINT @astr

						SET @FinalRC = 1 -- unhandled error occured, but don't fail
					END
					-----------------------

					IF @idx_datatypeid IS NOT NULL
					BEGIN
						SET @astr = 'LOB column identified within table: ' + @objectname 				
						PRINT @astr
					END
				END

				-----------------------------------------	
												
				IF @InxDefragtyp='REBUILD' 
					AND (@idx_datatypeid IS NULL 
						OR @FailoverToReorg = 0)
				BEGIN
					SELECT @SQLStrMain = @SQLStrMain + ' WITH ('
							+ CASE 	-- determine if online 
								WHEN @online = 1 AND @idx_datatypeid IS NULL THEN 'ONLINE = ON, '
								ELSE ''
								END
							+ CASE @SortinTempDB
								WHEN 1 THEN 'SORT_IN_TEMPDB = ON, '
								ELSE ''
								END
							+ 'MAXDOP = ' + CAST(@MAXDOP as nvarchar(3)) 
							+ ', DATA_COMPRESSION = ' + @CompressDesc + ')'
				END -----------------------
				ELSE
				IF @InxDefragtyp='REBUILD'
					AND @online = 1 
					AND (@idx_datatypeid IS NOT NULL -- column datatype is a LOB
							AND @FailoverToReorg = 1)
				BEGIN
					-- failover to REORG
					PRINT '=> changing to REORGANIZE'
					SET @SQLStrMain = REPLACE(@SQLStrMain, 'REBUILD', 'REORGANIZE')
				END	
				-- ELSE @InxDefragtyp='REORGANIZE' - nothing else to append
			END

			-----------------------------------------
			-- If REBUILD then check available disk space vs Index size
			
			IF (@InxDefragtyp = 'REBUILD')
			BEGIN
				-- Debug
				/*
				SELECT DIS.UsedPagesMB, DFS.FGAvailSpaceInMB
				FROM #DBase_Index_Space_Stats DIS
				JOIN #DBase_FileGroup_Space_Stats DFS
						ON DIS.FileGroup = DFS.FileGroup
				WHERE
				DIS.TableName = @objectname
				AND DIS.IndexId = @IndexId
				AND DIS.Partition_number = @partition_number
				*/
				-- Debug

				SELECT @UsedPagesMB = DIS.UsedPagesMB
					,@FGAvailSpaceInMB = DFS.FGAvailSpaceInMB
				FROM #DBase_Index_Space_Stats DIS
				INNER JOIN #DBase_FileGroup_Space_Stats DFS
					ON DIS.FileGroup = DFS.FileGroup
				WHERE DIS.TableName = @objectname
					AND DIS.IndexId = @IndexId
					AND DIS.Partition_number = @partition_number

				IF (@UsedPagesMB > @FGAvailSpaceInMB) 
				BEGIN
					PRINT 'Size of index exceeds available disk space on Index [' + @DatabaseName + N'].[' +  @schemaname + N'].[' + LTRIM(RTRIM(@objectname)) + N'].['  + @Indexname +']'
						 + ' PARTITION=' + CAST(@partition_number as varchar(4))
					PRINT 'Index size (MB) = ' + CAST(@UsedPagesMB as varchar(100)) 
						+ '  Filegroup space available (MB) = ' + CAST(@FGAvailSpaceInMB as varchar(100))

					-----------------------------------------
		
					IF (@FailoverToReorg = 1) 
					BEGIN
						-- Fail over to REORGANIZE
						
						PRINT '@FailoverToReorg option set, will attempt to REORGANIZE the index:'
                            
						IF @MajorVersion <= 9
						BEGIN
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'REBUILD', 'REORGANIZE')
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'MAXDOP = ' + CAST(@MAXDOP as nvarchar(3)), '') -- CB Bugfix no maxdop for a reorg 5.0.9.1
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'WITH ()','') -- CB Bugfix 5.0.9.2
						END -----------------------
						ELSE
						BEGIN
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'REBUILD', 'REORGANIZE')
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'ONLINE = ON, ', '') -- CB strip online option for a reorg
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'SORT_IN_TEMPDB = ON, ', '') -- CB strip SortinTempDB option for a reorg
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'MAXDOP = ' + CAST(@MAXDOP as nvarchar(3)), '') -- CB Bugfix no maxdop for a reorg 5.0.9.1
							SET @SQLStrMain = REPLACE(@SQLStrMain,', DATA_COMPRESSION = ' + @CompressDesc,'')
							SET @SQLStrMain = REPLACE(@SQLStrMain, 'WITH ()','') -- CB Bugfix 5.0.9.2
						END

						UPDATE DBServices.dbo.dbsIndexDFRG 
						SET ReIndexStatus = 'Failed over to REORGANIZE'
						WHERE  
							dbsDatabaseName = @DatabaseName
							AND ObjectId = @objectid
							AND IndexId = @IndexId
							AND Partition_number = @partition_number
					END -----------------------
					ELSE
					BEGIN											
						SET @ErrorText = 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: @FailoverToReorg option has NOT been set so will now skip defragmenting the index'
							+ ' DB: ' + @DatabaseName
							+ ' Objectid: ' + CAST(@objectid as varchar(20))
							+ ' Indexid: ' + CAST(@IndexId as varchar(10)) 
							+  ' NOT PERFORMED - NOT ENOUGH DISK SPACE!'
						
						IF @disableFalerts = 0
						BEGIN
							EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 2
							SET @FinalRC = 1
						END
						ELSE
							PRINT @ErrorText
	    
						UPDATE DBServices.dbo.dbsIndexDFRG 
						SET ReIndexStatus = 'NOT PERFORMED - NOT ENOUGH DISK SPACE'
						WHERE  
							dbsDatabaseName = @DatabaseName
							AND ObjectId = @objectid
							AND IndexId = @IndexId
							AND Partition_number = @partition_number

						SET @SkipIndex = 1
					END
				END

			END

			------------------------------------------------------------------------------------------

			IF @SkipIndex = 0
			BEGIN
				-- Check Transaction Log Used% against @MaxTransLogPct (if value supplied)

				IF @MaxTransLogPct <> 0
				BEGIN
					-- CB: Retry for @retrydelay, @retrymax times if DB Tlog usage > @MaxTransLogPct
					SET @retrycnt =0
					WHILE @retrycnt <= @retrymax
					BEGIN
						DELETE FROM @TLogsUsedPct

						INSERT INTO @TLogsUsedPct 
							EXEC ('DBCC SQLPERF(LOGSPACE) WITH NO_INFOMSGS')

						SELECT @LogUsedPct = LogUsed 
						FROM @TLogsUsedPct 
						WHERE DbaseName = @DatabaseName
                        
						IF (@deadline IS NOT NULL) 
							AND (CONVERT(char(5),getdate(),14) >= @deadline)
						BEGIN -- STOP retrying if deadline has been reached	
							PRINT 'DEADLINE ' + @deadline + ' REACHED - finishing'

							UPDATE DBServices.dbo.dbsIndexDFRG 
							SET ReIndexStatus = 'DEADLINE ' + @deadline + ' REACHED - NOT PERFORMED'
							WHERE  
								dbsDatabaseName = @DatabaseName
								AND ObjectId = @objectid
								AND IndexId = @IndexId
								AND Partition_number = @partition_number

							SET @retrycnt = @retrymax

							IF @disableFalerts = 0
								SET @FinalRC = 1
							BREAK 										
						END
						
						------------------------------------------
						-- CB: MWE 5.0.9.3 - Check for table lock, skip or retry (SQL 2005+)				
						IF @TblLockCheck= 1
							AND @MajorVersion >= 9
						BEGIN
							
							SET @resource_type= NULL
							SET @SQLStr = N'SELECT TOP 1 @resource_typeOUT = resource_type
							FROM sys.dm_tran_locks l
							JOIN sys.partitions p ON l.resource_associated_entity_id = p.hobt_id
							WHERE l.resource_database_id = DB_ID(''' + @DatabaseName 
								+ ''') AND p.object_id = ' + CAST (@objectid as nvarchar(20))
								+ ' AND p.partition_id = ' + CAST (@partition_number as nvarchar(20)) 
								
							SET @permdef = N'@resource_typeOUT nvarchar(120) OUTPUT'
		
							EXEC sp_executesql @SQLStr,@permdef,@resource_typeOUT = @resource_type OUTPUT
						
							IF (@resource_type IS NOT NULL) AND @resource_type NOT IN ('PAGE') 
							--@resource_type = DATABASE, FILE, OBJECT, PAGE, KEY, EXTENT, RID, APPLICATION, METADATA, HOBT, or ALLOCATION_UNIT.
							BEGIN
								-- LOCK on table - retry or skip
								IF @retrycnt < @retrymax 
								BEGIN
									--Retry in @retrydelay
									SET @retrycnt = @retrycnt + 1
									
									PRINT @objectname + ': LOCKED with ' + @resource_type 
										+ ' for idx ' + @Indexname 
										+ ' - waiting for ' + @retrydelay  
										+ ', retry count ' + CAST(@retrycnt as nvarchar(3)) 
										+ ' of ' + CAST(@retrymax as nvarchar(3))
										
									WAITFOR DELAY @retrydelay
								END -------------------
								ELSE
								BEGIN --@retrycnt = @retrymax 
									-- Retry count exceeded - skip
									SET @retrycnt = @retrycnt + 1
									PRINT @objectname + ': LOCKED table retry count (' + CAST(@retrymax as nvarchar(3)) 
										+ ') for idx ' + @Indexname + ' exceeded - skipping'

									IF @disableFalerts = 0
										SET @FinalRC = 1
								END
							END
						END
						
						--------------------------------------------
						
						IF (CAST(@LogUsedPct as int) > @MaxTransLogPct)
							AND (@retrycnt <= @retrymax)
						BEGIN
							--CB: Retry
							IF @retrycnt < @retrymax 
							BEGIN
								--Retry in @retrydelay
								SET @retrycnt = @retrycnt + 1
								PRINT '- TLog ' + CAST (CAST(@LogUsedPct as int) as nvarchar(3)) 
									+ '% used > threshold of ' + CAST(@MaxTransLogPct as nvarchar(2)) 
									+ '% - waiting for ' + @retrydelay 
									+ ', retry count ' + CAST(@retrycnt as nvarchar(3)) + ' of ' + CAST(@retrymax as nvarchar(3))
									
								WAITFOR DELAY @retrydelay
							END -----------------------
							ELSE
							BEGIN
								SET @ErrorText = @DatabaseName + ' UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: Idx ' + @InxDefragtyp
									+ ' aborted due to Transaction Log Used% exceeding ' + CAST(@MaxTransLogPct as varchar(2))
									+ '% threshold (' + CAST(@LogUsedPct as varchar(18)) + '%)'
									+ ' Objectid: ' + CAST(@objectid as varchar(20)) + ' Indexid: ' + CAST(@IndexId as varchar(10))

								UPDATE DBServices.dbo.dbsIndexDFRG 
								SET ReIndexStatus = 'NOT PERFORMED - Transaction Log Used% exceeded ' + CAST(@MaxTransLogPct as varchar(2)) 
									+ '% threshold (' + CAST(@LogUsedPct as varchar(18)) + '%)'
								WHERE  
									dbsDatabaseName = @DatabaseName
									AND ObjectId = @objectid
									AND IndexId = @IndexId
									AND Partition_number = @partition_number
									
								IF @disableFalerts = 0
								BEGIN
									EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 2
									SET @FinalRC = 1
								END
								ELSE
									PRINT @ErrorText
	    
								GOTO Exit_Sproc
							END -----------------------
						END -----------------------
						ELSE
							BREAK -- CB: OK to continue
					END
				END

				------------------------------------------------------------------------------------------
				--CB : Added deadline

				IF (@deadline IS NOT NULL)
					AND (CONVERT(char(5),getdate(),14) >= @deadline)
				BEGIN
					SET @ErrorText= 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: ' + @DatabaseName 
						+ ' Idx: ' + @InxDefragtyp 
						+ ' aborted due to DEADLINE of ' + @deadline  
					
					UPDATE DBServices.dbo.dbsIndexDFRG 
					SET ReIndexStatus = 'ABORTED - DEADLINE of ' + @deadline 
					WHERE dbsDatabaseName = @DatabaseName
						AND ObjectId = @objectid
						AND IndexId = @IndexId
						AND Partition_number = @partition_number
					
					IF @disableFalerts = 0
					BEGIN
						EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 2
						SET @FinalRC = 1
					END
					ELSE
						PRINT @ErrorText

					GOTO Exit_Sproc -- finish
				END

				------------------------------------------------------------------------------------------
				-- Finally execute @SQLStrMain command to action
				-- try/catch so as not to exit the sp upon errors

				IF @retrycnt <= @retrymax
				BEGIN               
					BEGIN TRY
						-- Execute alter index cmd
						PRINT @SQLStrMain -- output cmd string for investigating failures
						PRINT 'Started: ' + CONVERT (varchar, getdate(), 113)
						EXEC @RC = sp_executesql @SQLStrMain
						PRINT 'Finished: ' + CONVERT (varchar, getdate(), 113)
					END TRY

					BEGIN CATCH
						-- CB: Updated failed logging
						SET @ErrorText = 'UBSMWE: usp_UBSMWE_WFST_IDXReBld_JobRun: ' + @DatabaseName 
							+ ' Idx :' + @InxDefragtyp + ' FAILED with: ' + ERROR_MESSAGE() 
							+ ' Objectid: ' + CAST(@objectid as varchar(20)) 
							+ ' Indexid: ' + CAST(@IndexId as varchar(10))

						IF @disableFalerts = 0
						BEGIN
							EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorText, 2
							SET @FinalRC = 1 
						END
						ELSE
							PRINT @ErrorText
							
						UPDATE DBServices.dbo.dbsIndexDFRG 
						SET ReIndexStatus = 'ATTEMPTED BUT FAILED'
						WHERE  
							dbsDatabaseName = @DatabaseName
							AND ObjectId = @objectid
							AND IndexId = @IndexId
							AND Partition_number = @partition_number	
					END CATCH
					
					-----------------------
					
					IF @ErrorText IS NULL
						UPDATE DBServices.dbo.dbsIndexDFRG 
						SET ReIndexStatus = 'SUCCEEDED', ReIndexTime = getdate() 
						WHERE  
							dbsDatabaseName = @DatabaseName
							AND ObjectId = @objectid
							AND IndexId = @IndexId
							AND Partition_number = @partition_number
					ELSE
						SET @ErrorText = NULL -- reset
						
				END 
			END
		END -----------------------------------------
		ELSE
		BEGIN
			--CB MWE 5.0.9.3: This section 'should' no longer be reached as scope verified earlier. 
			PRINT 'Operation not performed due to percentage of fragmentation not meeting limit on Index ['
				+ @DatabaseName + N'].[' +  @schemaname + N'].[' + @objectname + N'].[' + @Indexname + ']'
				+ ' PARTITION=' + CAST(@partition_number as varchar(4))

			UPDATE DBServices.dbo.dbsIndexDFRG 
			SET ReIndexStatus = 'NOT PERFORMED - FRAGMENTATION UNDER '
				+ CAST(@IndexFragmentationLimitPercent as varchar(3)) + '% LIMIT'
			WHERE  
				dbsDatabaseName = @DatabaseName
				AND ObjectId = @objectid
				AND IndexId = @IndexId
				AND Partition_number = @partition_number
		END
	END -----------------------------------------
	ELSE
	BEGIN
		PRINT 'Operation not performed due to index rebuild option being disabled on Index [' 
			+ @DatabaseName + N'].[' +  @schemaname + N'].[' + @objectname + N'].[' + @Indexname +']'
			+ ' PARTITION=' + CAST(@partition_number as varchar(4))

		UPDATE DBServices.dbo.dbsIndexDFRG 
		SET ReIndexStatus = 'NOT PERFORMED - REBUILD OPTION DISABLED'
		WHERE dbsDatabaseName = @DatabaseName
			AND ObjectId = @objectid
			AND IndexId = @IndexId
			AND Partition_number = @partition_number
	END -----------------------------------------

	SET @i = @i + 1; 
	PRINT '-----'
END 

------------------------------------------------------------------------------------------

Exit_Sproc:

IF @disableFalerts = 1
	PRINT CHAR(13) + '*** Please note idx rebuild alerts are disabled (@disableFalerts = 1), consequently job result will return successful ***' 

PRINT '...'
PRINT CONVERT (varchar, getdate(), 113) + ' - End of usp_UBSMWE_WFST_IDXReBld_JobRun'

RETURN @FinalRC

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdateActiveServerName]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_UpdateActiveServerName] 	




AS

SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_UpdateActiveServerName.SQL
// 
// Purpose:
//   Populate dbsInstanceConfig with current server name...
//
// Notes: This stored procedure is called by main UBSMWE job. 
//
// History: Dates are in mm/dd/yyyy format
//
//   
//   
//   @Date: 10/05/2004	@Author: Kevin Wagner	@Version: 1.5.0	@Action: Inception.
//   @Date: 12/18/2006	@Author: Kevin Wagner	@Version: 2.5.0	@Action: Stop unproductive result set.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

BEGIN  --Begin main()


--PRINT '/************************************************************************************************************/'
--PRINT 'Start Running of usp_UpdateActiveServerName at ' + CONVERT ( varchar ( 255 )  , getdate() , 114  )+ ' on ' + @@servername
--PRINT '/************************************************************************************************************/'

DECLARE 	@test varchar(20)
		,@RC int


/*
// Set current status in heartbeat
*/
-- Need to stop unproductive logging
--		EXEC usp_UpdatedbsUBSMWEHeartbeat 'start usp_UpdateActiveServerName'

/*
//    The idea here is to initialize the dbsInstance table with the actual host name of the server
*/

--Could use HOST_NAME() instead...

	EXEC master..xp_regread @rootkey='HKEY_LOCAL_MACHINE',
	  @key='SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName',
	  @value_name='ComputerName',
	  @value=@test OUTPUT
	PRINT 'Server name is ' + @test



IF @test IS NOT NULL

		BEGIN
-- Need to stop unproductive logging
--				EXEC usp_UpdatedbsUBSMWEHeartbeat 'Updating ActiveComputerName '
			EXEC usp_UpdatedbsInstanceConfig 'ActiveComputerName', @test
		END

ELSE
		BEGIN
			EXEC usp_UpdatedbsUBSMWEHeartbeat 'Unable to update ActiveComputerName - Return data was (null) invalid' , 1
		END


	

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsDatabase]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdatedbsDatabase] @Init bit = 0
AS

/****************************************************************************************
// @File: usp_UpdatedbsDatabase.SQL
// 
// Purpose:
//   Update Current list of databases from master..sysdatabases into local work table
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 20/08/2004 @Author: Kevin Wagner @Version: 1.0.1 @Action: Updated to account for detaching and reattaching databases
//   @Date: 07/11/2004 @Author: Kevin Wagner @Version: 1.5.2 @Action: Updated for new functionality allowing the exclusion of all user databases (SMB Project requirement.)
//   @Date: 05/02/2007 @Author: Kevin Wagner @Version: 2.5.1 @Action: Updated for issue#3 Renamed database full backup requirement.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 03/06/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4 @Action: Updated for BUG# 33, 34 and 39
//   @Date: 07/02/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9 @Action: Updated @init process to inc tbl CVSubclient and dbsDatabaseException
//   @Date: 17/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//   @Date: 27/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.8 @Action: TRRv3 Beta
//   @Date: 01/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 Beta
//   @Date: 26/06/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.33 @Action: Bugfix: AO AG failover - 2nd TLog backup jobs not removed
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE 
	@RC int
	,@dbid2 smallint
	,@name sysname
	,@dbid smallint
	,@sid varbinary(85) 
	,@mode smallint
	,@status int
	,@status2 int
	,@crdate datetime  
	,@reserved datetime 
	,@category int
	,@cmptlevel tinyint 
	,@filename nvarchar(255) 
	,@version int 
	,@JobAction int --0 = No Action, 1 = Create Job, 2 = Delete Job		
	,@dbsDatabaseName nvarchar(128)
	,@dbsDatabaseUID uniqueidentifier
	,@dbsDatabaseName_Hold nvarchar(128)
	,@DBStatus nvarchar(20)
	,@ErrorMsg nvarchar(512)
	,@IncludeReadOnlyBackups bit
	,@dbsBackupProcessor tinyint
	,@AOnode bit
	,@AOPrim bit

DECLARE @sysdatabasesTable TABLE (
	[name] [sysname]  NULL ,
	[dbid] [smallint]  NULL ,
	[sid] [varbinary] (85) NULL ,
	[mode] [smallint]  NULL ,
	[status] [int]  NULL ,
	[status2] [int]  NULL ,
	[crdate] [datetime]  NULL ,
	[reserved] [datetime]  NULL ,
	[category] [int]  NULL ,
	[cmptlevel] [tinyint]  NULL ,
	[filename] [nvarchar] (260) NULL ,
	[version] int NULL ) 

--------------------------------------------------------------------------------------------			
-- Set vars

INSERT INTO @sysdatabasesTable
	SELECT [name]
			,[dbid]
			,[sid]
			,[mode]
			,[status]
			,[status2]
			,[crdate]
			,[reserved]
			,[category]
			,[cmptlevel]
			,[filename]
			,[version]
	FROM master..sysdatabases
	WHERE [name] <> 'tempdb' 

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IncludeReadOnlyBackups', @IncludeReadOnlyBackups OUTPUT 
IF @RC <> 0
BEGIN
	SET @IncludeReadOnlyBackups = 0
	SET @ErrorMsg = 'UBSMWE: usp_UpdatedbsDatabase: IncludeReadOnlyBackups missing; using a value of 0' 
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2	-- raise an info
END

--------------------------------------------------------------------------------------------			
IF @Init = 1 -- Clean up new DB entries or mark as inactive 
BEGIN
	-- Search and clean up duplicates
	IF EXISTS (SELECT MAX(dbsDatabaseName)
				FROM DBServices.dbo.dbsDatabase
				GROUP BY dbsDatabaseName
				HAVING COUNT(*) > 1)
	BEGIN
		DECLARE @DBNamesTable TABLE (dbsDatabaseName nvarchar(128))

		INSERT INTO @DBNamesTable
			SELECT MAX(dbsDatabaseName)
			FROM DBServices.dbo.dbsDatabase
			GROUP BY dbsDatabaseName
			HAVING COUNT(*) > 1
		
		DECLARE db_cur CURSOR FOR
		SELECT DBNT.dbsDatabaseName, db.dbsDatabaseUID 
		FROM @DBNamesTable DBNT 
		INNER JOIN DBServices.dbo.dbsDatabase db
			ON DBNT.dbsDatabaseName = db.dbsDatabaseName
		ORDER BY db.[dbsDatabaseEntryDate] ASC

		OPEN db_cur

		FETCH NEXT FROM db_cur
			INTO @dbsDatabaseName, @dbsDatabaseUID
		SELECT @dbsDatabaseName_Hold = @dbsDatabaseName

		WHILE (@@FETCH_STATUS = 0)
		BEGIN  --begin while
			IF NOT EXISTS (SELECT 1 
							FROM DBServices.dbo.dbsDatabaseBackupHistory
							WHERE dbsDatabaseUID = @dbsDatabaseUID )
			BEGIN
				-- for the particular entry there is no backup history
				-- therefore the entry as invalid - delete
				DELETE FROM DBServices.dbo.dbsDatabaseBackup
				WHERE dbsDatabaseUID = @dbsDatabaseUID

				DELETE FROM DBServices.dbo.dbsDatabase	
				WHERE dbsDatabaseUID = @dbsDatabaseUID	

				DELETE FROM DBServices.dbo.dbsCVSubclients		
				WHERE dbsDatabaseUID = 	@dbsDatabaseUID	

				DELETE FROM DBServices.dbo.dbsDatabaseException		
				WHERE dbsDatabaseUID = @dbsDatabaseUID	
				
				DELETE FROM DBServices.[dbo].[dbsPartialBackupHistory]
				WHERE dbsDatabaseUID = @dbsDatabaseUID	

			END
			ELSE
			BEGIN
				-- dbsDatabaseBackupHistory exists for DB
				IF EXISTS (SELECT MAX(dbsDatabaseName)
							FROM DBServices.dbo.dbsDatabase
							GROUP BY  dbsDatabaseName
							HAVING COUNT(*) > 1) -- test again in case more than 1 dup
				BEGIN
					-- set DB name to old, mark entry as inactive
					UPDATE DBServices.dbo.dbsDatabase
					SET dbsDatabaseName = dbsDatabaseName + ' *OLD*'
						,dbsDatabaseIsActive = 0
					WHERE dbsDatabaseUID = @dbsDatabaseUID
				END
			END

			FETCH NEXT FROM db_cur INTO  @dbsDatabaseName, @dbsDatabaseUID
		END-- end while
		CLOSE db_cur
		DEALLOCATE db_cur	
	END
END
--------------------------------------------------------------------------------------------

--1, Update dbsDatabase, set is active flag = 0 to name of database if the name no longer exists in the sysdatabases table.
--   We need to do this from the base table and not from the courser so we can test for all conditions.

UPDATE DBServices.dbo.dbsDatabase
SET	dbsDatabaseIsActive = 0
	,dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1
WHERE dbsDatabaseName NOT IN (SELECT [name] FROM @sysdatabasesTable)
	AND	dbsDatabaseIsActive = 1

------------------------------------------------------------------------------------------
-- Set DB State

-- Determine if AO
IF [DBServices].[dbo].[ufn_InstanceMajorVersion] () >= 11
	SET @AOnode = CAST(SERVERPROPERTY ('IsHadrEnabled') as bit)
ELSE
	SET @AOnode = 0

-----------------------

DECLARE dbsDatabase_cur CURSOR 
FOR SELECT [name]
	,[dbid]
	,[sid]
	,[mode]
	,[status]
	,[status2]
	,[crdate]
	,[reserved]
	,[category]
	,[cmptlevel]
	,[filename]
	,[version]
FROM @sysdatabasesTable
OPEN dbsDatabase_cur

FETCH NEXT FROM dbsDatabase_cur
	INTO @name
		,@dbid   
		,@sid  
		,@mode   
		,@status 
		,@status2  
		,@crdate  
		,@reserved  
		,@category  
		,@cmptlevel 
		,@filename 
		,@version
WHILE (@@FETCH_STATUS = 0)
BEGIN  --begin while

	--------------------------------------------------------------------------------------------
	--2, Update DBID for databases where name is the same but the DBID changed in sysdatabases, Part of fix for BUG# 33, 34 and 39
	UPDATE DBServices.dbo.dbsDatabase 
	SET dbsDatabasedbid = @dbid
		,dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1
	FROM DBServices.dbo.dbsDatabase
	WHERE dbsDatabaseName = @name
		AND dbsDatabaseIsActive = 1
		AND	dbsDatabasedbid <> @dbid

	--------------------------------------------------------------------------------------------
	--3, Ok, now we need to reactivate Databases that were deleted and now back in the sysdatabases table.
	UPDATE DBServices.dbo.dbsDatabase 
	SET dbsDatabasedbid = @dbid
		,dbsDatabaseIsActive = 1
		,dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1
	FROM DBServices.dbo.dbsDatabase
	WHERE dbsDatabaseName = @name
		AND dbsDatabaseIsActive = 0

	--------------------------------------------------------------------------------------------
	--4 Check DB online status 

	IF @AOnode = 1
		SET @AOPrim = sys.fn_hadr_backup_is_preferred_replica(@name)
	ELSE
		SET @AOPrim = 1

	SET @DBStatus = CASE 
						WHEN (@status &		  32) <> 0 THEN 'LOADING'
						WHEN (@status &       64) <> 0 THEN 'PRE_RECOVERY'
						WHEN (@status &       128) <> 0 THEN 'RECOVERING'
						WHEN (@status &       256) <> 0 THEN 'NOT_RECOVERED'
						WHEN (@status &       512) <> 0 THEN 'OFFLINE'
						WHEN ((@status &      1024) <> 0)
							 AND (@IncludeReadOnlyBackups = 0) THEN 'READ_ONLY'
						WHEN (@status &      2048) <> 0 THEN 'DBO_USE_ONLY'
						WHEN (@status &      4096) <> 0 THEN 'SINGLE_USER'
						WHEN (@status &     32768) <> 0 THEN 'EMERGENCY_MODE'
						WHEN (@AOnode = 1 AND @AOPrim = 0) THEN 'AO_WARM_STANDBY'
						ELSE 'ONLINE'
					END

	--------------------------------------------------------------------------------------------
	-- New DB
	/*
	//    The idea here is to insert into the work table (dbsDatabase)
	//    those databases whose dbid and name combination do not exist from
	//    master..sysdatabases.
	*/

	IF NOT EXISTS (SELECT 1
					FROM DBServices.dbo.dbsDatabase 
					WHERE dbsDatabasedbid = @dbid 
						AND (dbsDatabaseName = @name
							OR dbsDatabaseName = @name + ' *OFFLINE*'))

	BEGIN --Insert new database to dbsDatabase table
		INSERT INTO	[DBServices].[dbo].[dbsDatabase]	
				(
				[dbsDatabaseUID], --Globally unique identifer that will be used in MSSQLCentral
				[dbsDatabasedbid],  --dbid from sysdatabases
				[dbsDatabaseName], --Current Database Name 
				[dbsDatabaseIsSystemObjectFlag], --Indicates database is system object such as 'master'
				[dbsDatabaseCreateDate],  -- Create data from master..sysdatabases
				[dbsDatabaseEntryDate], --Current time entered in work table
				[dbsDatabaseMSSQLCentralNeedsUpdateFlag], --Reserved for future use
				[dbsDatabaseInfoLoadedToMSSQLCentralDate], --Reserved for future use
				[dbsDatabaseIsActive] --Indicates if the database is currently active.
				)
		SELECT
	 		newid(),	--[dbsDatabaseUID], --Globally unique identifer that will be used in MSSQLCentral
			@dbid,		--[dbsDatabasedbid],  --dbid from sysdatabases
			CASE
				WHEN @DBStatus <> 'ONLINE' THEN @name + ' *OFFLINE*'
				ELSE @name
			END,		--[dbsDatabaseName], --Current Database Name
			CASE	
				WHEN @name IN ('master', 'model', 'msdb', 'Northwind', 'pubs', 'DBServices', 'tempdb') THEN 1
				ELSE 0
			END,		--[dbsDatabaseIsSystemObjectFlag] --Indicates database is system object such as 'master'
			@crdate,	--[dbsDatabaseCreateDate],  -- Create data from master..sysdatabases
			getdate(),	--[dbsDatabaseEntryDate], --Current time entered in work table
			1,			--[dbsDatabaseMSSQLCentralNeedsUpdateFlag], --Reserved for future use //hardcode yes for now...
			NULL,		--[dbsDatabaseInfoLoadedToMSSQLCentralDate], --Reserved for future use
			CASE	
				WHEN @name IN ('tempdb') THEN 0
				WHEN @DBStatus <> 'ONLINE' THEN 0
					ELSE 1 -- 'ONLINE'
			END --[dbsDatabaseIsActive]

			GOTO NEXT_DB
	END 

	--------------------------------------------------------------------------------------------
	-- Existing - verify state 

	IF @DBStatus <> 'ONLINE'
	BEGIN -- OFFLINE

		IF NOT EXISTS (SELECT 1 
						FROM DBServices.dbo.dbsDatabase
						WHERE dbsDatabasedbid = @dbid
							AND dbsDatabaseName LIKE '%*OFFLINE*'
							AND dbsDatabaseIsActive = 0)
		BEGIN -- Mark as OFFLINE
			UPDATE DBServices.dbo.dbsDatabase 
			SET dbsDatabaseName = dbsDatabaseName + ' *OFFLINE*'
				,dbsDatabaseIsActive = 0
				,dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1
				,[dbsDatabaseEntryDate]=getdate()	--modified date
			FROM DBServices.dbo.dbsDatabase
			WHERE dbsDatabasedbid = @dbid
				AND dbsDatabaseName = @name
				AND dbsDatabaseIsActive = 1
			
			SET @ErrorMsg = 'UBSMWE: usp_UpdatedbsDatabase: Database ' + @name 
							+ ' identified as ' + @DBStatus + ' - marking it OFFLINE; DB Maintenance deactivated' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1	-- raise an info
		END
		
		GOTO NEXT_DB
	END
	ELSE ----------------------------
	BEGIN -- ONLINE
		SELECT @dbsDatabaseName = NULL
			,@dbsDatabaseUID = NULL

		SELECT TOP 1 @dbsDatabaseName = dbsDatabaseName
					,@dbsDatabaseUID = dbsDatabaseUID
		FROM DBServices.dbo.dbsDatabase
		WHERE dbsDatabaseName = @name + ' *OFFLINE*'
			AND dbsDatabaseIsActive = 0
			AND	dbsDatabasedbid = @dbid
		ORDER BY dbsDatabaseEntryDate DESC

		-- DB back online - mark as active
		IF @dbsDatabaseName IS NOT NULL
		BEGIN
			UPDATE DBServices.dbo.dbsDatabase 
			SET dbsDatabaseName = @name
				,dbsDatabaseIsActive = 1
				,dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1
				,[dbsDatabaseEntryDate]=getdate()	--modified date
			FROM DBServices.dbo.dbsDatabase
			WHERE dbsDatabaseUID = @dbsDatabaseUID
		
			SET @ErrorMsg = 'UBSMWE: usp_UpdatedbsDatabase: Database ' + @name 
							+ ' identified as back ONLINE - DB Maintenance re-activated' 
			EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1	-- raise an info

			GOTO NEXT_DB
		END
	END
	
	NEXT_DB:

	FETCH NEXT FROM dbsDatabase_cur
	INTO @name
		,@dbid   
		,@sid  
		,@mode   
		,@status 
		,@status2  
		,@crdate  
		,@reserved  
		,@category  
		,@cmptlevel 
		,@filename 
		,@version

END-- end while
CLOSE dbsDatabase_cur
DEALLOCATE dbsDatabase_cur

--------------------------------------------------------------------------------------------

IF @Init = 1
BEGIN
	UPDATE DBServices.dbo.dbsDatabase
	SET dbsDatabaseMSSQLCentralNeedsUpdateFlag = 1
END

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsDatabaseBackup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdatedbsDatabaseBackup]  @Init bit = 0
AS
/****************************************************************************************
// @File: usp_UpdatedbsDatabaseBackup.sql
// 
// @Version 6.0.0.29
// Purpose:
//   Insert Current list of databases from master..sysdatabases into local work table
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 02/12/2005 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Fixed issue with BackupType not updating properly
//   @Date: 25/01/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Fixed issue with create procedure statement (BUG identified by Shawn Crocker)
//   @Date: 29/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Added code to allow for use in Log Shipped operations
//   @Date: 16/10/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0.5 @Action: Updated for Logshipping Secondary database issue.
//   @Date: 25/10/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0.9 @Action: Updated for issue#34.
//   @Date: 15/12/2006 @Author: Kevin Wagner @Version: UBSMWE 2.5.0 @Action: Changed to include exception for backing up Readonly databases
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 07/02/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 HF For Start Servers. @Action: Updated section for exception date processing.
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 03/06/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4 @Action: Fixed for bug# 33 and 34
//   @Date: 03/06/2008 @Author: Kevin Wagner @Version: UBSMWE 5.0.7 @Action: Added Support for AlwaysON Replica exclussion from backups
//   @Date: 17/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 beta
//   @Date: 02/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.7 @Action: TRRv3 beta
//   @Date: 10/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 beta
//   @Date: 13/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.11 @Action: TRRv3 beta
//   @Date: 27/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.13 @Action: TRRv3 beta
//   @Date: 11/02/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.23 @Action: no_full exception update
//   @Date: 31/03/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.29 @Action: TRR-132 Feature request for DB file backup subfolders
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

--SELECT Default backup location
DECLARE @dbsInstanceFileLocation nvarchar(255),
		@RC int,
		@dbsExcludeAllUserDatabases bit,
		@dbsDBExternalBackupFlag bit,
		@dbsDatabaseUID uniqueidentifier, 
		@dbsDatabasedbid int, 
		@DatabaseName nvarchar(128),
		@dbsDatabaseIsActive bit,
		@dbsDBBackupType nvarchar(128),
		@dbsDBBackupType2 nvarchar(128),
		@IsDbNew int,
		@IncludeReadOnlyBackups nvarchar(2),
		@InstanceMajorVersion tinyint,
		@isAlwaysONSYNC bit,
		@dbsBackupProcessor tinyint,
		@islog nchar(1),
		@debug nchar(1),
		@i int,
		@DBNoFull bit,
		@dbsFSDBSubfolders bit,
		@FileLocation nvarchar(255),
		@exists bit,
		@astr nvarchar(1024)

-- Get config

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsExcludeAllUserDatabases', @dbsExcludeAllUserDatabases OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IncludeReadOnlyBackups', @IncludeReadOnlyBackups OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsBackupProcessor', @dbsBackupProcessor OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsFSDBSubfolders', @dbsFSDBSubfolders OUTPUT, @quiet=1

SET @InstanceMajorVersion = [DBServices].[dbo].[ufn_InstanceMajorVersion] ()                                                      

IF @Init = 1
BEGIN -- Initialise  
	UPDATE [DBServices].[dbo].[WorkFlowJob]
	SET [WFJobNeedsUpdate] = 1
END

-- TRIM @dbsInstanceFileLocation
SET @dbsInstanceFileLocation = LTRIM(RTRIM(@dbsInstanceFileLocation))
IF CHARINDEX('\',RIGHT(@dbsInstanceFileLocation, 1)) > 0
	SET @dbsInstanceFileLocation = LEFT(@dbsInstanceFileLocation, LEN(@dbsInstanceFileLocation) -1)

-----------------------------------------------------------------------------------------------------------
-- Determine DB list

DECLARE dbsDatabase_cur CURSOR FOR
SELECT 	d.dbsDatabaseUID	-- MWE DB GUID
	,d.dbsDatabasedbid		-- sys.databases id
	,d.dbsDatabaseName
	,CASE  -- dbsDBExternalBackupFlag
		WHEN (@dbsExcludeAllUserDatabases = 1			 -- Exclude all User DBs
				AND d.dbsDatabaseIsSystemObjectFlag = 0)
			AND NOT EXISTS (SELECT 1
				FROM DBServices.dbo.dbsDatabaseException dbe
				WHERE dbe.dbsDatabaseUID = d.dbsDatabaseUID -- note from main Query
					AND dbe.dbsExceptionActive = 1
					AND dbe.dbsDatabaseExceptionType = 'backup'
					AND dbe.dbsDatabaseExceptionSubType = 'external') -- No user exception
			THEN 1 -- Backups scheduled externally
		ELSE 0 -- Local MWE backups
	END as 'dbsDBExternalBackupFlag'
	,d.dbsDatabaseIsActive
	,CAST ((CASE --chkdbsDBBackupType
			WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Recovery' ) IS NULL THEN 'Decommissioned'
			WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Status' ) <> 'ONLINE' THEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Status' )
			WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'IsInStandBy' ) = 1 THEN 'STANDBY'
			WHEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Updateability' ) <> 'READ_WRITE' THEN DATABASEPROPERTYEX( d.dbsDatabaseName , 'Updateability' )
			ELSE CONVERT(nvarchar(128), DATABASEPROPERTYEX( d.dbsDatabaseName , 'Recovery' ) )
		END ) as nvarchar(128) ) as 'chkdbsDBBackupType'
	,dbb.dbsDBBackupType as 'olddbsDBBackupType'
	,CASE --  IsDbNew
		WHEN dbb.[dbsDatabaseUID] IS NULL THEN 1
		ELSE 0
	END AS 'IsDbNew'

FROM [DBServices].[dbo].[dbsDatabase] d
LEFT OUTER JOIN [DBServices].[dbo].[dbsDatabaseBackup] dbb 
	ON d.[dbsDatabaseUID] = dbb.[dbsDatabaseUID]
FOR UPDATE

------------------------------------------
-- For each valid DB

OPEN dbsDatabase_cur

FETCH NEXT FROM dbsDatabase_cur 
	INTO @dbsDatabaseUID
		, @dbsDatabasedbid
		, @DatabaseName
		, @dbsDBExternalBackupFlag
		, @dbsDatabaseIsActive
		, @dbsDBBackupType
		, @dbsDBBackupType2
		, @IsDbNew

WHILE (@@FETCH_STATUS = 0)
BEGIN  --begin while
	
	IF @dbsDatabaseIsActive = 1 AND @DatabaseName <> 'tempdb'
	BEGIN -- All ACTIVE Databases

		------------------------------------------
		-- determine if logshipped, if primary
		SET @islog = NULL
		EXEC [DBServices].[dbo].usp_isLogshipped @DatabaseName, @islog OUTPUT
		SET @dbsDBBackupType = CASE @islog
					WHEN 'P' THEN 'LS_Primary'
					WHEN 'S' THEN 'STANDBY'
					ELSE @dbsDBBackupType
				END

		------------------------------------------
		--SQL2012 and up AlwaysON Replicas are excluded from backup
		--due to Syncronization and the fact that they cannot do differential backup on replica	
	
		IF @InstanceMajorVersion >= 11 
		BEGIN
			SET @isAlwaysONSYNC = 1
			--Detect if Always on replicas

			SELECT @isAlwaysONSYNC = sys.fn_hadr_backup_is_preferred_replica(@DatabaseName)
			IF @isAlwaysONSYNC <> 1 
				SET @dbsDBBackupType = 'RESTORING' -- Note non AO DBs always return 1 for primary
		END
		------------------------------------------
	
		-- determine if DB backup no_fulls exception exists
		SET @DBNoFull = ISNULL(
				(SELECT TOP 1 1 
				FROM [DBServices].[dbo].dbsDatabaseException dbe 
				WHERE dbsDatabaseUID = @dbsDatabaseUID
					AND dbsExceptionActive = 1
					AND	dbsDatabaseExceptionType = LOWER('backup')
					AND	dbsDatabaseExceptionSubType = LOWER('no_full')) 
				, 0) 

		IF @debug = '2'
		BEGIN
			PRINT '--[usp_UpdatedbsDatabaseBackup]--------------------------------------------'
			SELECT 
				@dbsDatabaseUID as '@dbsDatabaseUID'
				, @dbsDatabasedbid as '@dbsDatabasedbid'
				, @DatabaseName as '@DatabaseName'
				, @dbsDBExternalBackupFlag as '@dbsDBExternalBackupFlag'
				, @dbsDatabaseIsActive as '@dbsDatabaseIsActive'
				, @dbsDBBackupType as '@dbsDBBackupType'
				, @dbsDBBackupType2 as '@dbsDBBackupType2'
				, @IsDbNew as '@IsDbNew'
		END

		-----------------------------------------------------------------------------------------------------------

		IF @dbsFSDBSubfolders = 1
			AND @dbsDBExternalBackupFlag = 0
		BEGIN
			-- FS DB Subfolders
			SET @FileLocation = @dbsInstanceFileLocation + '\' 
						+ [DBServices].[dbo].[ufn_SafeFileName](LEFT(@DatabaseName,64))

			EXEC @RC = [DBServices].[dbo].[usp_FileExists] @FileLocation, @exists OUTPUT

			IF ISNULL(@exists, 0) = 0
			BEGIN
				PRINT 'Folder ' + @FileLocation + ' does not exist - attempting to create'
				SET @astr = N'mkdir ' + @FileLocation
				EXEC @RC = master..xp_cmdshell @astr, no_output

				IF @RC <> 0
				BEGIN
					SET @astr = 'UBSMWE: usp_UpdatedbsDatabaseBackup: ERROR unable to create: ' + @FileLocation 
					EXEC [DBServices].[dbo].[usp_LogEvent] @astr, 2
				END -------------------
				ELSE 
					PRINT '- Successful'
			END
		END
		ELSE
			SET @FileLocation = @dbsInstanceFileLocation 

		-----------------------------------------------------------------------------------------------------------
		-- Create / Del WFT jobs 

		IF @IsDbNew = 1 
		BEGIN --All New databases 

			INSERT INTO [DBServices].[dbo].[dbsDatabaseBackup]
				(
					[dbsDatabaseUID], 
					[dbsDBBackupType],
					[dbsDBExternalBackupFlag],
					[dbsDBFileLocation], 
					[dbsDBMSSQLCentralNeedsUpdateFlag], 
					[dbsDBDoFullBackupNow],
					[dbsDBIsInRestoreProcess],
					[dbsDBIsInFullBackupProcess],
					[dbsDBIsInLogBackupProcess]
				)
	 		SELECT	@dbsDatabaseUID,
					@dbsDBBackupType, -- [dbsDBHBackupTypeID], FULL and Bulk_Logged = Trans also,  Simple = Database Only
					@dbsDBExternalBackupFlag,
					@FileLocation, --[dbsDBHFileLocation]
					1, --[dbsDBHMSSQLCentralNeedsUpdateFlag], 
					CASE @dbsDBExternalBackupFlag
						WHEN 0 THEN 1
						WHEN 1 THEN 0
					END, -- [dbsDBDoFullBackupNow] IF New databases should be fully backed up on next run. 
					0, -- [dbsDBIsInRestoreProcess] New database is not in restore process... Mark as 0
					CASE @dbsDBExternalBackupFlag
						WHEN 0 THEN 1
						WHEN 1 THEN 0
					END, -- [dbsDBIsInFullBackupProcess] IF New database is not in full backup process... Mark as 0
					0 -- [dbsDBIsInLogBackupProcess] New database is not in log backup process... Mark as 0
			

			--This is a dynamic param and changing the setting will be reflected in the next run of the UBSMWE.
			IF  ( @IncludeReadOnlyBackups = 0 AND @dbsDBBackupType IN ( 'FULL', 'BULK_LOGGED', 'SIMPLE', 'LS_Primary' ) )
				OR ( @IncludeReadOnlyBackups = 1 AND @dbsDBBackupType NOT IN ('RESTORING', 'STANDBY', 'OFFLINE', 'SUSPECT', 'RECOVERING', 'EMERGENCY') )
			BEGIN
				-- Create a 'CheckDB' backup job						
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 3 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 1 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				IF @dbsDBExternalBackupFlag = 0 
					AND @DBNoFull = 0
				BEGIN -- Create backup jobs

					-- Create a 'BUFull' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 1 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 1 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

					-- IF Tlog backups:
					IF @dbsDBBackupType  IN ('FULL', 'BULK_LOGGED')
					BEGIN 
						--Create log backup job
						EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
									,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 1 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
					END -------------------
					ELSE
					BEGIN
						--Delete log backup job
						EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
									,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
					END 
				END -- end - Create backup jobs

				--------------------------------------

				--If the Database status is not Online then do not create jobs for Reindex and UpdateStats
				IF @dbsDBBackupType IN ( 'FULL', 'BULK_LOGGED', 'SIMPLE', 'LS_Primary' ) 
				BEGIN
					-- Create a 'IDXRebuild' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 1 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

					-- Create a 'UpdateStats' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 1 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				END	-------------------
				ELSE
				BEGIN -- Tidy up
					-- Del the 'IDXRebuild' backup job if exists
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

					-- Del the 'UpdateStats' backup job if exists
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				END	
			END --------------------------------------
			ELSE
			BEGIN  -- Tidy up
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 1 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
								
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
								,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 3 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
			END
		END   -----------------------------------------------------------------------------------------------------------
		ELSE
		BEGIN --Manage existing databases

			--@IncludeReadOnlyBackups A PARAM IN THE dbsInstanceConfigTable and make the default be True for the IB.
			--This is a dynamic param and changing the setting will be reflected in the next run of the UBSMWE.
			IF  ( @IncludeReadOnlyBackups = 0 AND @dbsDBBackupType IN ( 'FULL', 'BULK_LOGGED', 'SIMPLE', 'LS_Primary' ) )
				OR ( @IncludeReadOnlyBackups = 1 AND @dbsDBBackupType NOT IN ('RESTORING', 'STANDBY', 'OFFLINE', 'SUSPECT', 'RECOVERING', 'EMERGENCY') )
			BEGIN -- IF in an 'online' state 

				--------------------------------------------------------------------
				-- Backup jobs

				IF @dbsDBExternalBackupFlag = 0
					AND @DBNoFull = 0
				BEGIN -- Manage backup jobs

					--  Create if not existing a 'BUFull' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 1 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 3 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

					--  Manage 'BULog' backup job
					IF @dbsDBBackupType  IN ('FULL', 'BULK_LOGGED')
					BEGIN -- Create if not existing log backup job
						EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
										,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
										,@ActionFlag = 3 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
					END -----------------
					ELSE
					BEGIN --Delete BUlog backup job
						EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
										,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
										,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
					END 
				END
				ELSE  --------------------------------------
				BEGIN	-- @dbsDBExternalBackupFlag = 1 or @DBNoFull = 1 - MWE NOT to backup DB
					-- Del backup jobs for DB

					-- Delete BUFull backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 1 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

					-- Delete BUlog backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
									,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				END 

				------------------------------------------
				-- Maintenance jobs 

				--  Create if not existing a 'CheckDB' backup job
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 3 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 3 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				IF @dbsDBBackupType IN ( 'FULL', 'BULK_LOGGED', 'SIMPLE', 'LS_Primary' )
				BEGIN
					--  Create if not existing a 'DBReindex' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 3 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

					--  Create if not existing a 'UpdateStats' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 3 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				END	 -----------------
				ELSE
				BEGIN
					--  Del 'DBReindex' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
					--  Del'UpdateStats' backup job
					EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
									,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
									,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				END
			END -- end - IF in an 'online' state 
			ELSE --------------------------------------------------------------------
			BEGIN	-- DB no longer available / in an 'online state; clean up respective jobs

				--  Del 'FullBackup' backup job
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 1 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				
				--  Del 'CheckDB' backup job
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 3 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				--  Del 'DBReindex' backup job
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

				--  Del 'UpdateStats' backup job
				EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
								,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
								,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing			
			END
			
			-----------------------------------------------------------------------------------------------------------

			--update the status in the dbsDatabaseBackup table
			IF EXISTS ( SELECT 1 
						FROM [DBServices].[dbo].[dbsD_DBE] 
						INNER JOIN [DBServices].[dbo].[dbsDatabaseBackupException] ddbe 
							ON	dbsD_DBE.dbsDatabaseBackupExceptionID = ddbe.dbsDatabaseBackupExceptionID
								AND	(ddbe.dbsDatabaseBackupExceptionType = LOWER('backup')) 
								AND	(ddbe.dbsDatabaseBackupExceptionSubType = LOWER('no_full'))
						WHERE dbsD_DBE.dbsDatabaseUID = @dbsDatabaseUID
							AND dbsD_DBE.dbsD_DBEIsActiveFlag = 1)
			BEGIN --Exception to skip a full backup exists for this database

				UPDATE dbsDatabaseBackup 
				SET dbsDBBackupType = @dbsDBBackupType
					,dbsDBExternalBackupFlag = @dbsDBExternalBackupFlag
					,dbsDBFileLocation = @FileLocation
					,dbsDBMSSQLCentralNeedsUpdateFlag = 1 
					,dbsDBDoFullBackupNow = 0 
					,dbsDBIsInFullBackupProcess =
						CASE @dbsDBExternalBackupFlag
							WHEN 0 THEN 1
							WHEN 1 THEN 0
						END -- [dbsDBIsInFullBackupProcess] IF New database is not in full backup process... Mark as 0
				WHERE dbsDatabaseUID = @dbsDatabaseUID 
					AND ( (dbsDBBackupType <> @dbsDBBackupType)	-- If backuptype has changed
						OR (dbsDBExternalBackupFlag <> @dbsDBExternalBackupFlag) ) -- or backup processor has changed to external 

			END -----------------------------------------
			ELSE 
			BEGIN --No exception Exists for this database

				UPDATE dbsDatabaseBackup 
				SET dbsDBBackupType = @dbsDBBackupType
					,dbsDBExternalBackupFlag = @dbsDBExternalBackupFlag
					,dbsDBFileLocation = @FileLocation
					,dbsDBMSSQLCentralNeedsUpdateFlag = 1 
					,dbsDBDoFullBackupNow = 
						CASE @dbsDBExternalBackupFlag
							WHEN 0 THEN 1
							WHEN 1 THEN 0
						END -- [dbsDBDoFullBackupNow] IF New databases should be fully backed up on next run. 
					,dbsDBIsInFullBackupProcess = CASE @dbsDBExternalBackupFlag
								WHEN 0 THEN 1
								WHEN 1 THEN 0
							END -- [dbsDBIsInFullBackupProcess] IF New database is not in full backup process... Mark as 0
				WHERE dbsDatabaseUID = @dbsDatabaseUID 
					AND ( (dbsDBBackupType <> @dbsDBBackupType)	-- If backuptype has changed
						OR (dbsDBExternalBackupFlag <> @dbsDBExternalBackupFlag) ) -- or backup processor has changed to external 
			END
		END --Manage existing databases
	
	END  -----------------------------------------------------------------------------------------------------------
	ELSE
	BEGIN -- DBs marked as inactive - Decom old database
	
		SET @i = CHARINDEX(' *OFFLINE*', @DatabaseName) -- del jobs for offline DBs
		IF @i > 0
			SET @DatabaseName = LEFT(@DatabaseName , @i-1)

		EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName 
						,@JobType = 1 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
						,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

		EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
						,@JobType = 2 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
						,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
						
		EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
						,@JobType = 3 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
						,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

		EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
						,@JobType = 4 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
						,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing

		EXEC [DBServices].[dbo].usp_ManageWorkFlowTaskJobs @DatabaseName = @DatabaseName  
						,@JobType = 5 --1 = FullBackup, 2 = Log, 3 = CheckDB, 4 = DBReindex, 5 =  UpdateStats
						,@ActionFlag = 2 --1 = Create Job, 2 = Delete Job, 3 = SPECIAL Case Create if not existing
				
		UPDATE dbsDatabaseBackup
		SET dbsDBBackupType = @dbsDBBackupType
		WHERE dbsDatabaseUID = @dbsDatabaseUID
		
	END --Decom old database

	-- end - Create / Del WFT jobs --------------------------------------------------------------------------------------------------

	FETCH NEXT FROM dbsDatabase_cur 
		INTO @dbsDatabaseUID
			, @dbsDatabasedbid
			, @DatabaseName
			, @dbsDBExternalBackupFlag
			, @dbsDatabaseIsActive
			, @dbsDBBackupType
			, @dbsDBBackupType2
			, @IsDbNew
END-- end while

CLOSE dbsDatabase_cur
DEALLOCATE dbsDatabase_cur

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsDatabaseBackup_Schedule]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdatedbsDatabaseBackup_Schedule] 
AS

/****************************************************************************************
// @File: usp_UpdatedbsDatabaseBackup_Schedule.SQL
// 
// Purpose:
//   Updates the schedule related information in the dbsDatabaseBackup table.
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//   
//   @Date: 04/26/2004 @Author: Kevin Wagner @Version: 1.5.1 @Action: Created
//   @Date: 11/01/2004 @Author: Kevin Wagner @Action: Updated for SMB failsafe log backups
//   @Date: 29/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Added code to allow for use in Log Shipped operations
//	 @Date: 05/02/1007 @Author: Kevin Wagner @Version: UBSMWE 2.5.0 @Action: Changed for OFFLINE databases.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 07/02/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 HF For Start Servers. @Action: Updated section for exception date processing.
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 21/09/2009 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.2 @Action: Updated for midnight spanning bug reported under bug# 69
//   @Date: 29/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @dbsDatabaseFullBackupStartTime nvarchar(50),
	@dbsDatabaseLogBackupStartTime nvarchar(50),
	@dbsDatabaseDBCCStartTime nvarchar(50),
	@dbsDatabaseIDXReorgStartTime nvarchar(50),
	@dbsDatabaseLogBackupIntervalMinute nvarchar(4),
	@dbsDatabaseLogBackupEndTime nvarchar(50),
	@NB_Enabled bit,
	@CV_Enabled bit,
	@NB_WindowStartTime nvarchar(50),
	@NB_WindowEndTime nvarchar(50),
	@dbsDatabaseLogPercentUsed nvarchar(3),
	@ActualLogPercentUsed int,
	@RC int,
	@IncludeReadOnlyBackups nvarchar(2),
	@ErrorMsg nvarchar(256),
	@debug bit
----------------------------------------------------------
-- Get Config

--Need to add error handeling code, but, for now, assume all is ok...
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupStartTime', @dbsDatabaseLogBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseDBCCStartTime', @dbsDatabaseDBCCStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseIDXReorgStartTime', @dbsDatabaseIDXReorgStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupIntervalMinute', @dbsDatabaseLogBackupIntervalMinute OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupEndTime', @dbsDatabaseLogBackupEndTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_Enabled', @NB_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_Enabled', @CV_Enabled OUTPUT 
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_WindowStartTime', @NB_WindowStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'NB_WindowEndTime', @NB_WindowEndTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'IncludeReadOnlyBackups', @IncludeReadOnlyBackups OUTPUT -- Added for SMB project failsafe.
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT

/*
//    Update the exception status
//    for the current schedule and toggle the flag to true if in the exception period 
//    and false if past exception date.
*/

IF @debug >= 2
	PRINT 'usp_UpdatedbsDatabaseBackup_Schedule:'

--Set the exception to 0, means no exception exists
IF NOT (ISDATE (@dbsDatabaseFullBackupStartTime)=1
	AND ISDATE (@dbsDatabaseLogBackupStartTime)=1
	AND ISDATE (@dbsDatabaseDBCCStartTime)=1
	AND ISDATE (@dbsDatabaseIDXReorgStartTime)=1
	AND ISDATE (@dbsDatabaseLogBackupEndTime)=1
	AND ISDATE (@NB_WindowStartTime)=1
	AND ISDATE (@NB_WindowEndTime)=1)
BEGIN
	SET @ErrorMsg = N'UBSMWE Error: usp_UpdatedbsDatabaseBackup_Schedule: Invalid time specified within table dbo.dbsInstanceConfig - unable to configure backup schedule!'
	PRINT @ErrorMsg
  	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3
  	SET @RC = 1
	GOTO END_IT	
END

--Not started yet
UPDATE DBServices.dbo.dbsD_DBE
SET	dbsD_DBEIsActiveFlag = 0
WHERE	dbsD_DBEIsActiveFlag = 1
	AND	dbsD_DBEStartDate < getdate() 

--No valid start date
UPDATE DBServices.dbo.dbsD_DBE
SET	dbsD_DBEIsActiveFlag = 0
WHERE	dbsD_DBEIsActiveFlag = 1
	AND	dbsD_DBEStartDate IS NULL 

--Only Set if the END Date is not null, otherwise, no end date exists.
UPDATE DBServices.dbo.dbsD_DBE
SET	dbsD_DBEIsActiveFlag = 0
WHERE	dbsD_DBEIsActiveFlag = 1
	AND	 ( dbsD_DBEEndDate < getdate() AND dbsD_DBEEndDate IS NOT NULL ) 

--Set the exception to 1, means exception exists

UPDATE DBServices.dbo.dbsD_DBE
SET	dbsD_DBEIsActiveFlag = 1
WHERE	dbsD_DBEIsActiveFlag = 0
	AND	dbsD_DBEStartDate <= getdate() 
	AND dbsD_DBEStartDate IS NOT NULL  
	AND  ( dbsD_DBEEndDate >= getdate() OR dbsD_DBEEndDate IS NULL )


--Set the exception status for the workflow tables 
UPDATE WorkFlowException
SET WFExceptionExists = CASE
						WHEN getdate() BETWEEN WFExceptionStartDate 
							AND DATEADD(mi, WFExceptionDurationMinutes
								, (DATEADD(dd, WFExceptionDurationDays, WFExceptionStartDate))) THEN 1
						ELSE 0
						END
FROM DBServices.dbo.WorkFlowException
	

UPDATE WorkFlowTaskException
SET WFTaskExceptionExists = CASE
							WHEN getdate() BETWEEN WFTaskExceptionStartDate
								AND DATEADD(mi, WFTaskExceptionDurationMinutes
									, (DATEADD(dd, WFTaskExceptionDurationDays, WFTaskExceptionStartDate))) THEN 1
							ELSE 0
							END
FROM DBServices.dbo.WorkFlowException
	

/*
//    The idea here is to update the full database backup flag
//    for the current schedule. This process only flips the flag to true.
//    The flag will be cleared when the database backup has run.
*/

UPDATE dbsDatabaseBackup
SET dbsDBDoFullBackupNow = 1 --dbsDBHNextFullBackupRun = getdate()
FROM DBServices.dbo.dbsDatabase d 
INNER JOIN DBServices.dbo.dbsDatabaseBackup db 
  ON d.dbsDatabaseUID = db.dbsDatabaseUID 
LEFT OUTER JOIN	dbsD_DBE 
	ON db.dbsDatabaseUID = dbsD_DBE.dbsDatabaseUID 
		AND dbsDatabaseBackupExceptionID 
			IN (SELECT dbsDatabaseBackupExceptionID FROM dbsDatabaseBackupException 
				WHERE dbsDatabaseBackupExceptionType = N'Backup'
					AND dbsDatabaseBackupExceptionSubType = N'No Full')  
WHERE (d.dbsDatabaseIsActive = 1) 
	AND	(d.dbsDatabaseName NOT IN ('tempdb', 'Northwind', 'pubs')) 
	AND	( (GETDATE() >= dbsDBNextFullBackupRun) or dbsDBNextFullBackupRun IS NULL )
	AND	(dbsD_DBE.dbsD_DBEIsActiveFlag = 0 OR dbsD_DBE.dbsD_DBEIsActiveFlag IS NULL)
	AND	db.dbsDBBackupType NOT IN ('RESTORING', 'STANDBY', 'OFFLINE')
	AND	(db.dbsDBExternalBackupFlag = 0)		--Need to check this one out

UPDATE dbsDatabaseBackup
SET dbsDBDoFullBackupNow = 0 --dbsDBHNextFullBackupRun = getdate()
FROM DBServices.dbo.dbsDatabase d 
INNER JOIN DBServices.dbo.dbsDatabaseBackup db 
	ON d.dbsDatabaseUID = db.dbsDatabaseUID 
WHERE ( d.dbsDatabaseIsActive = 0 AND db.dbsDBDoFullBackupNow = 1 )
	OR ( db.dbsDBBackupType IN ('RESTORING', 'STANDBY', 'OFFLINE') AND db.dbsDBDoFullBackupNow = 1 )
	OR ( d.dbsDatabaseIsActive = 1
		AND db.dbsDBDoFullBackupNow = 1 
		AND @IncludeReadOnlyBackups = 0
		AND db.dbsDBBackupType NOT IN ('FULL', 'BULK_LOGGED', 'SIMPLE', 'LS_Primary' )
		)

--LOG DATABASE BACKUP
IF GETDATE() BETWEEN dbo.ufn_ParseMWETime (@dbsDatabaseLogBackupStartTime) AND dbo.ufn_ParseMWETime (@dbsDatabaseLogBackupEndTime) 
BEGIN -- Set to run a tlog backup
	BEGIN TRY
		UPDATE dbsDatabaseBackup
		SET dbsDBDoLogBackupNow = 1
		FROM DBServices.dbo.[dbsDatabase] d
		INNER JOIN DBServices.dbo.[dbsDatabaseBackup] db 
			ON 	d.[dbsDatabaseUID] = db.[dbsDatabaseUID]
		LEFT OUTER JOIN	dbsD_DBE 
			ON	db.dbsDatabaseUID = dbsD_DBE.dbsDatabaseUID 
			AND dbsDatabaseBackupExceptionID IN 
				(SELECT dbsDatabaseBackupExceptionID
				FROM dbsDatabaseBackupException 
				WHERE dbsDatabaseBackupExceptionType = N'Backup'
					AND dbsDatabaseBackupExceptionSubType = N'No Log')  
		WHERE d.dbsDatabaseIsActive = 1 
			AND	db.dbsDBBackupType IN ( 'FULL', 'BULK_LOGGED', 'LS Primary' )
			AND	d.dbsDatabaseName NOT IN ( 'tempdb' )
			AND	( GETDATE() >= dbsDBNextLogBackupRun OR	dbsDBNextLogBackupRun IS NULL )
			AND	(dbsD_DBE.dbsD_DBEIsActiveFlag = 0 OR dbsD_DBE.dbsD_DBEIsActiveFlag IS NULL)	
	END TRY
	BEGIN CATCH
		SET @RC = @@ERROR
		PRINT 'UBSMWE Error: usp_UpdatedbsDatabaseBackup_Schedule: Unhandled exception: ' + CAST(@RC as varchar(5)) + ' - LOG DATABASE BACKUP - Set to run a tlog backup'
	END CATCH
END
ELSE -----------------------------------
BEGIN -- Set not to run a tlog backup
	BEGIN TRY
		UPDATE dbsDatabaseBackup
		SET dbsDBDoLogBackupNow = 0
 		FROM DBServices.dbo.[dbsDatabase] d
		INNER JOIN DBServices.dbo.[dbsDatabaseBackup] db 
			ON 	d.[dbsDatabaseUID] = db.[dbsDatabaseUID]
		WHERE 	d.dbsDatabaseIsActive = 1 
	END TRY
	BEGIN CATCH
		SET @RC = @@ERROR
		PRINT 'UBSMWE Error: usp_UpdatedbsDatabaseBackup_Schedule: Unhandled exception: ' + CAST(@RC as varchar(5)) + ' - LOG DATABASE BACKUP - Set not to run a tlog backup'
	END CATCH
END

--TODO
--Begin code for Log Backup exception processing, will backup log reguardless of time constraints if above failsafe log utilization threshold 

--select *
--
--FROM 	[dbsDatabase] d
--JOIN 	[dbsDatabaseBackup] dbh 
--	ON 	d.[dbsDatabaseUID] = dbh.[dbsDatabaseUID]
--JOIN 	master..sysperfinfo mspi
--	ON 	d.[dbsDatabaseName] = mspi.[instance_name]
--WHERE 	d.dbsDatabaseIsActive = 1 
--	AND	dbh.dbsDBHBackupType IN ( 'FULL', 'BULK_LOGGED' )
--	AND	d.dbsDatabaseName NOT IN ( 'tempdb' )
--	AND mspi.counter_name = 'Percent Log Used'
--	AND mspi.cntr_value > 70


--NB_ schedule update, will initially hold this in the general config table...
--Sets NB_WindowFlag true when in the window, else, sets it to 0

--SELECT '@NB_WindowStartTime =',@NB_WindowStartTime 
--SELECT '@NB_WindowEndTime =',@NB_WindowEndTime 

IF @NB_Enabled = 1 OR @CV_Enabled = 1
BEGIN 
	IF @NB_WindowStartTime < @NB_WindowEndTime
	BEGIN
		IF GETDATE() BETWEEN dbo.ufn_ParseMWETime (@NB_WindowStartTime) AND dbo.ufn_ParseMWETime (@NB_WindowEndTime)
		BEGIN
			--todo
			PRINT 'Not midnight span - Flag = True'
			EXEC usp_UpdatedbsInstanceConfig 'NB_WindowFlag', '1'
		END
		ELSE
		BEGIN
			PRINT 'Not midnight span - Flag = False'
			--todo
			EXEC usp_UpdatedbsInstanceConfig 'NB_WindowFlag', '0'
		END
	END	
	ELSE ------------------------
	BEGIN
		--Ok, we span midnight, so, need to see if we are between Start time and Midnight or Midnight and End time. If so, set to true
		--We need to do it this way so we can get around having to know to add or subtract 24 hrs from getdate()
		IF (GETDATE() BETWEEN dbo.ufn_ParseMWETime (@NB_WindowStartTime) AND dbo.ufn_ParseMWETime ('23:59'))
			OR (GETDATE() BETWEEN dbo.ufn_ParseMWETime ('00:00' ) AND dbo.ufn_ParseMWETime (@NB_WindowEndTime ))
		BEGIN
			--todo
			PRINT 'Midnight span - Flag = True'
			EXEC usp_UpdatedbsInstanceConfig 'NB_WindowFlag', '1'
		END
		ELSE
		BEGIN
			PRINT 'Midnight span - Flag = False'
			--todo
			EXEC usp_UpdatedbsInstanceConfig 'NB_WindowFlag', '0'
		END
	END		

END --@NB_Enabled = 1

END_OK:
RETURN 0

END_IT:
RETURN 1

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsDatabaseBackupHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdatedbsDatabaseBackupHistory] @dbsDBHID bigint, @dbsDBHEndDate datetime
AS

/****************************************************************************************
// @File: usp_UpdatedbsDatabaseBackupHistory.SQL
// 
// Purpose:
//   Insert Current list of databases from master..sysdatabases into local work table
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 19/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Updated for expanded Netbackup Functionality
//   @Date: 01/08/2006 @Author: Kevin Wagner @Version: UBSMWE 2.0 @Action: Updated for MSSQLCentral Integration
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.0 @Action: Final release to production
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 25/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @dbsDatabaseUID char(36)
	,@RC int

UPDATE [DBServices].[dbo].[dbsDatabaseBackupHistory]
SET	[dbsDBHEndDate] = @dbsDBHEndDate
WHERE dbsDBHID = @dbsDBHID

SELECT @dbsDatabaseUID = dbsDatabaseUID
FROM [DBServices].[dbo].[dbsDatabaseBackupHistory]
WHERE dbsDBHID = @dbsDBHID

EXEC @RC = [DBServices].[dbo].[msc_UpdatedbsDatabaseBackupHistory] 
	 @dbsDBHID = @dbsDBHID
	,@dbsDatabaseUID = @dbsDatabaseUID
	,@dbsDBHEndDate = @dbsDBHEndDate

RETURN @RC

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsDatabaseException]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdatedbsDatabaseException]
AS

/****************************************************************************************
// @File: usp_UpdatedbsDatabaseException.sql
// 
// Purpose:
//   Update the [dbsDatabaseException] table dbsDatabaseUID's 
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History: @DateFormat DD/MM/YYYY
//
//   @Date: 07/02/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9 @Action: Created for Bug: dbsDatabaseUID recreated upon UBSMWE reinstallation but fails to update the [dbsDatabaseException] table
//   @Date: 21/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.4 @Action: TRRv3 Beta tidyup
//
****************************************************************************************/

BEGIN  --Begin main()
SET DATEFORMAT ymd
SET NOCOUNT ON

IF EXISTS(SELECT TOP 1 dbsDB.[dbsDatabaseName] as 'dbsDatabaseUID Mismatch'
			FROM [DBServices].[dbo].[dbsDatabase] as dbsDB
			INNER JOIN [DBServices].[dbo].[dbsDatabaseException] dbsDBEx
				ON dbsDB.dbsDatabaseName = dbsDBEx.dbsDatabasename
			WHERE dbsDB.[dbsDatabaseUID] <> dbsDBEx.[dbsDatabaseUID]
				AND dbsDB.[dbsDatabaseIsActive] = 1)
BEGIN
	-- Mismatch found - update [dbsDatabaseException].[dbsDatabasedbid]
	UPDATE dbsDBEx
	SET dbsDBEx.dbsDatabaseUID = dbsDB.dbsDatabaseUID
	FROM [DBServices].[dbo].[dbsDatabase] as dbsDB
	INNER JOIN  [DBServices].[dbo].[dbsDatabaseException] dbsDBEx
		ON dbsDB.dbsDatabaseName = dbsDBEx.dbsDatabasename
	WHERE dbsDB.[dbsDatabaseIsActive] = 1
END

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsInstanceConfig]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdatedbsInstanceConfig] 	@dbsInstanceConfigName nvarchar(255)
						,@dbsInstanceConfigValue nvarchar(255)
AS

/****************************************************************************************
// @File: usp_UpdatedbsInstanceConfig.SQL
// 
// Purpose:
//   Update dbsInstanceConfig table with given value
//
// History: Dates are in mm/dd/yyyy format
//
//   @Version: 6.0.0.0
//   @Author: Kevin Wagner 
//   @Date: 10/05/2004
//   @Action: Created.
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//	 @Date: 29/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta 
//
****************************************************************************************/

BEGIN  --Begin main()

SET DATEFORMAT ymd
SET NOCOUNT ON 

DECLARE @RC INT
	,@CurrentdbsInstanceConfigValue nvarchar(255)

SET @dbsInstanceConfigName = LTRIM(RTRIM(@dbsInstanceConfigName))
SET @dbsInstanceConfigValue = LTRIM(RTRIM(@dbsInstanceConfigValue))

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] @dbsInstanceConfigName, @CurrentdbsInstanceConfigValue OUTPUT, 1 
IF @RC <> 0 -- entry not found
BEGIN
	INSERT INTO dbsInstanceConfig
	VALUES 	(@dbsInstanceConfigName, @dbsInstanceConfigValue)
END
ELSE -- @RC=0 - entry found
BEGIN
	UPDATE 	dbsInstanceConfig
	SET 	dbsInstanceConfigValue = @dbsInstanceConfigValue
	WHERE 	dbsInstanceConfigName = @dbsInstanceConfigName
END 

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdatedbsUBSMWEHeartbeat]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_UpdatedbsUBSMWEHeartbeat] 
		@stage varchar(255),
		@LogNTEvent sql_variant  = 0

AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_UpdatedbsUBSMWEHeartbeat.SQL
// 
// Purpose:
//   Provide Heartbeat function for UBSMWE schedule
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//   @DateFormat DD/MM/YYYY
//   @Date: 26/04/2004 @Author: Kevin Wagner @Version: Beta SWX @Action: Created
//   @Date: 31/10/2004 @Author: Kevin Wagner @Version: 1.5.0 @Action: Updated with new functionality to log to nt event log.
//	@LogNTEvent_Int = 0 --Do not log to NT event log 
//	@LogNTEvent_Int = 1 --log informational message to NT event log (blue i in a white baloon)
//	@LogNTEvent_Int = 2 --log warning message to NT event log (black ! in yellow triangle)
//	@LogNTEvent_Int = 3 --log error message to NT event log (white X in red circle)
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
//
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT  ON
/*
//    The idea here is to monitor the running of the main UBSMWE
//    Each running of the 
*/
DECLARE @debug int,
	@Count int,
	@LogNTEvent_Int int

SELECT @LogNTEvent_Int = convert(int, @LogNTEvent)

-- Can not use the standard statement since this call would fail due to recoursion... exec dbo.usp_GetbsInstanceConfig 'DEBUG', @debug
SELECT @debug = convert(int, dbsInstanceConfigValue) FROM dbsInstanceConfig WHERE dbsInstanceConfigName = 'DEBUG'

--Main Run Mode, just update first column...

IF @debug = 0 
	BEGIN

		SELECT @Count = count([dbsUBSMWEHeartbeatID]) FROM [dbsUBSMWEHeartbeat]
		IF @Count <> 1
			BEGIN
				DELETE FROM [DBServices].[dbo].[dbsUBSMWEHeartbeat]
				INSERT INTO [DBServices].[dbo].[dbsUBSMWEHeartbeat]( [dbsUBSMWEHeartbeatDate], [dbsUBSMWEHeartbeatStage])
				VALUES( getdate(), 'Initial update on first use from ' + @stage)
			END
		ELSE
			BEGIN
				UPDATE 	[dbsUBSMWEHeartbeat]
				SET	[dbsUBSMWEHeartbeatDate] = getdate(),
					[dbsUBSMWEHeartbeatStage] = 'Stage  --  ' + @stage
			END
	END
ELSE
	BEGIN
		--Debug Mode, just insert steps as run...
 			INSERT INTO [DBServices].[dbo].[dbsUBSMWEHeartbeat]( [dbsUBSMWEHeartbeatDate], [dbsUBSMWEHeartbeatStage])
 			VALUES( getdate(), 'Stage ' + @stage)
	END


	IF @LogNTEvent_Int = 1 or (@debug = 1 and @LogNTEvent_Int = 0)
		BEGIN
			EXEC master..xp_logevent 60000, @stage, informational
		END
	IF @LogNTEvent_Int = 2
		BEGIN
			EXEC master..xp_logevent 60000, @stage, warning
		END
	IF @LogNTEvent_Int = 3
		BEGIN
			EXEC master..xp_logevent 60000, @stage, error
		END
	

--Debug Mode, just insert steps as run...
-- 			INSERT INTO [DBServices].[dbo].[dbsUBSMWEHeartbeat]( [dbsUBSMWEHeartbeatDate], [dbsUBSMWEHeartbeatStage])
-- 			VALUES( getdate(), 'Stage ' + @stage)



END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdateMWEVersion]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdateMWEVersion] @dbsSetVersion nvarchar(255)=null
AS

/****************************************************************************************
// @File: usp_UpdateMWEVersion.SQL
// Purpose:
//			Recreates MWE Main Engine Job with new Version
//			Updates dbsObjectVersions variable on dbsinstanceconfig table
//
// History: Date Format: dd/mm/yyyy
//
//   @Date: 19/03/2013 @Author: Steve Trogub @Version: 5.0.3 @Action: Created
//   @Date: 19/03/2013 @Author: Steve Trogub @Version: 5.0.3 @Action: Final release to production
//   @Date: 08/08/2014 @Author: Chris Basson @Version: 6.0.0.1 @Action: Tidy up mess
//   @Date: 26/02/2015 @Author: Chris Basson @Version: 6.0.0.25 @Action: MSSQL scheduler spin workaround
//   @Date: 02/07/2015 @Author: Chris Basson @Version: 6.0.0.34 @Action: Code review
//
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE @Jobs TABLE 
	( 	JobVal	int	IDENTITY,
		JobID	UNIQUEIDENTIFIER
	)

DECLARE  @dbsHighestVersion nvarchar(32)
		,@dbsProcID int 
		,@dbsProcName nvarchar(128)
		,@dbsProcVersion nvarchar(32)
		,@dbsVersion nvarchar(255)
		,@Enginename sysname
		,@i int
		,@JobID UNIQUEIDENTIFIER
		,@MajorVersion tinyint
		,@MiddleVersion tinyint
		,@MinorVersion tinyint
		,@NumberOfProcs int
		,@ProcName varchar(128)
		,@RC int
		,@skipUpdate bit	
		,@SQL varchar(2000)
		,@SubMinorVersion int
		,@tmpMajorVersion nvarchar(3)
		,@tmpMiddleVersion nvarchar(3)
		,@tmpMinorVersion nvarchar(3)
		,@tmpSubMinorVersion nvarchar(3)
		,@astr varchar(2000)
		,@KeepValues varchar(10)

-------------------------------------

--disable update by default
SET @skipUpdate=1

--check if DBServices exists
IF db_id('DBServices') IS NULL 
	GOTO QuitDBMissing

--Get current UBSMWE version
EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsVersion', @dbsVersion OUTPUT 

IF ISNULL(@dbsSetVersion, '') <> ''
BEGIN
	SET @skipUpdate=0

	GOTO UPDATE_VER_DO
END
ELSE
	PRINT '**** Experimenal - versions listed may be incorrect thus data can only be used as a guideline ****' +  CHAR(13)

-------------------------------------
--obtain Global MWE verison form all relevant procs

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#Result%' AND type in (N'U'))
	DROP TABLE [dbo].[#Result] 

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#ProcList%' AND type in (N'U'))
	DROP TABLE [dbo].[#ProcList] 

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#tbl_ProcVersion%' AND type in (N'U'))
	DROP TABLE [dbo].[#tbl_ProcVersion] 

CREATE TABLE #Result
	(TextField varchar(8000), ProcName nvarchar(128))

CREATE TABLE #ProcList
	(ID int IDENTITY
	,ProcName nvarchar(128)
	,ProcVersion nvarchar(512)
	,UNIQUE NONCLUSTERED (ID ASC) )

CREATE TABLE #ProcVersion
	(ProcVersion_ID int IDENTITY
	,ProcName nvarchar(128)
	,astr nvarchar(1024)
	,UNIQUE NONCLUSTERED (ProcVersion_ID ASC) )

-------------------------------------
-- populate the ProcName table with the procedure names:

INSERT #ProcList 
SELECT DISTINCT [name], NULL 
FROM [DBServices]..[sysobjects]
WHERE xtype = 'P'

SELECT @NumberOfProcs = COUNT(*)
FROM #ProcList

DECLARE cur_ProcList CURSOR LOCAL DYNAMIC
FOR SELECT ProcName
FROM #ProcList

OPEN cur_ProcList

FETCH NEXT FROM cur_ProcList
	INTO @ProcName
WHILE (@@FETCH_STATUS <> -1)
BEGIN

	SET @SQL = 'INSERT INTO #Result (TextField) EXEC sp_helptext ' + @ProcName
	EXEC (@SQL)

	UPDATE #Result 
	SET ProcName = @ProcName 
	WHERE ProcName IS NULL

	FETCH NEXT FROM cur_ProcList
		INTO @ProcName
END

CLOSE cur_ProcList
DEALLOCATE cur_ProcList

-------------------------------------
-- Determine proc version

INSERT INTO #ProcVersion
SELECT ProcName = ProcName
		,astr = LTRIM(RTRIM(
			SUBSTRING (UPPER(TextField)
			,(CHARINDEX ('@VERSION:', UPPER(TextField)) + 10)
			,ABS((CHARINDEX ('@ACTION:', UPPER(TextField)) - (CHARINDEX ('@VERSION:', UPPER(TextField)) + 10) ))
			) ))
FROM #Result
WHERE UPPER(TextField) LIKE '//%@VERSION:%'
ORDER BY ProcName DESC

------------------

SET @KeepValues = '%[^0-9.]%'

DECLARE cur_ProcVersion CURSOR LOCAL DYNAMIC
FOR SELECT astr
FROM #ProcVersion
FOR UPDATE

OPEN cur_ProcVersion

FETCH NEXT FROM cur_ProcVersion
	INTO @dbsProcVersion
WHILE (@@FETCH_STATUS <> -1)
BEGIN
    WHILE PATINDEX(@KeepValues, @dbsProcVersion) > 0
        SET @dbsProcVersion = STUFF(@dbsProcVersion, PATINDEX(@KeepValues, @dbsProcVersion), 1, '')

	UPDATE #ProcVersion
	SET astr = @dbsProcVersion
	WHERE CURRENT OF cur_ProcVersion

	FETCH NEXT FROM cur_ProcVersion
		INTO @dbsProcVersion
END

CLOSE cur_ProcVersion
DEALLOCATE cur_ProcVersion


-- Clear up nulls, invalid entries
UPDATE #ProcList
SET ProcVersion = '0'
WHERE ISNULL(ProcVersion,'') = ''
	OR ISNUMERIC(REPLACE(ProcVersion,'.','')) = 0

------------------

UPDATE #ProcList
SET ProcVersion = astr
FROM #ProcList
INNER JOIN #ProcVersion
	ON #ProcVersion.ProcName = #ProcList.ProcName
WHERE astr = (
			SELECT TOP 1 astr
			FROM #ProcVersion
			WHERE #ProcVersion.ProcName = #ProcList.ProcName
			GROUP BY ProcName, ProcVersion_ID, astr 
			ORDER BY ProcVersion_ID DESC
			)

/*
SELECT ProcName, ProcVersion
FROM #ProcList
ORDER BY ProcVersion DESC

GOTO QuitDBMissing
*/
-------------------------------------
-- Parse versions

SELECT @tmpMajorVersion = SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split('.', @dbsVersion) WHERE RowID=1
SELECT @tmpMiddleVersion=  SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split('.', @dbsVersion) WHERE RowID=2
SELECT @tmpMinorVersion =  SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split('.', @dbsVersion) WHERE RowID=3
SELECT @tmpSubMinorVersion=SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split('.', @dbsVersion) WHERE RowID=4

SET @MajorVersion = CAST(LEFT(@tmpMajorVersion,2) as tinyint)
SET @MiddleVersion = CAST(LEFT(@tmpMiddleVersion,2) as tinyint)
SET @MinorVersion = CAST(LEFT(@tmpMinorVersion,2) as tinyint)
SET @SubMinorVersion = CAST(LEFT(@tmpSubMinorVersion,2) as tinyint)


DECLARE procver_cur CURSOR FOR
SELECT ID, ProcName, ProcVersion
FROM #ProcList
ORDER BY ProcVersion DESC

OPEN procver_cur

FETCH NEXT FROM procver_cur
	INTO @dbsProcID, @dbsProcName, @dbsProcVersion
WHILE (@@fetch_status <> -1)
BEGIN
	IF (@@fetch_status <> -2)
    BEGIN	
		
		SELECT @tmpMajorVersion = SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split( '.',@dbsProcVersion ) WHERE RowID=1
		SELECT @tmpMiddleVersion=  SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split( '.',@dbsProcVersion ) WHERE RowID=2
		SELECT @tmpMinorVersion =  SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split( '.',@dbsProcVersion ) WHERE RowID=3
		SELECT @tmpSubMinorVersion=SUBSTRING(Value, PATINDEX('%[^0 ]%', Value + ' '), LEN(Value)) FROM dbo.fn_Split( '.',@dbsProcVersion ) WHERE RowID=4

		PRINT @dbsProcName + ' : ' + @dbsProcVersion

		IF CAST(LEFT(@tmpMajorVersion,2) as tinyint) > @MajorVersion
			AND ISNULL(@dbsSetVersion,'') = '' 
		BEGIN
			PRINT CHAR(13) + 'Procedure ' + @dbsProcName
					+ ' has Major Version ' + @dbsProcVersion + ' which is higher then exisintg ' + @dbsVersion
			PRINT 'This stored procedure can only update Middle version and down'
			PRINT '(Major Versions can only be incremented by a new package)'

			RAISERROR ('Major Version can only be incremented by a new package', 16, 1);
		END

		IF CAST(LEFT(@tmpMajorVersion,2) as tinyint) >= @MajorVersion 
		BEGIN
			SET @MajorVersion = CAST(LEFT(@tmpMajorVersion,2) as tinyint)

			IF CAST(LEFT(@tmpMiddleVersion,2) as tinyint) >= @MiddleVersion 
			BEGIN 
				SET @MiddleVersion = CAST(LEFT(@tmpMiddleVersion,2) as tinyint)

				IF CAST(LEFT(@tmpMinorVersion,2) as tinyint) >= @MinorVersion 
				BEGIN
					SET @MinorVersion = CAST(LEFT(@tmpMinorVersion,2) as tinyint)

					IF CAST(LEFT(@tmpSubMinorVersion,2) as tinyint) >= @MinorVersion 
						SET @MinorVersion = CAST(LEFT(@tmpSubMinorVersion,2) as tinyint)
				END
			END 
		END 
	END
     
	FETCH NEXT FROM procver_cur
		INTO @dbsProcID, @dbsProcName, @dbsProcVersion
END

CLOSE procver_cur
DEALLOCATE procver_cur


PRINT CHAR(13) + '**** Experimenal - versions listed may be incorrect thus data can only be used as a guideline ****'

-- Skipping next bit of code as parsing is not reliable enough to determine the version
GOTO END_OK

/*
--------------------

SET @dbsHighestVersion = ISNULL(CAST(@MajorVersion as nvarchar(3)),'0')
						 + '.' + ISNULL(CAST(@MiddleVersion as nvarchar(3)),'0') 

IF @MinorVersion IS NOT NULL  
	SET @dbsHighestVersion = @dbsHighestVersion
							 + '.' + CAST(@MinorVersion as nvarchar(3))

IF @SubMinorVersion IS NOT NULL  
	SET @dbsHighestVersion = @dbsHighestVersion
							+ '.' + CAST(@SubMinorVersion as nvarchar(3))

IF @dbsVersion = @dbsHighestVersion
BEGIN
	PRINT CHAR(13) + 'Global Version unchanged: ' + @dbsHighestVersion
	GOTO END_OK
END --------------------
ELSE
BEGIN
	PRINT CHAR(13) + 'New Global Version will be: ' + @dbsHighestVersion

	SET @skipUpdate = 0
	SET @dbsSetVersion = @dbsHighestVersion
END
*/


-------------------------------------
-- Re-create MWE main engine job

UPDATE_VER_DO:

IF @skipUpdate = 1 
	GOTO END_OK

EXEC @RC = DBServices.dbo.usp_UpdatedbsInstanceConfig 'dbsVersion', @dbsSetVersion

-----------------
-- Remove old engine job if exists of category name of DBS_%%

SET @i = 1

INSERT INTO @Jobs (JobID)
SELECT S.job_id  
FROM msdb..sysjobs S
INNER JOIN  msdb..syscategories  C
	ON C.category_id = S.category_id 
WHERE S.name  LIKE 'UBSMWE_Engine_%'

WHILE (@i <= (SELECT MAX(JobVal) FROM @Jobs)) 
BEGIN 
	PRINT 'Deleting existing UBSMWE_Engine job'

	SELECT @JobID = JobID
	FROM @Jobs
	WHERE JobVal = @i 

	EXEC @RC=msdb..sp_delete_job @job_id = @JobID
	IF (@RC <> 0)
		PRINT ' Error deleting SQL job ' + CAST (@JobID AS VARCHAR(36)) + ' FROM scheduler '
				
	SET @i = @i + 1 
END 

-----------------
-- Create the engine job

SET @JobID = NULL 
SET @RC = 0    

BEGIN TRANSACTION            

DECLARE @today int
SET @today = CAST(CONVERT(char(8), getdate() ,112) as int)

IF (SELECT COUNT(*) FROM msdb.dbo.syscategories WHERE name = N'UBSMWE_Engine') < 1 
	EXEC msdb.dbo.sp_add_category @name = N'UBSMWE_Engine'

PRINT N'Orig Version: ' + @dbsVersion
PRINT N'New Version: ' + @dbsSetVersion

SET @Enginename = N'UBSMWE_Engine_(' + LTRIM(RTRIM(@dbsSetVersion)) + ')'

BEGIN 
	-- Add the job
	EXEC @RC = msdb.dbo.sp_add_job @job_id = @JobID OUTPUT ,  
											@job_name = @Enginename,  
											@owner_login_name = N'sa',  
											@description = N'UBSMWE_Engine',  
											@category_name = N'UBSMWE_Engine',  
											@enabled = 1,  
											@notify_level_email = 0,  
											@notify_level_page = 0,  
											@notify_level_netsend = 0,  
											@notify_level_eventlog = 3,  
											@delete_level= 0
	IF @RC <> 0
		GOTO QuitWithRollback 
  
	-- Add the job steps
	DECLARE @step_id int

	SET @step_id = 1

	EXEC @RC = msdb.dbo.sp_add_jobstep @job_id = @JobID, 
											@step_id = @step_id, 
											@step_name = N'usp_UBSMWE_Engine', 
											@command=N'EXEC DBServices.dbo.usp_UBSMWE_Engine',  
											@database_name = N'DBServices', 
											@server = N'', 
											@database_user_name = N'', 
											@subsystem = N'TSQL', 
											@cmdexec_success_code = 0, 
											@flags = 4, 
											@retry_attempts = 0, 
											@retry_interval = 1,  
											@output_file_name = N'',  
											@on_success_step_id = 0,  
											@on_success_action = 1,  
											@on_fail_step_id = 0,  
											@on_fail_action = 2
	IF @RC <> 0
		GOTO QuitWithRollback 

	EXEC @RC = msdb.dbo.sp_update_job @job_id = @JobID,  
											@start_step_id = 1 
	IF @RC <> 0
		GOTO QuitWithRollback 

	-- Add the job schedules
	EXEC @RC = msdb.dbo.sp_add_jobschedule @job_id = @JobID, @name = N'UBSMWE_Engine',  
											@enabled = 1,  
											@freq_type = 4,  
											@active_start_date = @today,  
											@active_start_time = 0,  
											@freq_interval = 1,  
											@freq_subday_type = 4,  
											@freq_subday_interval = 10,  
											@freq_relative_interval = 0,  
											@freq_recurrence_factor = 0,  
											@active_end_date = 99991231,  
											@active_end_time = 235959
	IF @RC <> 0
		GOTO QuitWithRollback

	-- Add the Target Servers
	EXEC @RC = msdb.dbo.sp_add_jobserver @job_id = @JobID,  
											@server_name = N'(local)'
	IF @RC <> 0
		GOTO QuitWithRollback
END

-------------------------------------
COMMIT TRANSACTION      

PRINT '-----------------------------------------------------------------------------------'
PRINT CHAR(13) + '=> Restart the job ' + @Enginename + ' to ensure the change takes effect.'
PRINT CHAR(13) + '*** Please note an initial cycle can take upto 15mins to process ***'

-------------------------------------
END_OK:

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#Result%' AND type in (N'U'))
	DROP TABLE [dbo].[#Result] 

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#ProcList%' AND type in (N'U'))
	DROP TABLE [dbo].[#ProcList] 

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#tbl_ProcVersion%' AND type in (N'U'))
	DROP TABLE [dbo].[#tbl_ProcVersion] 

RETURN 0           

-------------------------------------
QuitWithRollback:
  IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION 

----------------
QuitDBMissing:

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#Result%' AND type in (N'U'))
	DROP TABLE [dbo].[#Result] 

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#ProcList%' AND type in (N'U'))
	DROP TABLE [dbo].[#ProcList] 

IF EXISTS (SELECT * FROM tempdb..sysobjects WHERE name LIKE '%#tbl_ProcVersion%' AND type in (N'U'))
	DROP TABLE [dbo].[#tbl_ProcVersion] 

RETURN 1

END --End main()


GO
/****** Object:  StoredProcedure [dbo].[usp_UpdateUBSMWEJobLogs]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdateUBSMWEJobLogs]
AS
/****************************************************************************************
// @File: usp_UpdateUBSMWEJobLogs.SQL
// @Version: 6.0.0.9
// 
// Purpose:
//   Updates UBSMWE WF and WFT Job log output files
//
// Notes: This stored procedure is called FROM main UBSMWE. Can be run by hand if needed.
//
// History: Date Format dd/mm/yyyy
//
//	 @Date  30/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta
****************************************************************************************/
BEGIN -- main

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
	, @sysjobs_JobID uniqueidentifier
	, @JobName nvarchar(255)
	, @JType tinyint
	, @sysjobs_StepID int
	, @JobStepName  nvarchar(255)
	, @sysjobs_StartStepID int
	, @JobLogFile nvarchar(200)
	, @CurrJobLogFile nvarchar(200)
	, @sysjobs_Flag tinyint -- 0=Overwrite file, 2=Append
	, @debug tinyint
	, @ErrorMsg nvarchar(512)
 
DECLARE @MWEActiveJobList TABLE (sysjobs_JobID uniqueidentifier, JobName nvarchar(255), JType tinyint)

SET @sysjobs_Flag = 0 -- 0=Overwrite file, 2=Append
-------------------------

EXEC [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT

-- Obtain JobList
INSERT INTO @MWEActiveJobList
SELECT DISTINCT WFsysjobsJobID, WFJobName, 1
FROM DBServices.dbo.WorkFlowJob

INSERT INTO @MWEActiveJobList
SELECT DISTINCT WFTaskJobID, WFTaskName, 2
FROM DBServices.dbo.WorkFlowTask
WHERE WFTaskEnabled = 1

-------------------------
-- Set Job Log

DECLARE jscur CURSOR LOCAL FAST_FORWARD FOR
SELECT DISTINCT mwej.sysjobs_JobID
	,mwej.JobName
	,mwej.JType
	,sjs.step_id
	,step_name
	,sj.start_step_id 
	, sjs.output_file_name 
FROM @MWEActiveJobList mwej
INNER JOIN [msdb].[dbo].sysjobs sj
	ON sj.job_id = mwej.sysjobs_JobID
INNER JOIN [msdb].[dbo].sysjobsteps sjs
	ON sjs.job_id = sj.job_id
WHERE step_name <> 'Log Error'
OPEN jscur

FETCH NEXT FROM jscur 
INTO @sysjobs_JobID 
	, @JobName 
	, @JType
	, @sysjobs_StepID 
	, @JobStepName 
	, @sysjobs_StartStepID
	, @CurrJobLogFile
WHILE @@FETCH_STATUS=0 
BEGIN
	
	EXEC @RC = DBServices.dbo.usp_GetLogfilename 
					@WFTaskname = @JobName
					, @FileName = @JobLogFile OUTPUT

	IF @JType = 1
		SET @JobLogFile =  REPLACE (@JobLogFile, '.log', '_Step_' + CAST(@sysjobs_StepID as varchar(2)) + '.log' )

	IF @debug >=2
	BEGIN
		PRINT '--Debug usp_UpdateUBSMWEJobLogs ------------------------'
		SELECT @JobName as '@JobName'
			, @sysjobs_StepID as '@sysjobs_StepID'
			, @JobStepName as '@JobStepName'
			, @CurrJobLogFile as '@CurrJobLogFile'
			, @JobLogFile as '@JobLogFile'
			, @sysjobs_Flag as '@sysjobs_Flag'
		PRINT '--------------------------------------------------------'
	END

	IF @RC = 0 
	BEGIN 
		IF ISNULL(@CurrJobLogFile,'') <> @JobLogFile
		BEGIN ---------------------------
			-- Set Job Log DO
			EXEC @RC = [msdb].[dbo].sp_update_jobstep 
				@job_id = @sysjobs_JobID
				, @step_id = @sysjobs_StepID
				, @output_file_name = @JobLogFile 
				, @flags = @sysjobs_Flag
		
			IF @RC <> 0
				GOTO END_IT -- ERROR
		END
		ELSE
			PRINT 'Job Log file is already matching or empty'
	END
	ELSE 
		GOTO END_IT -- ERROR

	FETCH NEXT FROM jscur 
	INTO @sysjobs_JobID 
		, @JobName 
		, @JType
		, @sysjobs_StepID 
		, @JobStepName 
		, @sysjobs_StartStepID
		, @CurrJobLogFile
END
CLOSE jscur
DEALLOCATE jscur 

RETURN 0 -- Success

----------------
END_IT:

CLOSE jscur
DEALLOCATE jscur 

SET @ErrorMsg = 'UBSMWE: usp_UpdateUBSMWEJobLogs: ERROR: Unable to set the Job Log file for: '
	+ @JobName + ' step: ' + @JobStepName 
	+ ' Log file: '+  @JobLogFile + ' - exiting, Investigation required'

EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2
RETURN 1

END -- main

SET QUOTED_IDENTIFIER OFF 

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdateWorkFlowJob]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdateWorkFlowJob] 
					(	@WFJobID			uniqueidentifier = NULL
						,@WFJobName			nvarchar(255)= NULL
						,@WFsysjobsJobID	uniqueidentifier = NULL
						,@WFJobDescription	nvarchar(255) = NULL
						,@WFCommand 		nvarchar(512) = NULL
						,@WFCommandDatabase	nvarchar(128) = NULL
						,@WFJobStatus 		bit				-- 0 = Disabled, 1 = Enabled
						,@WFJobStartTime 	char(8) = NULL	-- 03:00:00 default.
						,@WFJobFreq 		varchar(10)= NULL
						,@WFRunWorkFlowFlag bit = NULL		--wtf was varchar(8)!						 
					)					
AS
/************************************************************************************************
Name: 		usp_UpdateWorkFlowJob.SQL
Purpose:	Updates  WorkFlowJob table.
              
//  @Date: 29/02/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Created
//  @Date: 20/03/2008 @Author: Kevin Wagner @Version: 2.5.3 @Action: Final release to production
//  @Date: 02/07/2014 @Author: Chris Basson @Version: 6.0.0 @Action: TRRv3 Beta
//  @Date: 02/10/2014 @Author: Chris Basson @Version: 6.0.0.7 @Action: TRRv3 Beta
//  @Date: 19/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Bugfix dbsDatabaseFullBackupStartTime issue
************************************************************************************************/

BEGIN -- Main
SET NOCOUNT ON
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week

DECLARE @RC int
		,@SQL nvarchar(4000)

SELECT  @WFJobName = LTRIM(RTRIM(@WFJobName))
	   ,@WFJobDescription = LTRIM(RTRIM(@WFJobDescription))
	   ,@WFCommand = LTRIM(RTRIM(@WFCommand))
	   ,@WFCommandDatabase = LTRIM(RTRIM(@WFCommandDatabase))
	   ,@WFJobStartTime = LTRIM(RTRIM(@WFJobStartTime))
	   ,@WFJobFreq = LTRIM(RTRIM(@WFJobFreq))

------------------------------------

IF @WFJobID IS NULL 
	AND ISNULL(@WFJobName,'') = ''
BEGIN
	PRINT 'UBSMWE: usp_UpdateWorkFlowJob: A valid WFJobID or WFJobName is required'
	RETURN (-1)
END

--Seed the variables with existing info
IF @WFJobID IS NULL
BEGIN
	SELECT @WFJobID = WFJobID
	FROM DBServices.dbo.WorkFlowJob
	WHERE WFJobName = @WFJobName
END
ELSE
BEGIN
	SELECT @WFJobName = WFJobName 
	FROM DBServices.dbo.WorkFlowJob
	WHERE @WFJobID = WFJobID

	IF @WFJobName IS NULL
	BEGIN
		PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Job ' + @WFJobName + ' was not found'
		RETURN (-1)	
	END
END

-- check data validity
IF ISNULL(@WFJobStartTime,'') <> ''
BEGIN
	IF LEN(@WFJobStartTime) = 5
		SET @WFJobStartTime = @WFJobStartTime + ':00'

	IF PATINDEX('%%:%%:%%', @WFJobStartTime) = 0
		AND ISDATE(@WFJobStartTime) = 0
	BEGIN
		PRINT 'UBSMWE: usp_UpdateWorkFlowJob: @WFJobStartTime Invalid time format'
		PRINT 'Time should entered in the format - HH:MM:SS'
		RETURN (1)
	END
END

IF ISNULL(@WFJobFreq,'') <> '' 
BEGIN
	IF LOWER(@WFJobFreq) NOT IN('sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'hourly', 'daily', 'weekly', 'monthly', 'bufull', 'bulog', 'manual', 'netbackup')
	BEGIN
		PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Invalid Job execution frequency - ' + @WFJobFreq 
		PRINT 'valid type - ''sunday'', ''monday'', ''tuesday'', ''wednesday'', ''thursday'', ''friday'', ''saturday'', ''hourly'', ''daily'', ''weekly'', ''monthly'', ''bufull'', ''bulog'', ''manual'', ''netbackup'''
		PRINT ' '
		RETURN (1)
	END
END

------------------------------------
--If We have a name but no id, this is a new record

IF @WFJobID IS NULL
	AND @WFJobName IS NOT NULL 
BEGIN
	--Insert new record into the WorkFlowJob table
	SET @WFJobID = newid()

	SELECT @WFJobID
	   ,@WFJobName
	   ,@WFsysjobsJobID
	   ,@WFJobDescription
	   ,@WFCommand
	   ,@WFCommandDatabase
	   ,@WFJobStatus
	   ,@WFJobStartTime
	   ,@WFJobFreq
	   ,@WFRunWorkFlowFlag

	INSERT INTO [DBServices].[dbo].[WorkFlowJob]
	   ([WFJobID]
	   ,[WFJobName]
	   ,[WFsysjobsJobID]
	   ,[WFJobDescription]
	   ,[WFCommand]
	   ,[WFCommandDatabase]
	   ,[WFJobStatus]
	   ,[WFJobStartTime]
	   ,[WFJobFreq]
	   ,[WFJobNeedsUpdate]
	   ,[WFRunWorkFlowFlag])
	VALUES
	   (@WFJobID
	   ,@WFJobName
	   ,@WFsysjobsJobID
	   ,@WFJobDescription
	   ,@WFCommand
	   ,@WFCommandDatabase
	   ,@WFJobStatus
	   ,@WFJobStartTime
	   ,@WFJobFreq
	   ,1
	   ,@WFRunWorkFlowFlag )

	-- Update Job & scheduled job if any
	SET @RC = @@ERROR
	IF @RC <> 0
	BEGIN 
		PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Unable to insert new record into WorkFlowJob - ' + @WFJobName
		RETURN (1)
	END
	ELSE
		PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Added WorkFlowJob - ' + @WFJobName
END	------------------------------------
ELSE -- Existing
BEGIN
	-- Update with new info.
	IF @WFJobID IS NOT NULL
	BEGIN
		UPDATE [DBServices].[dbo].[WorkFlowJob]
		SET [WFJobID]			= ISNULL(@WFJobID, WFJobID)
		  ,[WFJobName]			= ISNULL(@WFJobName, WFJobName)
		  ,[WFsysjobsJobID]		= ISNULL(@WFsysjobsJobID, WFsysjobsJobID)
		  ,[WFJobDescription]	= ISNULL(@WFJobDescription,  WFJobDescription)
		  ,[WFCommand]			= ISNULL(@WFCommand, WFCommand)
		  ,[WFCommandDatabase]	= ISNULL(@WFCommandDatabase,  WFCommandDatabase)
		  ,[WFJobStatus]		= ISNULL(@WFJobStatus, WFJobStatus)
		  ,[WFJobStartTime]		= ISNULL(@WFJobStartTime, WFJobStartTime)
		  ,[WFJobFreq]			= ISNULL(@WFJobFreq, WFJobFreq)
		  ,[WFJobNeedsUpdate]	= 1
		  ,[WFRunWorkFlowFlag] = ISNULL(@WFRunWorkFlowFlag, WFRunWorkFlowFlag)
		WHERE WFJobID = @WFJobID

		SET @RC = @@ERROR
		IF @RC <> 0
		BEGIN 
			PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Unable to update record in WorkFlowJob table for ' + @WFJobName
			RETURN (1)
		END
		ELSE
			PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Updated WorkFlowJob - ' + @WFJobName
	END
	ELSE --@WFJobID IS NULL
	BEGIN
		UPDATE [DBServices].[dbo].[WorkFlowJob]
		SET [WFJobID]				= ISNULL(@WFJobID, WFJobID)
			,[WFJobName]			= ISNULL(@WFJobName, WFJobName)
			,[WFsysjobsJobID]		= ISNULL(@WFsysjobsJobID, WFsysjobsJobID)
			,[WFJobDescription]		= ISNULL(@WFJobDescription,  WFJobDescription)
			,[WFCommand]			= ISNULL(@WFCommand, WFCommand)
			,[WFCommandDatabase]	= ISNULL(@WFCommandDatabase,  WFCommandDatabase)
			,[WFJobStatus]			= ISNULL(@WFJobStatus, WFJobStatus)
			,[WFJobStartTime]		= ISNULL(@WFJobStartTime, WFJobStartTime)
			,[WFJobFreq]			= ISNULL(@WFJobFreq, WFJobFreq)
			,[WFJobNeedsUpdate]		= 1
			,[WFRunWorkFlowFlag]	= ISNULL(@WFRunWorkFlowFlag, WFRunWorkFlowFlag)
		WHERE WFJobName = @WFJobName

		SET @RC = @@ERROR
		IF @RC <> 0
		BEGIN 
			PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Unable to update record in WorkFlowJob table for ' + @WFJobName
			RETURN (1)
		END
		ELSE
		BEGIN
			PRINT 'UBSMWE: usp_UpdateWorkFlowJob: Updated WorkFlowJob - ' + @WFJobName
		END

	END
END

RETURN 0

END -- Main


GO
/****** Object:  StoredProcedure [dbo].[usp_UpdateWorkFlowTask]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_UpdateWorkFlowTask] @WFTaskName nvarchar(255) = NULL
												,@WFTaskTypeName nvarchar(255) = NULL
												,@WFTaskEnabled int = NULL
												,@WFTaskPriority int = NULL
												,@WFTaskID uniqueidentifier = NULL OUTPUT 
												,@WFTaskJobID uniqueidentifier = NULL 
												,@dbsDatabaseUID uniqueidentifier = NULL 
AS
SET DATEFORMAT ymd
SET NOCOUNT ON
/****************************************************************************************
// @File: usp_UpdateWorkFlowTask.SQL
// 
// Purpose:
//   Update WorkFlowTask table with given value
// Returns 0 for success and non 0 for failure
//

// History: Dates are in mm/dd/yyyy format
//
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 02/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 Beta
//
****************************************************************************************/

BEGIN  --Begin main()

DECLARE @WFTaskTypeID int

SET @WFTaskName= LTRIM(RTRIM(@WFTaskName))

--First check to make sure we have the TaskName.
IF @WFTaskName IS NULL 
BEGIN
	PRINT 'usp_UpdateWorkFlowTask: Must supply WFTaskName...'
	RETURN -1
END
ELSE IF @WFTaskID IS NULL
BEGIN
	SELECT @WFTaskID = WFTaskID 
	FROM dbo.WorkFlowTask 
	WHERE  WFTaskName = LTRIM(RTRIM(@WFTaskName))
END

IF EXISTS (SELECT * FROM DBServices.dbo.WorkFlowTask WHERE WFTaskID = @WFTaskID )
BEGIN
	UPDATE WorkFlowTask
	SET  WFTaskName = LTRIM(RTRIM(ISNULL(@WFTaskName, WFTaskName)))
		,WFTaskTypeID = ISNULL(@WFTaskTypeID, WFTaskTypeID)
		,WFTaskEnabled = ISNULL(@WFTaskEnabled, WFTaskEnabled)
		,WFTaskPriority = ISNULL(@WFTaskPriority, WFTaskPriority)
		,WFTaskJobID = ISNULL(@WFTaskJobID, WFTaskJobID)
		,dbsDatabaseUID = ISNULL(@dbsDatabaseUID, dbsDatabaseUID)
	WHERE WFTaskID = @WFTaskID
END
ELSE
BEGIN
	--SELECT @WFTaskID = NEWID() --Should always have valid Job id before entering into this table, no need to generate id at this point.

	IF @WFTaskID IS NULL
		SELECT @WFTaskID = newid()

	SELECT @WFTaskTypeID = WFTaskTypeID
	FROM	DBServices.dbo.WorkFlowTaskType
	WHERE	WFTaskTypeName = LTRIM(RTRIM(@WFTaskTypeName))

	IF @WFTaskID IS NOT NULL
		AND @WFTaskName IS NOT NULL
		AND @WFTaskTypeID IS NOT NULL
		AND @WFTaskEnabled IS NOT NULL
		AND @WFTaskPriority IS NOT NULL
	BEGIN

		INSERT INTO [dbo].[WorkFlowTask]
				   ([WFTaskID]
				   ,[WFTaskName]
				   ,[WFTaskTypeID]
				   ,[WFTaskEnabled]
				   ,[WFTaskPriority]
				   ,[dbsDatabaseUID])
			 VALUES
				   (@WFTaskID
				   ,@WFTaskName
				   ,@WFTaskTypeID
				   ,@WFTaskEnabled
				   ,@WFTaskPriority
				   ,@dbsDatabaseUID)
	END
	ELSE
	BEGIN
		PRINT 'usp_UpdateWorkFlowTask: Unable to insert a new record, please verify the input parameters'
		RETURN -1
	END
END	


END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_UpdateWorkFlowTaskHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_UpdateWorkFlowTaskHistory] @WFTaskHistoryID bigint
												,@WFTaskEndDate datetime
												,@WFTaskIsError int = 0
												,@WFTaskResultText nvarchar(2000) = 'OK'





AS
SET DATEFORMAT ymd
/****************************************************************************************
// @File: usp_UpdateWorkFlowTaskHistory.SQL
// 
// Purpose:
//   Update the WorkFlowTaskHistory table with end run information.
//
// Notes: This stored procedure is called from main UBSMWE. Do not run by hand.
//
// History:
//
//   @Date: 26/02/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Created
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/

BEGIN  --Begin main()

/*
// Set current status in heartbeat
*/
--	EXEC usp_UpdatedbsUBSMWEHeartbeat 'start usp_UpdateWorkFlowTaskHistory'

/*
//    
*/
	DECLARE @dbsDatabaseUID nvarchar(255)

	UPDATE [DBServices].[dbo].[WorkFlowTaskHistory]
	SET	[WFTaskEndDate] = @WFTaskEndDate
		,WFTaskIsError = @WFTaskIsError
		,WFTaskResultText = @WFTaskResultText
	WHERE WFTaskHistoryID = @WFTaskHistoryID

/*
	DECLARE @RC int

	SELECT @dbsDatabaseUID = dbsDatabaseUID
	FROM dbo.WorkFlowTaskHistory
	WHERE dbsDBHID = @dbsDBHID


	SELECT @dbsDatabaseUID, @dbsDBHID

	EXECUTE @RC = [DBServices].[dbo].[msc_UpdateWorkFlowTaskHistory] 
	 @dbsDBHID = @dbsDBHID, @dbsDatabaseUID = @dbsDatabaseUID, @dbsDBHEndDate = @dbsDBHEndDate
*/
	/*
	// Set current status in heartbeat
	*/
	--	EXEC usp_UpdatedbsUBSMWEHeartbeat 'finish usp_UpdateWorkFlowTaskHistory'


END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_WFST_PostCommand]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_WFST_PostCommand] (
				@WFTaskID_txt nvarchar(50)
				, @WFTaskHistoryID bigint
				, @ErrCode int)		-- error code pass through
AS

/****************************************************************************************
// @File: usp_WFST_PostCommand.SQL
//
// @Version 6.0.0.21
//
// Purpose:
//   MWE workflowtask job post step
//
// Notes: This stored procedure is called from db jobs.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 21/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 BETA
//   @Date: 08/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.6 @Action: TRRv3 BETA
//   @Date: 19/01/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.21 @Action: ERROR severity raised to 11
****************************************************************************************/

BEGIN --main

SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @RC int
	, @EndDate datetime

SET @EndDate = getdate()
IF @ErrCode = 0
BEGIN
	-- Successful
	EXEC @RC = [DBServices].[dbo].[usp_UpdateWorkFlowTaskHistory] 
			@WFTaskHistoryID = @WFTaskHistoryID
			, @WFTaskEndDate = @EndDate
			, @WFTaskIsError = 0
			, @WFTaskResultText = 'OK'

	UPDATE DBServices.dbo.WorkFlowTask
	SET WFTaskIsRunningFlag = 0
	WHERE WFTaskID = @WFTaskID_txt
END	
ELSE
BEGIN
	-- Failure
	EXEC @RC = [DBServices].[dbo].[usp_UpdateWorkFlowTaskHistory] 
		@WFTaskHistoryID = @WFTaskHistoryID
		, @WFTaskEndDate = @EndDate
		, @WFTaskIsError = @ErrCode
		, @WFTaskResultText = 'Error during execution of task, '

	UPDATE DBServices.dbo.WorkFlowTask
	SET WFTaskIsRunningFlag = 0
	WHERE WFTaskID = @WFTaskID_txt 

	RAISERROR ('There was a problem... see the job logs for more info', 11, 1) WITH NOWAIT
END

RETURN @ErrCode	-- passing through the error code for trapping

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_WFST_PreCommand]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_WFST_PreCommand] (
				@dbsDatabaseUID as uniqueidentifier
				, @dbsJobName as nvarchar(255)
				, @WFTaskID as uniqueidentifier
				, @WFTaskID_txt nvarchar(50)
				, @WFTaskHistoryID bigint OUTPUT) 
AS

/****************************************************************************************
// @File: usp_WFST_PreCommand.SQL
//
// @Version 6.0.0
//
// Purpose:
//   MWE workflowtask job step
//
// Notes: This stored procedure is called from db jobs.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 21/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0 @Action: TRRv3 BETA

****************************************************************************************/

BEGIN --main

SET DATEFORMAT ymd
SET NOCOUNT ON
SET DATEFIRST 7

DECLARE @RC int
		,@rtnTaskHistoryID bigint

EXEC DBServices.dbo.usp_GetWorkFlowSubTaskJobState @dbsDatabaseUID, @dbsJobName 

UPDATE DBServices.dbo.WorkFlowTask
SET WFTaskIsRunningFlag = 1
WHERE WFTaskID =  @WFTaskID_txt 

EXEC [DBServices].[dbo].[usp_InsertWorkFlowTaskHistory] @WFTaskID, @rtnTaskHistoryID OUTPUT
SET @RC = @@ERROR

SET @WFTaskHistoryID = @rtnTaskHistoryID

RETURN @RC

END --main

GO
/****** Object:  StoredProcedure [dbo].[usp_wget]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_wget] (@url nvarchar(255))
AS

/****************************************************************************************
// @File: usp_wget.SQL
//
// @Version 6.0.0.31
//
// Purpose:
//   Make http call and capture output.
//   Use to control TRR interface for CommVault configuration
// Notes: This stored procedure is called from main UBSMWE cv_backup stored procedure.
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: Beta General @Action: Created
//   @Date: 05/05/2012 @Author: Steve Trogub @Version: UBSMWE 4.1.0 @Action: Make http call from  T-SQL
//   @Date: 06/12/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.5 @Action: using wget.exe packaged with BRAT
//   @Date: 10/09/2013 @Author: Steve Trogub @Version: UBSMWE 5.0.8 @Action: added the -T -t timeout=30min,retrys=1
//   @Date: 12/08/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.1 @Action: TRRv3 Beta
//   @Date: 09/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 02/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.7 @Action: TRRv3 Beta
//   @Date: 31/10/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.9 @Action: TRRv3 Beta - Simplified
//   @Date: 05/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 04/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.14 @Action: TRRv3 
//   @Date: 10/06/2015 @Author: Chris Basson @Version: UBSMWE 6.0.0.31 @Action: Trap null output 
****************************************************************************************/

BEGIN  --Begin main()
SET NOCOUNT ON
SET DATEFORMAT ymd

DECLARE 	
	@dbsInstanceFileLocation nvarchar(255)
	,@wget_path nvarchar(255)
	,@RC int
	,@response nvarchar(512)
	,@return_value nvarchar(255)
	,@return_message nvarchar(4000)
	,@rstring varchar(40)
	,@sql nvarchar(4000)
	,@tempFile nvarchar(255)
	,@tmpstr varchar(8000)
	,@wgetcommand nvarchar(2000)
	,@MajorVersion tinyint
	,@ErrorMsg nvarchar(512)
	,@fexists bit
	,@debug tinyint

--set defaults
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsInstanceFileLocation', @dbsInstanceFileLocation OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'debug', @debug OUTPUT

EXEC usp_FileExists @dbsInstanceFileLocation ,@fexists OUTPUT
IF @fexists = 0
	SET @dbsInstanceFileLocation = 'C:\temp'	-- Should be set and existing however if not use c:\temp 

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'CV_ExecutableLocation', @tempFile OUTPUT

----------------------------------------------------

SET @wget_path = REPLACE (REPLACE ( @tempFile ,'cvbackup.cmd', 'wget.exe' ) ,'Program Files','PROGRA~1')

EXEC [DBServices].[dbo].[usp_FileExists] @wget_path ,@fexists OUTPUT
IF @fexists = 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_wget: wget.exe missing, expected location: ' 
		+ @wget_path + ' - Investigation required, UBSMWE has either not been installed or configured correctly; verify parameter: CV_ExecutableLocation'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 3 -- error

	GOTO END_IT
END

----------------------------------------------------
-- exec wget

SET @rstring=''
IF NOT RIGHT(@dbsInstanceFileLocation, 1) = '\' 
	SET @dbsInstanceFileLocation = @dbsInstanceFileLocation + '\'

EXEC @RC = [DBServices].[dbo].[usp_Gen_rnd_filename] N'_wget', @rstring OUTPUT
SET @tempFile = @dbsInstanceFileLocation + @rstring 
PRINT 'Temp file: ' + @tempFile

---------------

IF OBJECT_ID('tempdb..#wget_output') IS NOT NULL 
	DROP TABLE #wget_output

CREATE TABLE #wget_output (result nvarchar(512))
	
SET @wgetcommand = @wget_path + ' -q --timeout=1800 --tries=1 --no-check-certificate -O "' 
						+ @tempFile + '" "' + @url + '"'

IF @debug >= 2
	PRINT @wgetcommand

INSERT INTO #wget_output
	EXEC master..xp_cmdshell @wgetcommand

-------------
WAITFOR DELAY '00:00:03'

EXEC [DBServices].[dbo].[usp_FileExists] @tempFile, @fexists OUTPUT
IF @fexists = 0
BEGIN
	SET @ErrorMsg = 'UBSMWE: usp_wget: Output file missing: ' + @tempFile
		+ ' - please verify the dbsInstanceFileLocation path is correctly configured'
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1 

	GOTO END_IT
END 
-- ELSE continue..

SELECT @response = [result] 
FROM #wget_output 
WHERE [result] LIKE '%ERRMSG%'					

IF ISNULL(@response,'') = ''
	GOTO PARSE_OUTPUT
ELSE
IF CHARINDEX ('already exists', LOWER(@response)) > 1
	PRINT 'UBSMWE: usp_wget: Response keyword [already exists] - assuming OK :' + @response
ELSE
BEGIN
	SELECT [result] as 'wget_output'
	FROM #wget_output 

	SET @ErrorMsg = 'UBSMWE: usp_wget: configuration cmd failed: ' + @response
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning

	GOTO END_IT
END					

----------------------------------------------------
-- Parse output

PARSE_OUTPUT:	

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp
           
CREATE TABLE #tmp (line nvarchar(4000))

SET @sql = 'BULK INSERT #tmp
    FROM ''' + @tempFile + '''
    WITH (FirstRow = 1, FieldTerminator = ' + '''' + ' ' + '''' + ', RowTerminator = ' + '''' + '\n' + '''' + ')'
EXEC(@sql)


SELECT @RC = COUNT(*)
FROM #tmp
WHERE line IS NOT NULL

IF @RC = 0
BEGIN
	SELECT [result] as 'wget_output'
	FROM #wget_output 

	SET @ErrorMsg = 'UBSMWE: usp_wget: ERROR - output file empty for: ' + @url
	EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 2 -- warning

	GOTO END_IT
END

DECLARE procver_cur CURSOR FORWARD_ONLY FOR
SELECT line
FROM #tmp
OPEN procver_cur

FETCH NEXT FROM procver_cur 
INTO @tmpstr

WHILE (@@fetch_status <> -1)
BEGIN 
	SELECT @return_value=LTRIM(RTRIM(Value)) 
	FROM dbo.fn_Split( '=',@tmpstr ) 
	WHERE RowID = 2

	SELECT @return_message=LTRIM(RTRIM(Value))
	FROM dbo.fn_Split( '=',@tmpstr )
	WHERE RowID = 3
	   
	FETCH NEXT FROM procver_cur
	INTO @tmpstr
END
    
CLOSE procver_cur
DEALLOCATE procver_cur
      
----------------------------------------------------

PRINT 'Result: ' + @return_value
PRINT 'Message:' + @return_message

IF CHARINDEX('ERROR', @return_value) <> 0
	AND CHARINDEX ('already exists', LOWER(@return_message)) = 0
	GOTO END_IT

-- Tidy up temp file
EXEC [DBServices].[dbo].[usp_DelFile] @Filename = @tempFile

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

IF OBJECT_ID('tempdb..#wget_output') IS NOT NULL 
	DROP TABLE #wget_output

RETURN 0

----------------------------------------------------    
END_IT:

IF OBJECT_ID('tempdb..#tmp') IS NOT NULL 
	DROP TABLE #tmp

IF OBJECT_ID('tempdb..#wget_output') IS NOT NULL 
	DROP TABLE #wget_output

RETURN 1

END  --End main()

GO
/****** Object:  StoredProcedure [dbo].[usp_WorkFlowAddJobs]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_WorkFlowAddJobs] 	
	(	@WFJobID			uniqueidentifier,
		@WFJobName			nvarchar(256),
		@WFJobDescription	nvarchar(256),
		@WFCommand			nvarchar(512), 
		@WFCommandDatabase	nvarchar(128), 
		@WFJobStatus		int, 
		@WFJobStartTime		varchar(10), 
		@WFJobFreq			varchar(10),
		@WFJobNeedsUpdate	bit = 0,
		@WFRunWorkFlowFlag	bit = 1,
		@WFsysjobsJobID		uniqueidentifier output
	)
		
AS

/************************************************************************************************
//Name: usp_WorkFlowAddJobs.SQL
//Purpose:	Creates the WorkFlow driving job
//
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 13/06/2014 @Author: Chris Basson @Version: UBSMWE 5.0.9.3 @Action: Bugfix: Deletion of non UBSMWE jobs
//   @Date: 30/07/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.0 @Action: TRRv3 Beta
//   @Date: 08/09/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.6 @Action: TRRv3 Beta
//   @Date: 10/11/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.10 @Action: TRRv3 Beta
//   @Date: 26/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: BRAT support for non-alpha numerics in DB names
************************************************************************************************/

BEGIN -- Main
SET DATEFORMAT ymd
SET DATEFIRST 7 -- Sunday = 1st day of week
SET NOCOUNT ON

DECLARE @WorkFlowLog						nvarchar(255)
		,@WorkFlowCommand					nvarchar(512)
		,@ErrorMsg							nvarchar(512)
		,@WorkFlowStartdate					varchar(10)	
		,@WorkFlowStartTime					varchar(10)
		,@WorkFlowFrequencyType				int
		,@RC								int
		,@WorkFlowsysjobsID					uniqueidentifier 
		,@WFfreq_interval					int
		,@WFfreq_subday_type				int
		,@WFfreq_subday_interval			int
		,@WFfreq_relative_interval			int
		,@WFfreq_recurrence_factor			int
		,@WFactive_end_date					varchar(10)
		,@WFactive_end_time					varchar(10)
		,@dbsDatabaseFullBackupStartTime	varchar(10)
		,@dbsDatabaseLogBackupStartTime		varchar(10)
		,@dbsDatabaseDBCCStartTime			varchar(10)
		,@dbsDatabaseIDXReorgStartTime		varchar(10)
		,@dbsDatabaseLogBackupIntervalMinute varchar(4)
		,@dbsDatabaseLogBackupEndTime		varchar(10)
		,@dbsDatabaseLogPercentUsed			varchar(3)
		,@ActualLogPercentUsed				tinyint
		,@dbsDatabaseLogBackupPercentUsed	varchar(3)
		,@WFstep_id							tinyint
		,@WFJobStepExistingCount			tinyint
		,@WFName							nvarchar(255)
		,@WFPriority						int
		,@WorkFlowLogFile					varchar(255)
		,@WorkFlowLogFileInput				varchar(255)
		,@WFFlags							int
		,@WFCommandTEMP						nvarchar(512)
	
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseFullBackupStartTime', @dbsDatabaseFullBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupStartTime', @dbsDatabaseLogBackupStartTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupIntervalMinute', @dbsDatabaseLogBackupIntervalMinute OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseLogBackupEndTime', @dbsDatabaseLogBackupEndTime OUTPUT
EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseDBCCStartTime', @dbsDatabaseDBCCStartTime OUTPUT
IF @RC <> 0
	GOTO END_IT

EXEC @RC = [DBServices].[dbo].[usp_GetdbsInstanceConfig] 'dbsDatabaseIDXReorgStartTime', @dbsDatabaseIDXReorgStartTime OUTPUT
IF @RC <> 0
	GOTO END_IT

SET @WFJobFreq = LOWER(LTRIM(RTRIM(@WFJobFreq)))

--------------------------------------------------
-- Set information for the schedule

SET @RC = 0
IF @WFJobFreq = 'bufull'  
BEGIN
	SET @dbsDatabaseFullBackupStartTime = LEFT(@dbsDatabaseFullBackupStartTime,5)

	SET @WFJobStartTime = SUBSTRING( @dbsDatabaseFullBackupStartTime, 1, 2)
			+ SUBSTRING( @dbsDatabaseFullBackupStartTime, 4, 2) + '00'

	SELECT	
		@WorkFlowFrequencyType		= 4
		,@WFfreq_interval			= 1
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 0
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= @WFJobStartTime
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959

	UPDATE DBServices.dbo.WorkFlowJob 
	SET WFJobStartTime = @dbsDatabaseFullBackupStartTime + ':00'
	WHERE WFJobName = @WFJobName

END -------------------
ELSE
IF @WFJobFreq = 'bulog'
BEGIN
	SET @dbsDatabaseLogBackupStartTime = LEFT(@dbsDatabaseLogBackupStartTime,5)
	SET @dbsDatabaseLogBackupEndTime = LEFT(@dbsDatabaseLogBackupEndTime,5)

	SET @WFJobStartTime = SUBSTRING( @dbsDatabaseLogBackupStartTime, 1, 2) + SUBSTRING( @dbsDatabaseLogBackupStartTime, 4, 2) + '00'
	SET @WFactive_end_time = SUBSTRING( @dbsDatabaseLogBackupEndTime, 1, 2) + SUBSTRING( @dbsDatabaseLogBackupEndTime, 4, 2) + '00'

	SELECT
		 @WorkFlowFrequencyType		= 4 
		,@WFfreq_interval			= 1
		,@WFfreq_subday_type		= 4
		,@WFfreq_subday_interval	= @dbsDatabaseLogBackupIntervalMinute
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 0 
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= @WFJobStartTime
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= @WFactive_end_time

	UPDATE DBServices.dbo.WorkFlowJob 
	SET WFJobStartTime = @dbsDatabaseLogBackupStartTime + ':00'
	WHERE WFJobName = @WFJobName
END -------------------
ELSE
IF @WFJobFreq = 'daily'  
BEGIN
   SELECT
		@WorkFlowFrequencyType = 4
		,@WFfreq_interval			= 1
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'weekly'
BEGIN
	SELECT
		 @WorkFlowFrequencyType = 8
		,@WorkFlowStartdate = DATEPART(yy, getdate())*10000 
			+ DATEPART(mm, getdate())*100 
			+ DATEPART(dd, getdate())
		,@WorkFlowStartTime = DATEPART(hh, @WFJobStartTime)*10000 
			+ DATEPART(mi, @WFJobStartTime)*100 
			+ DATEPART(ss, @WFJobStartTime)
		,@WFfreq_interval			= 1
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'monthly'
BEGIN
	SELECT
		@WorkFlowFrequencyType = 16
		,@WorkFlowStartdate = DATEPART(yy, getdate())*10000 
			+ DATEPART(mm, getdate())*100 
			+ DATEPART(dd, getdate())
		,@WorkFlowStartTime = DATEPART(hh, @WFJobStartTime)*10000 
			+ DATEPART(mi, @WFJobStartTime)*100 
			+ DATEPART(ss, @WFJobStartTime)
		,@WFfreq_interval			= 1
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'sunday'
BEGIN
   SELECT
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 1
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'monday'
BEGIN
   SELECT
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 2
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'tuesday'
BEGIN
   SELECT
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 4
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'wednesday'
BEGIN
	SELECT
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 8
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'thursday'
BEGIN
	SELECT 
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 16
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = 'friday'
BEGIN
   SELECT
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 32
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END  -------------------
ELSE
IF @WFJobFreq = 'saturday'
BEGIN
   SELECT
		@WorkFlowFrequencyType		= 8
		,@WFfreq_interval			= 64
		,@WFfreq_subday_type		= 1
		,@WFfreq_subday_interval	= 0
		,@WFfreq_relative_interval	= 0
		,@WFfreq_recurrence_factor	= 1
		,@WorkFlowStartdate			= DATEPART(yy, getdate())*10000 
									+ DATEPART(mm, getdate())*100 
									+ DATEPART(dd, getdate())
		,@WorkFlowStartTime			= DATEPART(hh, @WFJobStartTime)*10000 
									+ DATEPART(mi, @WFJobStartTime)*100 
									+ DATEPART(ss, @WFJobStartTime)
		,@WFactive_end_date			= 99991231
		,@WFactive_end_time			= 235959
END -------------------
ELSE
IF @WFJobFreq = N'manual'
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: Manual has been chosen, no schedule will be applied.'
END -------------------
ELSE
IF @WFJobFreq = N'netbackup'
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: Netbackup has been chosen, no schedule will be applied.'
END -------------------
ELSE
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: Invalid @WFJobFreq parameter setting passed:' + @WFJobFreq
	RETURN -1
END -------------------

SELECT @WFJobFreq

--BEGIN --TRANSACTION      

-- Create UBSMWE_WF_Job Category if does not exist
IF NOT EXISTS (SELECT * FROM msdb.dbo.syscategories WHERE [name] = N'UBSMWE_WF_Job') 
	EXEC msdb.dbo.sp_add_category @name = N'UBSMWE_WF_Job'

-- Remove any existing job of the same name  
IF EXISTS(SELECT 1 FROM msdb.dbo.sysjobs WHERE ([name] = @WFJobName))    
BEGIN  
	-- Check if this is a multi server job
	IF EXISTS ( SELECT 1 
				FROM msdb.dbo.sysjobservers 
				INNER JOIN msdb.dbo.sysjobs
					ON msdb.dbo.sysjobservers.job_id = msdb.dbo.sysjobs.job_id 
				WHERE msdb.dbo.sysjobs.[name] =  @WFJobName
					AND msdb.dbo.sysjobservers.server_id <> 0) 
	BEGIN 
		SET @ErrorMsg = 'UBSMWE: usp_WorkFlowAddJobs: Unable to delete job ' + @WFJobDescription
			+ ' since there is a multi-server job with this name.'

		EXEC [DBServices].[dbo].[usp_LogEvent] @ErrorMsg, 1
		GOTO END_IT  
	END ----------------------
	ELSE 
	BEGIN
		IF @WFJobName LIKE 'UBSMWE%' -- ensure only UBSMWE jobs are deleted
			EXEC msdb.dbo.sp_delete_job @job_name = @WFJobName -- Delete the [local] job 
		ELSE	-- quit with success
			GOTO END_IT
	END 
END 


-- Add the job
EXEC @RC = msdb.dbo.sp_add_job
	@job_id					= @WorkFlowsysjobsID OUTPUT,
	@job_name              = @WFJobName, 
	@owner_login_name      = N'sa', 
	@description           = @WFJobDescription, 
	@category_name         = N'UBSMWE_WF_Job', 
	@enabled               = @WFJobStatus, 
	@notify_level_email    = 0, 
	@notify_level_page     = 0, 
	@notify_level_netsend  = 0, 
	@notify_level_eventlog = 2, 
	@delete_level          = 0
	
IF @RC <> 0 
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR adding job ' + @WFJobName
	GOTO END_IT 
END

-- Add the job steps  
SET @WFstep_id = 1
SET @WFFlags = 0

IF @WFRunWorkFlowFlag = 0 --Only need one job step for this since we only support one step for user defined job.
BEGIN
	-- Get log file name
	SET @WorkFlowLogFileInput = @WFJobName + '_Step_' + CAST(@WFstep_id as nvarchar(3))

	EXEC @RC = DBServices.dbo.usp_GetLogfilename @WorkFlowLogFileInput, @WorkFlowLogFile OUTPUT
	IF @RC <> 0 
	BEGIN 
		PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR getting output log file name for ' + @WFJobName
		RETURN (-1)
	END
	
	EXEC @RC = msdb.dbo.sp_add_jobstep
		@job_id					= @WorkFlowsysjobsID, 
		@step_id              = 1, 
		@step_name            = N'Step 1', 
		@command              = @WFCommand,
		@database_name        = @WFCommandDatabase, 
		@server               = N'', 
		@database_user_name   = N'', 
		@subsystem            = N'TSQL', 
		@cmdexec_success_code = 0,
		@flags                = @WFFlags, 
		@retry_attempts       = 0, 
		@retry_interval       = 1, 
		@output_file_name     = @WorkFlowLogFile,
		@on_success_step_id   = 0, 
		@on_success_action    = 1, 
		@on_fail_step_id      = 0,  -- Log error
		@on_fail_action       = 3   -- goto next step	
	  
	IF @RC <> 0 
	BEGIN
		PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR adding job step for ' + @WFJobName
		GOTO END_IT
	END
	ELSE
		SET @WFstep_id = @WFstep_id + 1
END ----------------------------
ELSE
BEGIN
	IF EXISTS ( SELECT 1
				FROM WorkFlowJob 
				INNER JOIN 	DBServices.dbo.WorkFlowJobManifest 
					ON WorkFlowJob.WFJobID = WorkFlowJobManifest.WFJobID 
				INNER JOIN DBServices.dbo.WorkFlow 
					ON WorkFlowJobManifest.WFID = WorkFlow.WFID
				WHERE (WorkFlowJob.WFJobID = @WFJobID) )
	BEGIN --We have WorkFlows to add to the job...

		DECLARE WorkFlowCursor CURSOR READ_ONLY FOR
		SELECT WorkFlow.WFName
		FROM WorkFlowJob 
		INNER JOIN DBServices.dbo.WorkFlowJobManifest 
			ON WorkFlowJob.WFJobID = WorkFlowJobManifest.WFJobID 
		INNER JOIN DBServices.dbo.WorkFlow 
			ON WorkFlowJobManifest.WFID = WorkFlow.WFID
		WHERE (WorkFlowJob.WFJobID = @WFJobID)
		ORDER BY WorkFlow.WFPriority
		OPEN WorkFlowCursor

		FETCH NEXT FROM WorkFlowCursor INTO @WFName
		WHILE (@@fetch_status <> -1)
		BEGIN 
			IF (@@fetch_status <> -2)
			BEGIN
				SET @WorkFlowLogFileInput = @WFJobName + '_Step_' + cast(@WFstep_id as nvarchar(3))

				EXEC @RC = DBServices.dbo.usp_GetLogfilename @WorkFlowLogFileInput, @WorkFlowLogFile OUTPUT

				SET @WFCommandTEMP = @WFCommand + ' ''' + @WFName + ''''

				EXEC @RC = msdb.dbo.sp_add_jobstep 
						@job_id				  = @WorkFlowsysjobsID, 
						@step_id              = @WFstep_id, 
						@step_name            = @WFName, 
						@command              = @WFCommandTEMP,
						@database_name        = @WFCommandDatabase, 
						@server               = N'', 
						@database_user_name   = N'', 
						@subsystem            = N'TSQL', 
						@cmdexec_success_code = 0,
						@flags                = @WFFlags, 
						@retry_attempts       = 0, 
						@retry_interval       = 1, 
						@output_file_name     = @WorkFlowLogFile,
						@on_success_step_id   = 0, 
						@on_success_action    = 3, 
						@on_fail_step_id      = 0,  -- Log error
						@on_fail_action       = 3   -- goto next step	
						  
				IF @RC <> 0 
				BEGIN
					PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR adding job step for WF ' + @WFName
					GOTO END_IT
				END
				ELSE
					SET @WFstep_id = @WFstep_id + 1
			END
			
			FETCH NEXT FROM WorkFlowCursor INTO @WFName
		END

		CLOSE WorkFlowCursor
		DEALLOCATE WorkFlowCursor
		
		--Ok, now that we have the last WorkFlow step, make sure that if it is success, it quits the job or we will always run the error step.
		SET @WFstep_id = @WFstep_id - 1

	    EXEC @RC = msdb.dbo.sp_update_jobstep
						@job_id				= @WorkFlowsysjobsID, 
						@step_id            = @WFstep_id, 
						@on_success_step_id = 0, 
						@on_success_action  = 1

		IF @RC <> 0 
		BEGIN
			PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR updating job step for WF ' + @WFName
			GOTO END_IT
		END
		ELSE
			SET @WFstep_id = @WFstep_id + 1
	END
END

SET @WorkFlowCommand = 'EXEC DBServices.dbo.usp_LogErrors @JobID= ' + QUOTENAME(CAST(@WorkFlowsysjobsID AS nvarchar(40)),'''')
		+ ', @error_id= 0'
		+ ', @command= ' + QUOTENAME(@WFCommand,'''') 
		+ ', @message= ' + QUOTENAME(N'SQL Job Execution Error','''')
		+ ', @LogEvent= 1'
		+ ', @NeedAlertGenerated= 0'
		+ ', @Level= 1'

SET @WorkFlowLogFileInput = @WFJobName + '_Step_' + cast(@WFstep_id as nvarchar(3))
EXEC @RC=DBServices.dbo.usp_GetLogfilename @WorkFlowLogFileInput, @WorkFlowLogFile OUTPUT
                                             
IF @WFJobFreq = N'netbackup'
BEGIN
	SET @WorkFlowCommand = 'EXEC DBServices.dbo.usp_LogErrors @JobID= ' + QUOTENAME(CAST(@WorkFlowsysjobsID AS nvarchar(40)),'''')
			+ ', @error_id= 0'
			+ ', @command= ' + QUOTENAME(@WFCommand,'''') 
			+ ', @message= ' + QUOTENAME(N'SQL Job Execution Error: Check current status: EXEC DBServices..usp_Help_FileBackup','''')
			+ ', @LogEvent= 1'
			+ ', @NeedAlertGenerated= 0'
			+ ', @Level= 2'
END

EXEC @RC = msdb.dbo.sp_add_jobstep
				@job_id = @WorkFlowsysjobsID, 
				@step_id = @WFstep_id,  
				@step_name = N'Log Error', 
				@command = @WorkFlowCommand, 
				@database_name = @WFCommandDatabase,  
				@server = N'', 
				@database_user_name = N'', 
				@subsystem = N'TSQL',  
				@cmdexec_success_code = 0,  
				@flags = @WFFlags, 
				@retry_attempts = 0, 
				@retry_interval = 1,  
				@output_file_name = @WorkFlowLogFile,  
				@on_success_step_id = 0, 
				@on_success_action = 2,  
				@on_fail_step_id = 0,  
				@on_fail_action = 2

IF @RC <> 0 
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR adding job step for ' + @WFCommandDatabase + ': ' + @WorkFlowCommand
	GOTO END_IT
END

EXEC @RC = msdb.dbo.sp_update_job
			@job_id = @WorkFlowsysjobsID
			, @start_step_id = 1 

IF @RC <> 0 
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR updating job step for ' + @WFCommandDatabase + ': ' + @WorkFlowCommand
	GOTO END_IT
END

-- Add the job schedules
IF @WFJobFreq NOT IN ('netbackup', 'manual')
BEGIN
	EXEC @RC = msdb.dbo.sp_add_jobschedule
					@job_id					= @WorkFlowsysjobsID, 
					@name                   = @WFJobName, 
					@enabled                = @WFJobStatus, 
					@freq_type              = @WorkFlowFrequencyType,
					@active_start_date      = @WorkFlowStartdate, 
					@active_start_time      = @WorkFlowStartTime, 
					@freq_interval          = @WFfreq_interval,
					@freq_subday_type       = @WFfreq_subday_type, 
					@freq_subday_interval   = @WFfreq_subday_interval, 
					@freq_relative_interval = @WFfreq_relative_interval,
					@freq_recurrence_factor = @WFfreq_recurrence_factor, 
					@active_end_date        = @WFactive_end_date, 
					@active_end_time        = @WFactive_end_time
	                                             
	IF @RC <> 0 
	BEGIN
		PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR adding job schedule for ' + @WFJobName 
		GOTO END_IT
	END
END

-- Add the Target Servers
EXEC @RC = msdb.dbo.sp_add_jobserver
			@job_id = @WorkFlowsysjobsID
			,@server_name = N'(local)' 
                                               
IF @RC <> 0 
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: ERROR setting job target server for ' + @WFJobName 
	GOTO END_IT
END

UPDATE DBServices.dbo.WorkFlowJob 
SET WFsysjobsJobID = @WorkFlowsysjobsID, WFJobNeedsUpdate = 0
WHERE WFJobName = @WFJobName
   
SET @RC = @@ERROR

IF @RC <> 0
BEGIN
	PRINT 'UBSMWE: usp_WorkFlowAddJobs: tbl WorkFlowJob update ERROR'
	GOTO END_IT
END
ELSE 
	RETURN (0)  -- success      
 
-----------------------------------------------------
END_IT:

RETURN (-1) -- Failure    

END -- main

GO
/****** Object:  StoredProcedure [dbo].[usp_WorkFlowTasks_validate]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[usp_WorkFlowTasks_validate] 			

AS
SET DATEFORMAT ymd
/************************************************************************************************
Name: 		usp_WorkFlowTasks_validate.SQL
Purpose:	Validates  WorkFlow tasks, Jobs & report of any orphan entries in housekkeping tables.
              
Modification History:
Version  Name                Date        Notes
//	1.0      Rakesh Bist   	    13/02/2006   Original version
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 16/06/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0

************************************************************************************************/
SET NOCOUNT ON
DECLARE @retcode        INT,
		@source		varchar(128),
		@command	varchar(128),
		@cmd		varchar(128),
		@message	varchar(512),
		@i			int,
		@JobID 		uniqueidentifier 

DECLARE @WFJobs table 
	( 	JobVal	int	identity,
		JobID	uniqueidentifier)

SET @retcode= 0

-- Check any task without sql jobs	
IF (SELECT COUNT(*) FROM DBServices.dbo.dbsWorkFlowTasks T
		WHERE NOT EXISTS (SELECT * FROM DBServices.dbo.dbsWorkFlowJobs J
					WHERE T.WFTaskID = J.WFTaskID)) > 0
BEGIN
	SELECT T.WFTaskID AS [Task ID]
		, 'No Job defined' AS [Job ID]
		, T.WFTaskName AS [Job Name]
		, T.WFTaskDesc AS [Job Description]
		, T.WFProcName AS [Procedure Name]
		, T.WFProcLoc AS [Procedure DB]
		, T.WFDBName AS [Database]
		, T.WFTaskStatus AS [Task Status]
		, T.WFTaskAddDate AS [Task Created]
		, T.WFStartTime AS [Scheduled Time]
		, T.WFTaskFreq AS [Execution Frequency] 
	FROM DBServices.dbo.dbsWorkFlowTasks T
	WHERE NOT EXISTS (SELECT * FROM DBServices.dbo.dbsWorkFlowJobs J WHERE T.WFTaskID = J.WFTaskID)

	--  PRINT 'WorkFlow task exists without a SQL Scheduler job ' 
	RAISERROR ('WorkFlow task exists without a SQL Scheduler job', 17, 1) WITH LOG

	INSERT INTO @WFJobs (JobID)
	SELECT T.WFTaskID FROM DBServices.dbo.dbsWorkFlowTasks T 
	WHERE NOT EXISTS (SELECT * FROM DBServices.dbo.dbsWorkFlowJobs J WHERE T.WFTaskID = J.WFTaskID)
	
	SET @i = 1 
	WHILE (@i <= (SELECT MAX(JobVal) FROM @WFJobs)) 
   	BEGIN
		SELECT @JobID = JobID FROM @WFJobs WHERE JobVal = @i 				
		
		-- log error
		SET @command = 'WorkFlow Tasks Validation'
		SET @message = 'WorkFlow task exists without a SQL Scheduler job, TaskID:  ' + CAST(@JobID AS VARCHAR(36))  
		SET @source = 'usp_WorkFlowTasks_validate'	
		EXEC @retcode=DBServices.dbo.usp_LogErrors NULL,0,@source,@command,@message    				

		IF @@ERROR <> 0
    		RETURN (1)
							
	    SET @i = @i + 1 
    END 
END	
		
-- Check any Job without WorkFlow task	
IF (SELECT COUNT(*)  FROM DBServices.dbo.dbsWorkFlowJobs J
	WHERE NOT EXISTS (SELECT * FROM DBServices.dbo.dbsWorkFlowTasks T WHERE T.WFTaskID = J.WFTaskID))> 0
BEGIN

	SELECT WFJobID, 'No Task exists' AS [Task ID]  FROM DBServices.dbo.dbsWorkFlowJobs J
		WHERE NOT EXISTS (SELECT * FROM DBServices.dbo.dbsWorkFlowTasks T WHERE T.WFTaskID = J.WFTaskID)

	RAISERROR ('A job exists without a WorkFlow task', 17, 1) WITH LOG
	INSERT INTO @WFJobs (JobID)
		SELECT WFJobID FROM DBServices.dbo.dbsWorkFlowJobs J
		WHERE NOT EXISTS (SELECT * FROM DBServices.dbo.dbsWorkFlowTasks T WHERE T.WFTaskID = J.WFTaskID)
	SET @i = 1 
	WHILE (@i <= (SELECT MAX(JobVal) FROM @WFJobs)) 

    	BEGIN 
		IF (SELECT COUNT(*) FROM msdb..sysjobs where job_id=@JobID) > 0
		BEGIN
			PRINT 'Orphan Job exists in SQL Scheduler without WorkFlow task ' 
			RAISERROR ('A SQL Scheduler job exists without a WorkFlow task', 17, 1) WITH LOG   		
			
			-- log error
			SET @command = 'WorkFlow Tasks Validation'
			SET @message = 'Orphan Job exists in SQL Scheduler without task, JobID:  ' + CAST(@JobID AS VARCHAR(36))  
			SET @source = 'usp_WorkFlowTasks_validate'	
			EXEC @retcode=DBServices.dbo.usp_LogErrors NULL,0,@source,@command,@message    				
			IF @@ERROR <> 0
				RETURN (1)		
   		END	
	SET @i = @i + 1 
   	END 
END
-- Check any task have status (0-disable, 1-enable) which is not in sync with job in sysjobs table
-- for example, job enable or disabled.

IF (SELECT COUNT(*) FROM DBServices.dbo.dbsWorkFlowJobs J
			JOIN msdb..sysjobs S
			ON J.WFJobID = S.job_id
			JOIN DBServices.dbo.dbsWorkFlowTasks T 
			ON T.WFTaskID = J.WFTaskID
			WHERE T.WFTaskStatus <> S.enabled) > 0
BEGIN
	PRINT 'Scheduled Job status in SQL Scheduler does not matches with  WorkFlow task Status' 
	RAISERROR ('Scheduled Job status in SQL Scheduler does not matches with  WorkFlow task Status', 17, 1) WITH LOG   		
	-- log error
	SET @command = 'WorkFlow Tasks Validation'
	SET @message = 'Scheduled Job status in SQL Scheduler does not matches with  WorkFlow task Status  ' 					  
	SET @source = 'usp_WorkFlowTasks_validate'	
	EXEC @retcode=DBServices.dbo.usp_LogErrors NULL,0,@source,@command,@message    				
	IF @@ERROR <> 0
		RETURN (1)				
END	

-- Any job in SQL Scheduler for WorkFlow without any taskid & Jobid in houskeeping tables.
IF (SELECT  COUNT(*) FROM 
		(SELECT S.job_id
		FROM msdb..sysjobs S
		JOIN  msdb..syscategories  C
			ON C.category_id = S.category_id 
		WHERE S.name  like 'DBS' + '[_]'+'%' AND C.name='DBS_Maintenance') AS T
	WHERE T.job_id NOT IN (SELECT WFJobID FROM DBServices.dbo.dbsWorkFlowJobs)) > 0

BEGIN

	RAISERROR ('Scheduled Job  in SQL Scheduler does not exists in the WorkFlow tables', 17, 1) WITH LOG 
	INSERT INTO @WFJobs (JobID)
	SELECT  * FROM (SELECT S.job_id  FROM msdb..sysjobs S
	JOIN  msdb..syscategories  C
	ON C.category_id = S.category_id 
	WHERE S.name  like 'DBS' + '[_]'+'%' AND C.name='DBS_Maintenance') AS T
	WHERE T.job_id NOT IN (SELECT WFJobID FROM DBServices.dbo.dbsWorkFlowJobs)

	SET @i = 1 
	WHILE (@i <= (SELECT MAX(JobVal) FROM @WFJobs)) 
	BEGIN 
	
		SELECT @JobID = JobID FROM @WFJobs WHERE JobVal = @i 		
	
		PRINT 'Scheduled Job  in SQL Scheduler does not exists in the WorkFlow tables  ' + CAST(@JobID AS VARCHAR(36))
		 		
		-- log error
		SET @command = 'WorkFlow Tasks Validation'
		SET @message = 'Scheduled Job  in SQL Scheduler does not exists in the WorkFlow tables, JobID:  ' 
				+ CAST(@JobID AS VARCHAR(36))  
		
		SET @source = 'usp_WorkFlowTasks_validate'	
		EXEC @retcode=DBServices.dbo.usp_LogErrors NULL,0,@source,@command,@message    				
		IF @@ERROR <> 0
			RETURN (1)
		
		SET @i = @i + 1 
	END 
END	


RETURN(@retcode)

GO
/****** Object:  StoredProcedure [dbo].[usp_WriteLineToFile]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[usp_WriteLineToFile](@FileName varchar(255), @Line nvarchar(2000)) 
AS

/****************************************************************************************
// @File: usp_WriteToFile.SQL
// 
// Purpose:
//   Write lines to specified text file, for now, only used in Netbackup procedures.
//
// Notes: This stored procedure is called from the Netbackup procedures. 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 22/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//   @Date: 29/09/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.4.1 @Action: Updated @Line param to 2000 per issue #54 
//   @Date: 03/12/2014 @Author: Chris Basson @Version: UBSMWE 6.0.0.14 @Action: TRRv3 
//
//
****************************************************************************************/

BEGIN
SET DATEFORMAT ymd
SET NOCOUNT ON

DECLARE @fso int
	,@RC int
	,@fileObject int

SET @RC = 1

--------------------------------------------------------------
-- Checks

IF ISNULL(@FileName,'') = '' 
	GOTO END_IT

IF ISNULL(@Line,'') = '' 
	RETURN 0	-- nothing to do - quit with success

--------------------------------------------------------------
--Create a handle to the File System Object

EXEC @RC = sp_OACreate 'Scripting.FileSystemObject', @fso OUT
IF @RC <> 0 
	GOTO END_IT

--Create a handle to the File Object
EXEC @RC = sp_OAMethod @fso, 'OpenTextFile', @fileObject OUT, @FileName, 8, 1
IF @RC <> 0 
	GOTO END_IT

--Actually write the information to the text file object
EXEC @RC = sp_OAMethod @fileObject, 'WriteLine', Null, @Line 
IF @RC <> 0 
	GOTO END_IT

--Tidyup	
WAITFOR DELAY '00:00:00.20' -- attempt to ensure buffers flush before closing

EXEC @RC = sp_OADestroy @fileObject
IF @RC <> 0 
	GOTO END_IT

EXEC @RC = sp_OADestroy @fso
IF @RC <> 0 
	GOTO END_IT
	
--------------------------------------------------------------
END_IT:

IF @RC <> 0 
	PRINT 'UBSMWE: usp_WriteLineToFile: write error to ' + @FileName

RETURN @RC

END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[fn_ConvertToExtents]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[fn_ConvertToExtents] (
   @extents VARCHAR (100))
RETURNS INTEGER
AS
BEGIN
   DECLARE @extentTotal   INT;
   DECLARE @colon         INT;
   DECLARE @firstExtent   INT;
   DECLARE @secondExtent  INT;

   SET @extentTotal = 0;
   SET @colon = CHARINDEX (':', @extents);

   IF (CHARINDEX (':', @extents, @colon + 1) = 0)
      SET @extentTotal = 1
   ELSE
      BEGIN
      SET @firstExtent = CONVERT (INT,
         SUBSTRING (@extents, @colon + 1, CHARINDEX (')', @extents, @colon) - @colon - 1));
      SET @colon = CHARINDEX (':', @extents, @colon + 1);
      SET @secondExtent = CONVERT (INT,
         SUBSTRING (@extents, @colon + 1, CHARINDEX (')', @extents, @colon) - @colon - 1));
      SET @extentTotal = (@secondExtent - @firstExtent) / 8 + 1;
   END

   RETURN @extentTotal
END

GO
/****** Object:  UserDefinedFunction [dbo].[fn_Split]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[fn_Split] (
	@Delimiter nchar(1),
	@List nvarchar(4000)
	)
   RETURNS @TableOfValues TABLE (
		[RowID] smallint IDENTITY(1,1), 
        [Value] nvarchar(4000)
		)
AS 
/****************************************************************************************
// @File: fn_Split.SQL
// @Version 6.0.0.29
// Purpose:
//   Returns a table variable containing split rows based on a specified delimiter
//
// Notes: 
//
// History: Date Format dd/mm/yyyy
//
//			@dbsDBHFileName ,@dbsDatabaseUID ,@dbsDBHEndDate
//
//   @Date: 03/23/2013 @Author: Steve Trogub @Version: 5.0.3 HF1 @Action: Created
//   @Date: 09/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: rewrite for BRAT support for non-alpha numerics in DB names
//
****************************************************************************************/

BEGIN -- main

DECLARE @LenList smallint
		,@s smallint
		,@e smallint

SET @LenList = (LEN(@List + N'*') - 1)  -- cater for trailing spaces

SELECT @s = 1, @e = 1

WHILE @e < @LenList  
BEGIN 

	SET @e = CHARINDEX(@Delimiter, @List, @s)

	IF ISNULL(@e, 0) = 0
		SET @e = @LenList + 1
                      
	INSERT INTO @TableOfValues 
	SELECT SUBSTRING(@List, @s, @e - @s)

	SET @s = @e + 1
END

RETURN
     
END  -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ParseFileName]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE FUNCTION [dbo].[ParseFileName]  (@Path varchar(8000))
RETURNS NVARCHAR(255)
AS

/****************************************************************************************
// @File: ParseFileName.SQL
// 
// Purpose:
//   Return just the file name from a long path
//
// Notes: This Function is used in the Netbackup stuff and will be used through the whole UBSMWE at some time. 
//
// History: Date Format dd/mm/yyyy
//
//   @Date: 20/11/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/



    BEGIN 
    	DECLARE @Index1 INT
		,@Index2 INT
		,@FileName nvarchar(255)
		,@WorkChar nchar(1)
    	
    	SET @Index1 = Len(@Path)
    	SET @Index2 = 1
    	SET @FileName = ''
    	WHILE @Index2 <= @Index1
    		BEGIN
			SELECT @WorkChar = SUBSTRING(@Path, @Index2, 1) 
    			IF  @WorkChar <> '\' 
				BEGIN
					SET @FileName = @FileName + @WorkChar
				END
			ELSE
				BEGIN
					SET @FileName = ''
				END

    			SET @Index2 = @Index2 + 1
    		END
    	RETURN(@FileName)
     
    END

GO
/****** Object:  UserDefinedFunction [dbo].[ParseStringWithDelim]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO

CREATE FUNCTION [dbo].[ParseStringWithDelim]  (@Text1 varchar(8000), @Delimiter nvarchar(255))
RETURNS NVARCHAR(255)
AS

/****************************************************************************************
// @File: ParseStringWithDelim.SQL
// 
// Purpose:
//   Return just the file name from a long path
//
// Notes: This Function is used in the Netbackup stuff and will be used through the whole UBSMWE at some time. 
//	Need to eventually expand the capability of this function to include stopping after a specified number of delims passed.
// History: Date Format dd/mm/yyyy
//
//   @Date: 02/12/2004 @Author: Kevin Wagner @Version: 1.5.2 HF1 @Action: Created
//   @Date: 21/03/2007 @Author: Kevin Wagner @Version: UBSMWE 2.5.2 @Action: Final release to production
//   @Date: 20/03/2008 @Author: Kevin Wagner @Version: UBSMWE 2.5.3 @Action: Final release to production
//
****************************************************************************************/



    BEGIN 
    	DECLARE @Index1 INT
		,@Index2 INT
		,@DelimiterLength INT
		,@Text2 nvarchar(255)
		,@WorkChar nchar(1)
    	
    	SET @Index1 = Len(@Text1)
	SET @DelimiterLength = LEN(@Delimiter)
    	SET @Index2 = 1
    	SET @Text2 = ''
    	WHILE @Index2 <= @Index1
    		BEGIN
			SELECT @WorkChar = SUBSTRING(@Text1, @Index2, @DelimiterLength) 
    			IF  @WorkChar <> @Delimiter --':' 
				BEGIN
					SET @Text2 = @Text2 + @WorkChar
				END
			ELSE
				BEGIN
					SET @Text2 = ''
				END

    			SET @Index2 = @Index2 + @DelimiterLength
    		END
    	RETURN(@Text2)
     
    END

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_BRATTime]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_BRATTime] (@DT as datetime)
RETURNS char(19)
AS

/****************************************************************************************
// @File: ufn_BRATTime.sql
//
// @Version 6.0.0.19
//
// Purpose: Returns a given DT in a required format for BRAT 
//
// Notes:
//
// History: Date Format dd/mm/yyyy
//
//	@Date: 18/12/2014 @Author: Chris Basson @Version 6.0.0.19 @Action: TRRv3 
****************************************************************************************/
BEGIN -- main

DECLARE @tmpDT char(19)

SET @tmpDT = REPLACE(CONVERT(char(19), @DT, 120), '-', '/')

IF ISDATE(@tmpDT) = 0
	SET @tmpDT = 'DTError'

RETURN ISNULL(@tmpDT, 'DTError')

END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_CmpVerNum]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_CmpVerNum] (
						@Source nvarchar(9),
						@Target nvarchar(9),
						@Parts tinyint = 4 )
RETURNS tinyint
AS

/****************************************************************************************
// @File: ufn_CmpVerNum.SQL
//
// @Version 6.0.0.2
//
// Purpose: Compares two version numbers; returns:
// 0 = same
// 1 = source has higher version number (later version)
// 2 = target has higher version number (later version)
//
// Notes: 
//
// History: Date Format dd/mm/yyyy
//
//	@Date: 12/08/2014 @Author: Chris Basson @Version 6.0.0.1 @Action: TRRv3 Beta Created
****************************************************************************************/

BEGIN -- main

DECLARE @ReturnValue as tinyint 
	, @PartIndex as tinyint
    , @SourcePartValue as tinyint
	, @TargetPartValue as tinyint

SELECT @ReturnValue = 0
	, @PartIndex = 1
    , @SourcePartValue = 0
	, @TargetPartValue = 0

WHILE (@PartIndex <= @Parts AND @ReturnValue = 0)
BEGIN
    SET @SourcePartValue = [dbo].[ufn_VerNthPart](@Source, @PartIndex)
    SET @TargetPartValue = [dbo].[ufn_VerNthPart](@Target, @PartIndex)

    IF @SourcePartValue > @TargetPartValue
        SET @ReturnValue = 1
    ELSE
	IF @SourcePartValue < @TargetPartValue
        SET @ReturnValue = 2

    SET @PartIndex = @PartIndex + 1;
END
RETURN @ReturnValue

END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_CV_SubclientforDB]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_CV_SubclientforDB] (@databasename nvarchar(128))
RETURNS nvarchar(255)
AS
/****************************************************************************************
// @File: ufn_CV_SubclientforDB.SQL
//
// @Version 6.0.0.0
//
// Purpose: Returns the Subclient for a given DB from dbsCVSubclients
//
// Notes: 
//
// History: Date Format dd/mm/yyyy
//
//	@Date: 08/07/2014 @Author: Chris Basson @Version 6.0.0.0 @Action: TRRv3 Beta Created
****************************************************************************************/
BEGIN -- main

DECLARE @RTNSubclient nvarchar(255)

SELECT TOP 1 @RTNSubclient = sc.dbsSubclientName
FROM DBServices.dbo.dbsDatabase db
INNER JOIN DBServices.dbo.dbsCVSubclients sc 
	ON db.dbsDatabaseUID = sc.dbsDatabaseUID
WHERE db.dbsDatabaseName = @databasename
	AND db.dbsDatabaseIsActive = 1
ORDER BY dbsSubclientUpdateDate DESC

RETURN ISNULL(@RTNSubclient,'Subclient_not_found')

END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_InstanceMajorVersion]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE FUNCTION [dbo].[ufn_InstanceMajorVersion] ()
RETURNS tinyint
AS
BEGIN
	-- Returns the base MSSQL product version as a tinyint:
	-- 8 - SQL 2000
	-- 9 - SQL 2005
	-- 10 - SQL 2008 

	RETURN(CAST(CAST(SERVERPROPERTY('ProductVersion')as nvarchar(2))as DEC(2)))
END

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_ParseMWETime]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_ParseMWETime](@MWETime nvarchar(5))
RETURNS datetime
AS
BEGIN -- main

/****************************************************************************************
// @File: ufn_ParseMWETime.SQL
//
// @Version 6.0.0.0
//
// Purpose: Parses a 5 char time to a current valid datetime 
//
// Notes: Called from usp_UpdatedbsDatabaseBackup_Schedule
//
// History: Date Format dd/mm/yyyy
//
//	@Date: 08/07/2014 @Author: Chris Basson @Version 6.0.0.0 @Action: TRRv3 Beta Created
****************************************************************************************/


	RETURN CONVERT(datetime, (
							CONVERT (varchar(4),DATEPART(year, getdate()))
							+ '-' + CONVERT(varchar(4),DATEPART(month, getdate()))
							+ '-' + CONVERT(varchar(4),DATEPART(day, getdate()))
							+ ' ' + @MWETime
						) )
END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_SafeFileName]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_SafeFileName](@filename nvarchar(255))
RETURNS nvarchar(255)
AS

/****************************************************************************************
// @File: ufn_SafeFileName.sql
// 
// Purpose: Returns a safe filename for a given string, replacing invalid chars with #
//			Permitted chars: A-Za-z0-9()''*\-._!~
// History: Dates are in DD/MM/YYYY format
//
//   @Date: 18/03/2015 @Author: Chris Basson @Version: 6.0.0.29 @Action: Support for non-alpha numerics in DB names
****************************************************************************************/

BEGIN --main

DECLARE @astr nvarchar(255)
		,@apath nvarchar(255)
		,@astr_cnt smallint
		,@currchar nchar(1)
		,@i smallint
		,@astr_out nvarchar(255)

---------------------------------------------

SET @astr = REVERSE(@filename)
SET @i = CHARINDEX('\', @astr)

IF @i > 0
BEGIN
	SET @astr = REVERSE(LEFT(@astr, @i - 1))
	SET @apath = REPLACE(@filename, @astr, '')
END ---------------
ELSE
BEGIN
	SET @apath = ''
	SET @astr = @filename
END

---------------------------------------------

SET @astr_cnt = LEN(@astr + '*') - 1
SET @i = 1
SET @astr_out = ''

---------------------------------------------

WHILE (@i <= @astr_cnt)
BEGIN
    SET @currchar = SUBSTRING(@astr, @i, 1)

	IF @currchar IN ('<','>',':','"','/','|','?','*') 
		SET @currchar = '#'
	ELSE 
	IF @currchar = CHAR(32) -- space
		SET @currchar = '_'

	SET @astr_out = @astr_out + @currchar

	SET @i = @i + 1
END

SET @astr_out = @apath + @astr_out

RETURN @astr_out

END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_timezone]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_timezone]()
RETURNS nvarchar(128)
AS

/****************************************************************************************
// @File: ufn_timezone.SQL
//
// @Version 6.0.0.2
//
// Purpose: Returns the timezone for the given host
//
// Notes: 
//
// History: Date Format dd/mm/yyyy
//
//	@Date: 13/08/2014 @Author: Chris Basson @Version 6.0.0.2 @Action: TRRv3 Beta Created
****************************************************************************************/

BEGIN -- main

DECLARE @timezoneoffset int
	,@timezone nvarchar(128)

--timezone calculation
SET @timezoneoffset =  DATEDIFF(MINUTE,GetDate(),GetUTCDate())

SET  @timezone = CASE 
						WHEN @timezoneoffset = 300  THEN '(UTC-05:00) Eastern Time (US & Canada)'
						WHEN @timezoneoffset = 360  THEN '(UTC-06:00) Central Time (US & Canada)'
						WHEN @timezoneoffset = 420  THEN '(UTC-07:00) Mountain Time (US & Canada)'
						WHEN @timezoneoffset = 480  THEN '(UTC-08:00) Pacific Time (US & Canada)'
						WHEN @timezoneoffset = 0    THEN '(UTC) Dublin, Edinburgh, Lisbon, London'
						WHEN @timezoneoffset = -60  THEN '(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna'
						WHEN @timezoneoffset = -120 THEN '(UTC+02:00) Jerusalem'
						WHEN @timezoneoffset = -180 THEN '(UTC+03:00) Kuwait, Riyadh'
						WHEN @timezoneoffset = -210 THEN '(UTC+03:30) Tehran'
						WHEN @timezoneoffset = -240 THEN '(UTC+04:00) Moscow, St. Petersburg, Volgograd'
						WHEN @timezoneoffset = -270 THEN '(UTC+04:30) Kabul'
						WHEN @timezoneoffset = -300 THEN '(UTC+05:00) Islamabad, Karachi'
						WHEN @timezoneoffset = -330 THEN '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi'
						WHEN @timezoneoffset = -345 THEN '(UTC+05:45) Kathmandu'
						WHEN @timezoneoffset = -360 THEN '(UTC+06:00) Astana'
						WHEN @timezoneoffset = -390 THEN '(UTC+06:30) Yangon (Rangoon)'
						WHEN @timezoneoffset = -420 THEN '(UTC+07:00) Bangkok, Hanoi, Jakarta'
						WHEN @timezoneoffset = -480 THEN '(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi'
						WHEN @timezoneoffset = -540 THEN '(UTC+09:00) Osaka, Sapporo, Tokyo'
						WHEN @timezoneoffset = -570 THEN '(UTC+09:30) Darwin'
						WHEN @timezoneoffset = -600 THEN '(UTC+10:00) Canberra, Melbourne, Sydney'
						WHEN @timezoneoffset = -660 THEN '(UTC+11:00) Vladivostok'
						WHEN @timezoneoffset = -720 THEN '(UTC+12:00) Magadan'
						WHEN @timezoneoffset = 60   THEN '(UTC-01:00) Cape Verde Is.'
						WHEN @timezoneoffset = 120  THEN '(UTC-02:00) Coordinated Universal Time-02'
						WHEN @timezoneoffset = 180  THEN '(UTC-03:00) Buenos Aires'
						WHEN @timezoneoffset = 240  THEN '(UTC-04:00) Georgetown, La Paz, Manaus, San Juan'
						WHEN @timezoneoffset = 270  THEN '(UTC-04:30) Caracas'
						WHEN @timezoneoffset = 540  THEN '(UTC-09:00) Alaska'
						WHEN @timezoneoffset = 600  THEN '(UTC-10:00) Hawaii'
						WHEN @timezoneoffset = 660  THEN '(UTC-11:00) Coordinated Universal Time-11'
						WHEN @timezoneoffset = 720  THEN '(UTC-12:00) International Date Line West'
						ELSE 'Unable to Calculate TimeZone Offset at this Location'
					END
RETURN @timezone

END -- main

GO
/****** Object:  UserDefinedFunction [dbo].[ufn_VerNthPart]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [dbo].[ufn_VerNthPart](@version as nvarchar(9), @part as tinyint) 
RETURNS tinyint 
AS

/****************************************************************************************
// @File: ufn_CmpVerNum.SQL
//
// @Version 6.0.0.2
//
// Purpose: Returns part of a given version num
//
// Notes: Called by ufn_CmpVerNum
//
// History: Date Format dd/mm/yyyy
//
//	@Date: 12/08/2014 @Author: Chris Basson @Version 6.0.0.1 @Action: TRRv3 Beta Created
****************************************************************************************/

BEGIN --main

DECLARE
    @ret as tinyint,
    @start as tinyint,
    @end as tinyint,
    @partsfound as tinyint,
    @terminate as tinyint

SELECT @ret = NULL
	, @start = 1
	, @end = 0
	, @partsfound = 0
	, @terminate = 0

IF @version IS NOT NULL
BEGIN
	SET @ret = 0
	WHILE @partsfound < @part
	BEGIN
		SET @end = CHARINDEX('.', @version, @start)
		IF @end = 0 -- did not find the dot. Either it was last part or the part was missing.
		BEGIN
			IF @part - @partsfound > 1 -- also this isn't the last part so it must bail early.
				SET @terminate = 1

			SET @partsfound = @part
			SET @end = LEN(@version) + 1; -- get the full length so that it can grab the whole of the final part.
		END
		ELSE
		SET @partsfound = @partsfound + 1

		IF @partsfound = @part AND @terminate = 0
			SET @ret = CONVERT(int, SUBSTRING(@version, @start, @end - @start))
		ELSE
			SET @start = @end + 1
	END
END

RETURN @ret

END --main

GO
/****** Object:  Table [dbo].[aacScrubberAccounts]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[aacScrubberAccounts](
	[Server] [nvarchar](128) NOT NULL,
	[Version] [int] NOT NULL,
	[Login] [nvarchar](128) NOT NULL,
	[LastAccessTime] [datetime] NOT NULL,
	[Application] [nvarchar](128) NOT NULL DEFAULT ('Unknown'),
	[ClientHostName] [nvarchar](128) NOT NULL DEFAULT ('Unknown'),
	[LastPasswordChange] [datetime] NOT NULL DEFAULT (getdate())
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsCVbackupStatus]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[dbsCVbackupStatus](
	[dbsCVbackupJobId] [nvarchar](20) NULL,
	[dbsCVBackupSetId] [nvarchar](20) NULL,
	[dbsCVbackupDatabase] [nvarchar](255) NULL,
	[dbsCVbackupType] [nvarchar](10) NULL,
	[dbsCVbackupTotalSize] [nvarchar](21) NULL,
	[dbsCVbackupStartTime] [nvarchar](12) NULL,
	[dbsCVbackupEndTime] [nvarchar](12) NULL,
	[BackupMethod] [nvarchar](5) NULL,
	[dbsCVbackupPolicy] [nvarchar](255) NULL,
	[dbsCVbackupStatus] [int] NULL,
	[dbsCVbackupUnixTimestamp]  AS (CONVERT([char](19),dateadd(hour,CONVERT([int],datediff(hour,getutcdate(),getdate())),dateadd(second,CONVERT([int],[dbsCVbackupStartTime]),'1970-01-01 00:00:00.000')),(126)))
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[dbsCVBRATlookup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [dbo].[dbsCVBRATlookup](
	[dbsDatabaseBackupProcessorID] [tinyint] NOT NULL,
	[minMWEver] [varchar](9) NOT NULL,
	[minBRATver] [varchar](9) NOT NULL
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[dbsCVSchedule]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsCVSchedule](
	[CVSubclient] [nvarchar](128) NOT NULL,
	[CVSchedulePolicy] [nvarchar](64) NOT NULL,
	[LastUpdate] [datetime] NOT NULL,
	[Enabled] [bit] NULL
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsCVSubclients]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsCVSubclients](
	[dbsDatabaseUID] [uniqueidentifier] ROWGUIDCOL  NOT NULL,
	[dbsDatabaseName] [nvarchar](128) NULL,
	[dbsDatabaseIsSystemObjectFlag] [bit] NOT NULL,
	[dbsSubclientUpdateDate] [datetime] NOT NULL,
	[dbsUserAdded] [nvarchar](128) NOT NULL,
	[dbsSubclientName] [nvarchar](255) NOT NULL,
	[dbsDatabaseIsOndemandFlag] [bit] NOT NULL,
 CONSTRAINT [PK_dbsCVSubclients] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsD_DBE]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsD_DBE](
	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
	[dbsDatabaseBackupExceptionID] [int] NOT NULL,
	[dbsD_DBEIsActiveFlag] [bit] NOT NULL,
	[dbsD_DBEStartDate] [datetime] NULL,
	[dbsD_DBEEndDate] [datetime] NULL,
 CONSTRAINT [PK_dbs_DBE] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseUID] ASC,
	[dbsDatabaseBackupExceptionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsDatabase]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsDatabase](
	[dbsDatabaseUID] [uniqueidentifier] ROWGUIDCOL  NOT NULL CONSTRAINT [DF_dbsDatabase_dbsDatabaseUID]  DEFAULT (newid()),
	[dbsDatabasedbid] [int] NOT NULL,
	[dbsDatabaseName] [nvarchar](128) NULL,
	[dbsDatabaseIsSystemObjectFlag] [bit] NOT NULL,
	[dbsDatabaseCreateDate] [datetime] NOT NULL,
	[dbsDatabaseEntryDate] [datetime] NOT NULL,
	[dbsDatabaseMSSQLCentralNeedsUpdateFlag] [bit] NOT NULL,
	[dbsDatabaseInfoLoadedToMSSQLCentralDate] [datetime] NULL,
	[dbsDatabaseIsActive] [bit] NOT NULL,
 CONSTRAINT [PK_dbsDatabase] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsDatabaseBackup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsDatabaseBackup](
	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
	[dbsDBBackupType] [nvarchar](128) NULL,
	[dbsDBExternalBackupFlag] [bit] NOT NULL,
	[dbsDBFileLocation] [nvarchar](512) NULL,
	[dbsDBMSSQLCentralNeedsUpdateFlag] [bit] NOT NULL,
	[dbsDBDoFullBackupNow] [bit] NULL,
	[dbsDBDoLogBackupNow] [bit] NULL,
	[dbsDBLastFullBackupRun] [datetime] NULL,
	[dbsDBLastLogBackupRun] [datetime] NULL,
	[dbsDBNextFullBackupRun] [datetime] NULL,
	[dbsDBNextLogBackupRun] [datetime] NULL,
	[dbsDBIsInRestoreProcess] [bit] NULL,
	[dbsDBIsInFullBackupProcess] [bit] NULL,
	[dbsDBIsInLogBackupProcess] [bit] NULL,
	[dbsDBCreateFullBackupJob] [bit] NULL,
	[dbsDBCreateLogBackupJob] [bit] NULL,
 CONSTRAINT [PK_dbsDatabaseBackupHeader] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsDatabaseBackupException]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsDatabaseBackupException](
	[dbsDatabaseBackupExceptionID] [int] NOT NULL,
	[dbsDatabaseBackupExceptionType] [nvarchar](255) NULL,
	[dbsDatabaseBackupExceptionSubType] [nvarchar](255) NULL,
 CONSTRAINT [PK_dbsDatabaseBackupException] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseBackupExceptionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsDatabaseBackupHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsDatabaseBackupHistory](
	[dbsDBHID] [bigint] IDENTITY(1,1) NOT FOR REPLICATION NOT NULL,
	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
	[dbsDBHIsLogFlag] [bit] NOT NULL,
	[dbsDBHStartDate] [datetime] NULL,
	[dbsDBHEndDate] [datetime] NULL,
	[dbsDBHFileName] [nvarchar](255) NULL,
	[dbsDBHIsOnDiskFlag] [bit] NOT NULL,
	[dbsDBackupProcessorID] [int] NULL,
	[dbsDBHParentID] [bigint] NULL,
	[dbsDBHActiveComputerName] [nvarchar](255) NULL,
	[dbsDBHSentToNBFlag] [bit] NULL,
 CONSTRAINT [PK_dbsDatabaseBackupHeaderDetail] PRIMARY KEY CLUSTERED 
(
	[dbsDBHID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsDatabaseBackupProcessor]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsDatabaseBackupProcessor](
	[dbsDatabaseBackupProcessorID] [int] NOT NULL,
	[dbsDatabaseBackupProcessorName] [nvarchar](255) NULL,
 CONSTRAINT [PK_dbsDatabaseBackupProcessor] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseBackupProcessorID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsDatabaseException]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsDatabaseException](
	[dbsDatabaseExceptionID] [int] NOT NULL,
	[dbsDatabaseExceptionType] [nvarchar](255) NULL,
	[dbsDatabaseExceptionSubType] [nvarchar](255) NULL,
	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
	[dbsDatabasename] [sysname] NOT NULL,
	[dbsExceptionDate] [datetime] NOT NULL,
	[dbsUserInitiated] [nvarchar](50) NOT NULL,
	[dbsExceptionActive] [bit] NOT NULL,
	[dbsAlign] [int] NOT NULL,
	[dbsRetain] [int] NOT NULL,
 CONSTRAINT [PK_dbsDatabaseException] PRIMARY KEY CLUSTERED 
(
	[dbsDatabaseExceptionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsIndexDFRG]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsIndexDFRG](
	[dbsDFGEntryTime] [datetime] NOT NULL DEFAULT (getdate()),
	[dbsDatabaseName] [nvarchar](128) NOT NULL,
	[ObjectName] [nchar](255) NULL,
	[ObjectId] [int] NULL,
	[IndexId] [int] NULL,
	[IndexType] [nvarchar](60) NULL,
	[IndexDepth] [tinyint] NULL,
	[Partition_number] [int] NULL,
	[avg_fragmentation_in_percent] [float] NULL,
	[avg_fragment_size_in_pages] [float] NULL,
	[fragment_count] [bigint] NULL,
	[CountPages] [bigint] NULL,
	[MinRecSize] [int] NULL,
	[MaxRecSize] [int] NULL,
	[AvgRecSize] [float] NULL,
	[RecCount] [bigint] NULL,
	[avg_page_space_used_in_percent] [float] NULL,
	[forwarded_record_count] [bigint] NULL,
	[ReIndexStatus] [nvarchar](100) NULL,
	[ReIndexTime] [datetime] NULL,
	[data_compression_desc] [nvarchar](60) NULL DEFAULT ('NONE')
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsInstanceConfig]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsInstanceConfig](
	[dbsInstanceConfigName] [nvarchar](255) NOT NULL,
	[dbsInstanceConfigValue] [nvarchar](255) NULL,
 CONSTRAINT [PK_dbsInstanceConfig] PRIMARY KEY NONCLUSTERED 
(
	[dbsInstanceConfigName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsMSSQLCentralCommandQueue]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsMSSQLCentralCommandQueue](
	[MSCCQID] [bigint] IDENTITY(1,1) NOT FOR REPLICATION NOT NULL,
	[MSCCQCommand] [nvarchar](4000) NOT NULL,
	[MSCCQEntryDate] [datetime] NOT NULL CONSTRAINT [DF_dbsMSSQLCentralCommandQueue_MCCQEntryDate]  DEFAULT (getdate()),
	[MSCCQIsProccessed] [bit] NOT NULL CONSTRAINT [DF_dbsMSSQLCentralCommandQueue_MCCQIsProccessed]  DEFAULT ((0)),
	[MSCCQResult] [nvarchar](255) NOT NULL CONSTRAINT [DF_dbsMSSQLCentralCommandQueue_MSCCQResult]  DEFAULT ('Not Executed'),
 CONSTRAINT [PK_dbsMSSQLCentralCommandQueue] PRIMARY KEY CLUSTERED 
(
	[MSCCQID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsMSSQLCentralCommandQueueExtendedError]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsMSSQLCentralCommandQueueExtendedError](
	[MSCCQID] [bigint] NOT NULL,
	[DateProcessed] [datetime] NOT NULL,
	[Result] [nvarchar](4000) NOT NULL,
 CONSTRAINT [PK_dbsMSSQLCentralCommandQueueExtendedError] PRIMARY KEY CLUSTERED 
(
	[MSCCQID] ASC,
	[DateProcessed] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsNetbackup]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsNetbackup](
	[dbsNetbackupID] [bigint] IDENTITY(1,1) NOT NULL,
	[dbsNetbackupRequestStartDate] [datetime] NOT NULL,
	[dbsNetbackupRequestEndDate] [datetime] NULL,
	[dbsNetbackupExitStatus] [nvarchar](255) NULL,
 CONSTRAINT [PK_dbsNetbackup] PRIMARY KEY CLUSTERED 
(
	[dbsNetbackupID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsNetbackupManifest]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsNetbackupManifest](
	[dbsNetbackupID] [bigint] NOT NULL,
	[dbsDBHID] [bigint] NOT NULL,
	[dbsNetbackupManifestLocation] [nvarchar](255) NULL,
	[IsSuccess] [bit] NULL,
	[IsSuccessRunNumber] [int] NULL,
 CONSTRAINT [PK_dbsNetbackupManifest] PRIMARY KEY CLUSTERED 
(
	[dbsNetbackupID] ASC,
	[dbsDBHID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsNetbackupStatus]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsNetbackupStatus](
	[dbsNetbackupRunNumber] [int] NOT NULL,
	[dbsNetbackupID] [bigint] NOT NULL,
	[dbsNetbackupStatusBackupstartedTime] [datetime] NULL,
	[dbsNetbackupStatusInitiatingbackupTime] [datetime] NULL,
	[dbsNetbackupStatusBACKUPSTARTTime] [datetime] NULL,
	[dbsNetbackupStatusBeginningbackupTime] [datetime] NULL,
	[dbsNetbackupTotalSize] [nvarchar](255) NULL,
	[dbsNetbackupEndTime] [datetime] NULL,
	[dbsNetbackupStatus] [nvarchar](255) NULL,
	[dbsNetbackupClass] [nvarchar](255) NULL,
	[dbsNetbackupFileListName] [nvarchar](255) NULL,
	[dbsNetbackupLogName] [nvarchar](255) NULL,
 CONSTRAINT [PK_dbsNetbackupStatus] PRIMARY KEY CLUSTERED 
(
	[dbsNetbackupRunNumber] ASC,
	[dbsNetbackupID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsPartialBackupHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsPartialBackupHistory](
	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
	[dbsDatabaseName] [sysname] NOT NULL,
	[dbsPartialBackupIsActiveFlag] [bit] NOT NULL,
	[dbsPartialBackupStartDate] [datetime] NULL,
	[dbsPartialBackupEndDate] [datetime] NULL,
	[dbsPartialBackupStatus] [int] NULL,
	[dbsPartialBackupExitStep] [int] NULL,
	[dbsDBHFileName] [nvarchar](255) NULL,
	[dbsDBHActiveComputerName] [nvarchar](255) NULL,
	[dbsFGList] [nvarchar](255) NULL
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[dbsUBSMWEHeartbeat]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[dbsUBSMWEHeartbeat](
	[dbsUBSMWEHeartbeatID] [int] IDENTITY(1,1) NOT FOR REPLICATION NOT NULL,
	[dbsUBSMWEHeartbeatDate] [datetime] NOT NULL,
	[dbsUBSMWEHeartbeatStage] [nvarchar](255) NULL,
 CONSTRAINT [PK_dbsUBSMWEHeartbeat] PRIMARY KEY CLUSTERED 
(
	[dbsUBSMWEHeartbeatID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[Index]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Index](
	[IndexName] [nvarchar](255) NOT NULL,
	[TableOwner] [nvarchar](128) NOT NULL,
	[TableName] [nvarchar](255) NOT NULL,
	[DisableRebuildFlag] [bit] NOT NULL,
 CONSTRAINT [PK_Index] PRIMARY KEY CLUSTERED 
(
	[IndexName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[MSSQL_logins]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[MSSQL_logins](
	[login_id] [nvarchar](128) NOT NULL,
	[Type] [nchar](1) NULL,
	[GPN] [nvarchar](8) NULL,
	[fullname] [nvarchar](30) NULL,
	[last_update] [datetime] NULL,
	[pwdate] [datetime] NULL,
 CONSTRAINT [MSSQL_logins_PK] PRIMARY KEY CLUSTERED 
(
	[login_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[Table]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Table](
	[TableOwner] [nvarchar](128) NOT NULL,
	[TableName] [nvarchar](255) NOT NULL,
	[dbsDatabaseUID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [PK_Table] PRIMARY KEY CLUSTERED 
(
	[TableOwner] ASC,
	[TableName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[UBSMWE_Errors]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[UBSMWE_Errors](
	[UBSMWE_Error_ID] [bigint] IDENTITY(1,1) NOT NULL,
	[InitialLogTime] [datetime] NOT NULL CONSTRAINT [DF__UBSMWE_Errors__LogTime_Col]  DEFAULT (getdate()),
	[SQLErrorID] [int] NULL,
	[Source] [varchar](128) NULL,
	[command] [varchar](128) NULL,
	[message] [varchar](512) NULL,
	[NeedAlertGenerated] [bit] NOT NULL CONSTRAINT [DF__UBSMWE_Errors__NeedAlertGenerated_Col]  DEFAULT ((1)),
	[ErrorAlertCount] [int] NOT NULL CONSTRAINT [DF__UBSMWE_Errors__ErrorAlertCount_Col]  DEFAULT ((1)),
	[LastErrorEnteredDate] [datetime] NOT NULL CONSTRAINT [DF__UBSMWE_Errors__LastErrorEnteredDate_Col]  DEFAULT (getdate()),
 CONSTRAINT [PK_UBSMWE_Errors] PRIMARY KEY CLUSTERED 
(
	[UBSMWE_Error_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[WorkFlow]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlow](
	[WFID] [uniqueidentifier] NOT NULL,
	[WFName] [nvarchar](255) NOT NULL,
	[WFPriority] [int] NOT NULL,
 CONSTRAINT [PK_WorkFlow] PRIMARY KEY CLUSTERED 
(
	[WFID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowException]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowException](
	[WFExceptionID] [uniqueidentifier] NOT NULL,
	[WFID] [uniqueidentifier] NOT NULL,
	[WFExceptionStartDate] [datetime] NOT NULL,
	[WFExceptionDurationDays] [int] NOT NULL,
	[WFExceptionDurationMinutes] [int] NOT NULL,
	[WFExceptionExists] [int] NOT NULL,
 CONSTRAINT [PK_WorkFlowException] PRIMARY KEY CLUSTERED 
(
	[WFExceptionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowJob]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[WorkFlowJob](
	[WFJobID] [uniqueidentifier] NOT NULL,
	[WFJobName] [nvarchar](255) NOT NULL,
	[WFsysjobsJobID] [uniqueidentifier] NULL,
	[WFJobDescription] [varchar](255) NULL,
	[WFCommand] [nvarchar](255) NULL,
	[WFCommandDatabase] [nvarchar](255) NULL,
	[WFJobStatus] [int] NULL,
	[WFJobStartTime] [varchar](8) NULL,
	[WFJobFreq] [varchar](50) NULL,
	[WFJobNeedsUpdate] [bit] NOT NULL CONSTRAINT [DF_WorkFlowJob_WFJobNeedsUpdate]  DEFAULT ((1)),
	[WFRunWorkFlowFlag] [bit] NOT NULL CONSTRAINT [DF_WorkFlowJob_WFJobIsUserCreated]  DEFAULT ((1)),
 CONSTRAINT [PK_WorkFlowJob] PRIMARY KEY CLUSTERED 
(
	[WFJobID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[WorkFlowJobManifest]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowJobManifest](
	[WFJobID] [uniqueidentifier] NOT NULL,
	[WFID] [uniqueidentifier] NOT NULL,
 CONSTRAINT [PK_WorkFlowJobManifest] PRIMARY KEY CLUSTERED 
(
	[WFJobID] ASC,
	[WFID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowManifest]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowManifest](
	[WFID] [uniqueidentifier] NOT NULL,
	[WFTaskID] [uniqueidentifier] NOT NULL,
	[WFManifestEnabled] [int] NOT NULL CONSTRAINT [DF_WorkFlowManifest_WFManifestEnabled]  DEFAULT ((1)),
 CONSTRAINT [PK_WorkFlowManifest] PRIMARY KEY CLUSTERED 
(
	[WFID] ASC,
	[WFTaskID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowTask]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowTask](
	[WFTaskID] [uniqueidentifier] NOT NULL,
	[WFTaskName] [nvarchar](255) NOT NULL,
	[WFTaskTypeID] [int] NOT NULL,
	[WFTaskEnabled] [int] NOT NULL,
	[WFTaskPriority] [int] NOT NULL,
	[WFTaskIsRunningFlag] [int] NULL,
	[WFTaskJobID] [uniqueidentifier] NULL,
	[dbsDatabaseUID] [uniqueidentifier] NULL,
 CONSTRAINT [PK_WorkFlowTask] PRIMARY KEY CLUSTERED 
(
	[WFTaskID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowTaskDependancies]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowTaskDependancies](
	[WFTaskTypeID] [tinyint] NOT NULL,
	[WFTaskTypeID_Dependancy] [tinyint] NOT NULL,
 CONSTRAINT [IX_WorkFlowTaskDependancies] UNIQUE NONCLUSTERED 
(
	[WFTaskTypeID] ASC,
	[WFTaskTypeID_Dependancy] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowTaskException]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowTaskException](
	[WFTaskExceptionID] [uniqueidentifier] NOT NULL,
	[WFTaskID] [uniqueidentifier] NOT NULL,
	[WFTaskExceptionStartDate] [datetime] NOT NULL,
	[WFTaskExceptionDurationDays] [int] NOT NULL,
	[WFTaskExceptionDurationMinutes] [int] NOT NULL,
	[WFTaskExceptionExists] [int] NOT NULL,
 CONSTRAINT [PK_WorkFlowTaskException] PRIMARY KEY CLUSTERED 
(
	[WFTaskExceptionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowTaskHistory]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowTaskHistory](
	[WFTaskHistoryID] [bigint] IDENTITY(1,1) NOT FOR REPLICATION NOT NULL,
	[WFTaskID] [uniqueidentifier] NOT NULL,
	[WFTaskStartDate] [datetime] NULL,
	[WFTaskEndDate] [datetime] NULL,
	[WFTaskActiveComputerName] [nvarchar](255) NULL,
	[WFTaskIsError] [int] NULL,
	[WFTaskResultText] [nvarchar](2000) NULL,
 CONSTRAINT [PK_WorkFlowTaskHistory] PRIMARY KEY CLUSTERED 
(
	[WFTaskHistoryID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  Table [dbo].[WorkFlowTaskType]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[WorkFlowTaskType](
	[WFTaskTypeID] [int] NOT NULL,
	[WFTaskTypeName] [nvarchar](255) NOT NULL,
	[WFTaskComment] [nvarchar](255) NOT NULL,
	[WFTaskCommand] [nvarchar](255) NULL,
	[WFTaskPreCommand] [nvarchar](255) NULL,
	[WFTaskPostCommand] [nvarchar](255) NULL,
	[WFTaskParam1] [nvarchar](255) NULL,
	[WFTaskParam2] [nvarchar](255) NULL,
	[WFTaskParam3] [nvarchar](255) NULL,
	[WFTaskParam4] [nvarchar](255) NULL,
 CONSTRAINT [PK_WorkFlowTaskType] PRIMARY KEY CLUSTERED 
(
	[WFTaskTypeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
/****** Object:  View [dbo].[uv_dbsDatabaseBackupConfig]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [dbo].[uv_dbsDatabaseBackupConfig]
AS
SELECT TOP 300 db.dbsDatabaseName
			, dbb.dbsDBExternalBackupFlag
			, dbb.dbsDBBackupType
			, cvsub.dbsSubclientName
			, svsubsched.CVSchedulePolicy
			, svsubsched.Enabled as 'SchedEnabled'
			, dbb.dbsDBFileLocation
			, dbb.dbsDBLastFullBackupRun
			, dbb.dbsDBLastLogBackupRun
			, dbb.dbsDBNextFullBackupRun
			, dbb.dbsDBNextLogBackupRun
			, dbe.dbsExceptionActive
			, dbe.dbsAlign
			, dbe.dbsRetain
			, dbe.dbsDatabaseExceptionType
			, dbe.dbsDatabaseExceptionSubType
			, dbeT.dbsD_DBEIsActiveFlag
			, dbeT.dbsD_DBEStartDate
			, dbeT.dbsD_DBEEndDate
FROM DBServices.dbo.dbsDatabase db
LEFT OUTER JOIN DBServices.dbo.dbsCVSubclients cvsub
	ON db.dbsDatabaseUID = cvsub.dbsDatabaseUID
LEFT OUTER JOIN DBServices.dbo.dbsCVSchedule svsubsched
	ON cvsub.dbsSubclientName = svsubsched.CVSubclient
LEFT OUTER JOIN DBServices.dbo.dbsDatabaseBackup dbb
	ON db.dbsDatabaseUID = dbb.dbsDatabaseUID 
LEFT OUTER JOIN DBServices.dbo.dbsD_DBE dbeT 
	ON db.dbsDatabaseUID = dbeT.dbsDatabaseUID
LEFT OUTER JOIN DBServices.dbo.dbsDatabaseException dbe
	ON db.dbsDatabaseUID = dbe.dbsDatabaseUID
WHERE (db.dbsDatabaseIsActive = 1)
	AND db.dbsDatabaseName <> 'tempdb'
ORDER BY db.dbsDatabaseIsSystemObjectFlag, db.dbsDatabaseName


GO
/****** Object:  View [dbo].[uv_dbsDatabaseBackupHist]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [dbo].[uv_dbsDatabaseBackupHist]
AS
SELECT TOP 2000 db.dbsDatabaseName
		, db.dbsDatabaseIsActive 
        , dbh.dbsDBHIsLogFlag
		, dbh.dbsDBHStartDate
		, dbh.dbsDBHEndDate
		, dbh.dbsDBHIsOnDiskFlag
		, dbh.dbsDBHFileName
		, dbh.dbsDBackupProcessorID
		, dbh.dbsDBHSentToNBFlag
FROM DBServices.dbo.dbsDatabase db
LEFT OUTER JOIN DBServices.dbo.dbsDatabaseBackupHistory dbh
	ON db.dbsDatabaseUID = dbh.dbsDatabaseUID
WHERE     (db.dbsDatabaseName <> N'tempdb')
GROUP BY db.dbsDatabaseIsActive, db.dbsDatabaseName,dbh.dbsDBHStartDate, dbh.dbsDBHIsLogFlag, dbh.dbsDBHEndDate, dbh.dbsDBHIsOnDiskFlag, dbh.dbsDBHSentToNBFlag, dbh.dbsDBackupProcessorID, dbh.dbsDBHFileName
ORDER BY dbh.dbsDBHStartDate DESC

GO
/****** Object:  View [dbo].[uv_dbsDatabaseIndexStatus]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[uv_dbsDatabaseIndexStatus]
AS
SELECT TOP 2000
	 dbsDFGEntryTime
	, dbsDatabaseName
	, ObjectName
	, IndexId
	, IndexType
	, Partition_number
	, ReIndexStatus
	, CountPages
	, avg_fragmentation_in_percent
	, AvgRecSize
	, RecCount
	, avg_page_space_used_in_percent
	, avg_fragment_size_in_pages
	, ReIndexTime
	, data_compression_desc
	, forwarded_record_count
FROM dbo.dbsIndexDFRG
GROUP BY
	 dbsDatabaseName
	, ObjectName
	, IndexId
	, IndexType
	, Partition_number
	, ReIndexStatus
	, CountPages
	, avg_fragmentation_in_percent
	, AvgRecSize
	, RecCount
	, avg_page_space_used_in_percent
	, avg_fragment_size_in_pages
	, ReIndexTime
	, data_compression_desc
	, forwarded_record_count
	, dbsDFGEntryTime 
HAVING (dbsDatabaseName <> N'tempdb')
ORDER BY
	dbsDatabaseName
	, CountPages DESC
	, avg_fragmentation_in_percent DESC
	, ObjectName
	, IndexId
	, Partition_number

GO
/****** Object:  View [dbo].[uv_dbsDatabaseWorkFlowDetails]    Script Date: 9/14/2016 5:15:52 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [dbo].[uv_dbsDatabaseWorkFlowDetails]
AS
SELECT TOP (100) PERCENT 
	db.dbsDatabaseName
	, wfj.WFJobName
	, wfj.WFJobStartTime
	, wft.WFTaskName
	, wft.WFTaskEnabled
	, wfEx.WFExceptionExists
	, wfEx.WFExceptionStartDate
	, wfEx.WFExceptionDurationDays
	, wfEx.WFExceptionDurationMinutes
	, wftEx.WFTaskExceptionExists
	, wftEx.WFTaskExceptionStartDate
	, wftEx.WFTaskExceptionDurationDays
	, wftEx.WFTaskExceptionDurationMinutes
FROM  dbo.WorkFlowJobManifest
INNER JOIN dbo.WorkFlow wf
	ON dbo.WorkFlowJobManifest.WFID = wf.WFID 
INNER JOIN dbo.WorkFlowJob wfj
	ON dbo.WorkFlowJobManifest.WFJobID = wfj.WFJobID
INNER JOIN dbo.WorkFlowManifest wfman
	ON wf.WFID = wfman.WFID
INNER JOIN dbo.WorkFlowTask wft
	ON wfman.WFTaskID = wft.WFTaskID
INNER JOIN dbo.dbsDatabase db
	ON wft.dbsDatabaseUID = db.dbsDatabaseUID 
LEFT OUTER JOIN dbo.WorkFlowException wfEx
	ON wf.WFID = wfEx.WFID
LEFT OUTER JOIN dbo.WorkFlowTaskException wftEx
	ON wft.WFTaskID = wftEx.WFTaskID
WHERE db.dbsDatabaseIsActive = 1
	AND db.dbsDatabaseName <> 'tempdb'
	AND wfman.WFManifestEnabled = 1
GROUP BY 
	db.dbsDatabaseIsSystemObjectFlag 
	,db.dbsDatabaseName
	, wfj.WFJobName
	, wft.WFTaskName
	, wfj.WFJobStartTime
	, wfEx.WFExceptionExists
	, wfEx.WFExceptionStartDate
	, wfEx.WFExceptionDurationDays
	, wfEx.WFExceptionDurationMinutes
	, wft.WFTaskEnabled
	, wftEx.WFTaskExceptionExists
	, wftEx.WFTaskExceptionStartDate
	, wftEx.WFTaskExceptionDurationDays
	, wftEx.WFTaskExceptionDurationMinutes
ORDER BY db.dbsDatabaseIsSystemObjectFlag, db.dbsDatabaseName, wfj.WFJobName

GO
SET ANSI_PADDING ON

GO
/****** Object:  Index [inxLogin]    Script Date: 9/14/2016 5:15:52 PM ******/
CREATE UNIQUE CLUSTERED INDEX [inxLogin] ON [dbo].[aacScrubberAccounts]
(
	[Login] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
SET ANSI_PADDING ON

GO
/****** Object:  Index [IX_dbsInstanceConfig]    Script Date: 9/14/2016 5:15:52 PM ******/
CREATE UNIQUE CLUSTERED INDEX [IX_dbsInstanceConfig] ON [dbo].[dbsInstanceConfig]
(
	[dbsInstanceConfigName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
/****** Object:  Index [IX_dbsDatabaseBackupHistory_dbsDatabaseUID]    Script Date: 9/14/2016 5:15:52 PM ******/
CREATE NONCLUSTERED INDEX [IX_dbsDatabaseBackupHistory_dbsDatabaseUID] ON [dbo].[dbsDatabaseBackupHistory]
(
	[dbsDatabaseUID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
SET ANSI_PADDING ON

GO
/****** Object:  Index [IX_dbsIndexDFRG_db_obj_ind_par]    Script Date: 9/14/2016 5:15:52 PM ******/
CREATE NONCLUSTERED INDEX [IX_dbsIndexDFRG_db_obj_ind_par] ON [dbo].[dbsIndexDFRG]
(
	[dbsDatabaseName] ASC,
	[ObjectId] ASC,
	[IndexId] ASC,
	[Partition_number] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
/****** Object:  Index [IX_dbsMSSQLCentralCommandQueue]    Script Date: 9/14/2016 5:15:52 PM ******/
CREATE NONCLUSTERED INDEX [IX_dbsMSSQLCentralCommandQueue] ON [dbo].[dbsMSSQLCentralCommandQueue]
(
	[MSCCQID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
ALTER TABLE [dbo].[Index] ADD  CONSTRAINT [DF_Index_EnableRebuildFlag]  DEFAULT ((1)) FOR [DisableRebuildFlag]
GO
ALTER TABLE [dbo].[Table] ADD  CONSTRAINT [DF_Table_TableOwner]  DEFAULT ('dbo') FOR [TableOwner]
GO
ALTER TABLE [dbo].[dbsD_DBE]  WITH CHECK ADD  CONSTRAINT [FK_dbs_DBE_dbsDatabase] FOREIGN KEY([dbsDatabaseUID])
REFERENCES [dbo].[dbsDatabase] ([dbsDatabaseUID])
GO
ALTER TABLE [dbo].[dbsD_DBE] CHECK CONSTRAINT [FK_dbs_DBE_dbsDatabase]
GO
ALTER TABLE [dbo].[dbsD_DBE]  WITH CHECK ADD  CONSTRAINT [FK_dbsD_DBE_dbsDatabaseBackupException] FOREIGN KEY([dbsDatabaseBackupExceptionID])
REFERENCES [dbo].[dbsDatabaseBackupException] ([dbsDatabaseBackupExceptionID])
GO
ALTER TABLE [dbo].[dbsD_DBE] CHECK CONSTRAINT [FK_dbsD_DBE_dbsDatabaseBackupException]
GO
ALTER TABLE [dbo].[dbsDatabaseBackup]  WITH CHECK ADD  CONSTRAINT [FK_dbsDatabaseBackupHeader_dbsDatabase] FOREIGN KEY([dbsDatabaseUID])
REFERENCES [dbo].[dbsDatabase] ([dbsDatabaseUID])
GO
ALTER TABLE [dbo].[dbsDatabaseBackup] CHECK CONSTRAINT [FK_dbsDatabaseBackupHeader_dbsDatabase]
GO
ALTER TABLE [dbo].[dbsDatabaseBackupHistory]  WITH CHECK ADD  CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabase] FOREIGN KEY([dbsDatabaseUID])
REFERENCES [dbo].[dbsDatabase] ([dbsDatabaseUID])
GO
ALTER TABLE [dbo].[dbsDatabaseBackupHistory] CHECK CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabase]
GO
ALTER TABLE [dbo].[dbsDatabaseBackupHistory]  WITH NOCHECK ADD  CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabaseBackupProcessor] FOREIGN KEY([dbsDBackupProcessorID])
REFERENCES [dbo].[dbsDatabaseBackupProcessor] ([dbsDatabaseBackupProcessorID])
NOT FOR REPLICATION 
GO
ALTER TABLE [dbo].[dbsDatabaseBackupHistory] NOCHECK CONSTRAINT [FK_dbsDatabaseBackupHistory_dbsDatabaseBackupProcessor]
GO
ALTER TABLE [dbo].[dbsMSSQLCentralCommandQueueExtendedError]  WITH NOCHECK ADD  CONSTRAINT [FK_dbsMSSQLCentralCommandQueueExtendedError_dbsMSSQLCentralCommandQueue] FOREIGN KEY([MSCCQID])
REFERENCES [dbo].[dbsMSSQLCentralCommandQueue] ([MSCCQID])
ON DELETE CASCADE
NOT FOR REPLICATION 
GO
ALTER TABLE [dbo].[dbsMSSQLCentralCommandQueueExtendedError] CHECK CONSTRAINT [FK_dbsMSSQLCentralCommandQueueExtendedError_dbsMSSQLCentralCommandQueue]
GO
ALTER TABLE [dbo].[dbsNetbackupManifest]  WITH CHECK ADD  CONSTRAINT [FK_dbsNetbackupManifest_dbsDatabaseBackupHistory] FOREIGN KEY([dbsDBHID])
REFERENCES [dbo].[dbsDatabaseBackupHistory] ([dbsDBHID])
GO
ALTER TABLE [dbo].[dbsNetbackupManifest] CHECK CONSTRAINT [FK_dbsNetbackupManifest_dbsDatabaseBackupHistory]
GO
ALTER TABLE [dbo].[dbsNetbackupManifest]  WITH CHECK ADD  CONSTRAINT [FK_dbsNetbackupManifest_dbsNetbackup] FOREIGN KEY([dbsNetbackupID])
REFERENCES [dbo].[dbsNetbackup] ([dbsNetbackupID])
GO
ALTER TABLE [dbo].[dbsNetbackupManifest] CHECK CONSTRAINT [FK_dbsNetbackupManifest_dbsNetbackup]
GO
ALTER TABLE [dbo].[dbsNetbackupStatus]  WITH CHECK ADD  CONSTRAINT [FK_dbsNetbackupStatus_dbsNetbackup] FOREIGN KEY([dbsNetbackupID])
REFERENCES [dbo].[dbsNetbackup] ([dbsNetbackupID])
GO
ALTER TABLE [dbo].[dbsNetbackupStatus] CHECK CONSTRAINT [FK_dbsNetbackupStatus_dbsNetbackup]
GO
ALTER TABLE [dbo].[Index]  WITH CHECK ADD  CONSTRAINT [FK_Index_Table1] FOREIGN KEY([TableOwner], [TableName])
REFERENCES [dbo].[Table] ([TableOwner], [TableName])
GO
ALTER TABLE [dbo].[Index] CHECK CONSTRAINT [FK_Index_Table1]
GO
ALTER TABLE [dbo].[Table]  WITH CHECK ADD  CONSTRAINT [FK_dbsTable_dbsDatabase] FOREIGN KEY([dbsDatabaseUID])
REFERENCES [dbo].[dbsDatabase] ([dbsDatabaseUID])
GO
ALTER TABLE [dbo].[Table] CHECK CONSTRAINT [FK_dbsTable_dbsDatabase]
GO
ALTER TABLE [dbo].[WorkFlowException]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowException_WorkFlow] FOREIGN KEY([WFID])
REFERENCES [dbo].[WorkFlow] ([WFID])
GO
ALTER TABLE [dbo].[WorkFlowException] CHECK CONSTRAINT [FK_WorkFlowException_WorkFlow]
GO
ALTER TABLE [dbo].[WorkFlowJobManifest]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowJobManifest_WorkFlow] FOREIGN KEY([WFID])
REFERENCES [dbo].[WorkFlow] ([WFID])
GO
ALTER TABLE [dbo].[WorkFlowJobManifest] CHECK CONSTRAINT [FK_WorkFlowJobManifest_WorkFlow]
GO
ALTER TABLE [dbo].[WorkFlowJobManifest]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowJobManifest_WorkFlowJob] FOREIGN KEY([WFJobID])
REFERENCES [dbo].[WorkFlowJob] ([WFJobID])
GO
ALTER TABLE [dbo].[WorkFlowJobManifest] CHECK CONSTRAINT [FK_WorkFlowJobManifest_WorkFlowJob]
GO
ALTER TABLE [dbo].[WorkFlowManifest]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowManifest_WorkFlow] FOREIGN KEY([WFID])
REFERENCES [dbo].[WorkFlow] ([WFID])
GO
ALTER TABLE [dbo].[WorkFlowManifest] CHECK CONSTRAINT [FK_WorkFlowManifest_WorkFlow]
GO
ALTER TABLE [dbo].[WorkFlowManifest]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowManifest_WorkFlowTask] FOREIGN KEY([WFTaskID])
REFERENCES [dbo].[WorkFlowTask] ([WFTaskID])
GO
ALTER TABLE [dbo].[WorkFlowManifest] CHECK CONSTRAINT [FK_WorkFlowManifest_WorkFlowTask]
GO
ALTER TABLE [dbo].[WorkFlowTask]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowTask_dbsDatabase] FOREIGN KEY([dbsDatabaseUID])
REFERENCES [dbo].[dbsDatabase] ([dbsDatabaseUID])
GO
ALTER TABLE [dbo].[WorkFlowTask] CHECK CONSTRAINT [FK_WorkFlowTask_dbsDatabase]
GO
ALTER TABLE [dbo].[WorkFlowTask]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowTask_WorkFlowTaskType] FOREIGN KEY([WFTaskTypeID])
REFERENCES [dbo].[WorkFlowTaskType] ([WFTaskTypeID])
GO
ALTER TABLE [dbo].[WorkFlowTask] CHECK CONSTRAINT [FK_WorkFlowTask_WorkFlowTaskType]
GO
ALTER TABLE [dbo].[WorkFlowTaskException]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowTaskException_WorkFlowTask] FOREIGN KEY([WFTaskID])
REFERENCES [dbo].[WorkFlowTask] ([WFTaskID])
GO
ALTER TABLE [dbo].[WorkFlowTaskException] CHECK CONSTRAINT [FK_WorkFlowTaskException_WorkFlowTask]
GO
ALTER TABLE [dbo].[WorkFlowTaskHistory]  WITH CHECK ADD  CONSTRAINT [FK_WorkFlowTaskHistory_WorkFlowTask] FOREIGN KEY([WFTaskID])
REFERENCES [dbo].[WorkFlowTask] ([WFTaskID])
GO
ALTER TABLE [dbo].[WorkFlowTaskHistory] CHECK CONSTRAINT [FK_WorkFlowTaskHistory_WorkFlowTask]
GO
USE [master]
GO
ALTER DATABASE [DBServices] SET  READ_WRITE 
GO
*/
